
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model Post
 * 
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model ReviewReply
 * 
 */
export type ReviewReply = $Result.DefaultSelection<Prisma.$ReviewReplyPayload>
/**
 * Model AIReplyTemplate
 * 
 */
export type AIReplyTemplate = $Result.DefaultSelection<Prisma.$AIReplyTemplatePayload>
/**
 * Model Insight
 * 
 */
export type Insight = $Result.DefaultSelection<Prisma.$InsightPayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model ReportJob
 * 
 */
export type ReportJob = $Result.DefaultSelection<Prisma.$ReportJobPayload>
/**
 * Model SearchKeyword
 * 
 */
export type SearchKeyword = $Result.DefaultSelection<Prisma.$SearchKeywordPayload>
/**
 * Model RankTrackingResult
 * 
 */
export type RankTrackingResult = $Result.DefaultSelection<Prisma.$RankTrackingResultPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const PostType: {
  WHATS_NEW: 'WHATS_NEW',
  EVENT: 'EVENT',
  OFFER: 'OFFER'
};

export type PostType = (typeof PostType)[keyof typeof PostType]


export const PostStatus: {
  DRAFT: 'DRAFT',
  SCHEDULED: 'SCHEDULED',
  PUBLISHED: 'PUBLISHED',
  FAILED: 'FAILED',
  DELETED: 'DELETED'
};

export type PostStatus = (typeof PostStatus)[keyof typeof PostStatus]


export const RecurType: {
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY'
};

export type RecurType = (typeof RecurType)[keyof typeof RecurType]


export const ReviewStatus: {
  PENDING: 'PENDING',
  REPLIED: 'REPLIED',
  FLAGGED: 'FLAGGED'
};

export type ReviewStatus = (typeof ReviewStatus)[keyof typeof ReviewStatus]


export const SentimentType: {
  POSITIVE: 'POSITIVE',
  NEUTRAL: 'NEUTRAL',
  NEGATIVE: 'NEGATIVE'
};

export type SentimentType = (typeof SentimentType)[keyof typeof SentimentType]


export const ReplySource: {
  MANUAL: 'MANUAL',
  AI_GENERATED: 'AI_GENERATED',
  AUTO_POSTED: 'AUTO_POSTED'
};

export type ReplySource = (typeof ReplySource)[keyof typeof ReplySource]


export const ReplyTone: {
  FORMAL: 'FORMAL',
  FRIENDLY: 'FRIENDLY',
  APOLOGETIC: 'APOLOGETIC'
};

export type ReplyTone = (typeof ReplyTone)[keyof typeof ReplyTone]


export const InsightType: {
  VIEWS: 'VIEWS',
  SEARCHES: 'SEARCHES',
  CLICKS: 'CLICKS',
  DIRECTION_REQUESTS: 'DIRECTION_REQUESTS',
  PHONE_CALLS: 'PHONE_CALLS',
  PHOTOS_VIEWED: 'PHOTOS_VIEWED',
  PHOTO_QUANTITY: 'PHOTO_QUANTITY',
  WEBSITE_CLICKS: 'WEBSITE_CLICKS',
  CALL_CLICKS: 'CALL_CLICKS',
  BUSINESS_IMPRESSIONS_MOBILE_MAPS: 'BUSINESS_IMPRESSIONS_MOBILE_MAPS',
  BUSINESS_IMPRESSIONS_MOBILE_SEARCH: 'BUSINESS_IMPRESSIONS_MOBILE_SEARCH',
  BUSINESS_IMPRESSIONS_DESKTOP_MAPS: 'BUSINESS_IMPRESSIONS_DESKTOP_MAPS',
  BUSINESS_IMPRESSIONS_DESKTOP_SEARCH: 'BUSINESS_IMPRESSIONS_DESKTOP_SEARCH',
  BUSINESS_BOOKINGS: 'BUSINESS_BOOKINGS',
  BUSINESS_FOOD_ORDERS: 'BUSINESS_FOOD_ORDERS',
  BUSINESS_FOOD_MENU_CLICKS: 'BUSINESS_FOOD_MENU_CLICKS',
  BUSINESS_CONVERSATIONS: 'BUSINESS_CONVERSATIONS'
};

export type InsightType = (typeof InsightType)[keyof typeof InsightType]


export const ReportType: {
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY',
  CUSTOM: 'CUSTOM'
};

export type ReportType = (typeof ReportType)[keyof typeof ReportType]


export const ReportStatus: {
  GENERATING: 'GENERATING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type ReportStatus = (typeof ReportStatus)[keyof typeof ReportStatus]


export const ReportFrequency: {
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY'
};

export type ReportFrequency = (typeof ReportFrequency)[keyof typeof ReportFrequency]


export const SubscriptionStatus: {
  INACTIVE: 'INACTIVE',
  TRIALING: 'TRIALING',
  ACTIVE: 'ACTIVE',
  PAST_DUE: 'PAST_DUE',
  CANCELED: 'CANCELED',
  EXPIRED: 'EXPIRED'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


export const SubscriptionPlan: {
  FREE: 'FREE',
  BASIC: 'BASIC',
  PREMIUM: 'PREMIUM',
  ENTERPRISE: 'ENTERPRISE'
};

export type SubscriptionPlan = (typeof SubscriptionPlan)[keyof typeof SubscriptionPlan]

}

export type PostType = $Enums.PostType

export const PostType: typeof $Enums.PostType

export type PostStatus = $Enums.PostStatus

export const PostStatus: typeof $Enums.PostStatus

export type RecurType = $Enums.RecurType

export const RecurType: typeof $Enums.RecurType

export type ReviewStatus = $Enums.ReviewStatus

export const ReviewStatus: typeof $Enums.ReviewStatus

export type SentimentType = $Enums.SentimentType

export const SentimentType: typeof $Enums.SentimentType

export type ReplySource = $Enums.ReplySource

export const ReplySource: typeof $Enums.ReplySource

export type ReplyTone = $Enums.ReplyTone

export const ReplyTone: typeof $Enums.ReplyTone

export type InsightType = $Enums.InsightType

export const InsightType: typeof $Enums.InsightType

export type ReportType = $Enums.ReportType

export const ReportType: typeof $Enums.ReportType

export type ReportStatus = $Enums.ReportStatus

export const ReportStatus: typeof $Enums.ReportStatus

export type ReportFrequency = $Enums.ReportFrequency

export const ReportFrequency: typeof $Enums.ReportFrequency

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

export type SubscriptionPlan = $Enums.SubscriptionPlan

export const SubscriptionPlan: typeof $Enums.SubscriptionPlan

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reviewReply`: Exposes CRUD operations for the **ReviewReply** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReviewReplies
    * const reviewReplies = await prisma.reviewReply.findMany()
    * ```
    */
  get reviewReply(): Prisma.ReviewReplyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIReplyTemplate`: Exposes CRUD operations for the **AIReplyTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIReplyTemplates
    * const aIReplyTemplates = await prisma.aIReplyTemplate.findMany()
    * ```
    */
  get aIReplyTemplate(): Prisma.AIReplyTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.insight`: Exposes CRUD operations for the **Insight** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Insights
    * const insights = await prisma.insight.findMany()
    * ```
    */
  get insight(): Prisma.InsightDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reportJob`: Exposes CRUD operations for the **ReportJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportJobs
    * const reportJobs = await prisma.reportJob.findMany()
    * ```
    */
  get reportJob(): Prisma.ReportJobDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.searchKeyword`: Exposes CRUD operations for the **SearchKeyword** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SearchKeywords
    * const searchKeywords = await prisma.searchKeyword.findMany()
    * ```
    */
  get searchKeyword(): Prisma.SearchKeywordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rankTrackingResult`: Exposes CRUD operations for the **RankTrackingResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RankTrackingResults
    * const rankTrackingResults = await prisma.rankTrackingResult.findMany()
    * ```
    */
  get rankTrackingResult(): Prisma.RankTrackingResultDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    Organization: 'Organization',
    Location: 'Location',
    Post: 'Post',
    Review: 'Review',
    ReviewReply: 'ReviewReply',
    AIReplyTemplate: 'AIReplyTemplate',
    Insight: 'Insight',
    Report: 'Report',
    ReportJob: 'ReportJob',
    SearchKeyword: 'SearchKeyword',
    RankTrackingResult: 'RankTrackingResult'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "session" | "organization" | "location" | "post" | "review" | "reviewReply" | "aIReplyTemplate" | "insight" | "report" | "reportJob" | "searchKeyword" | "rankTrackingResult"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      ReviewReply: {
        payload: Prisma.$ReviewReplyPayload<ExtArgs>
        fields: Prisma.ReviewReplyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewReplyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReplyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewReplyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReplyPayload>
          }
          findFirst: {
            args: Prisma.ReviewReplyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReplyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewReplyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReplyPayload>
          }
          findMany: {
            args: Prisma.ReviewReplyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReplyPayload>[]
          }
          create: {
            args: Prisma.ReviewReplyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReplyPayload>
          }
          createMany: {
            args: Prisma.ReviewReplyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewReplyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReplyPayload>[]
          }
          delete: {
            args: Prisma.ReviewReplyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReplyPayload>
          }
          update: {
            args: Prisma.ReviewReplyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReplyPayload>
          }
          deleteMany: {
            args: Prisma.ReviewReplyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewReplyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewReplyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReplyPayload>[]
          }
          upsert: {
            args: Prisma.ReviewReplyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReplyPayload>
          }
          aggregate: {
            args: Prisma.ReviewReplyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReviewReply>
          }
          groupBy: {
            args: Prisma.ReviewReplyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewReplyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewReplyCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewReplyCountAggregateOutputType> | number
          }
        }
      }
      AIReplyTemplate: {
        payload: Prisma.$AIReplyTemplatePayload<ExtArgs>
        fields: Prisma.AIReplyTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIReplyTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIReplyTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIReplyTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIReplyTemplatePayload>
          }
          findFirst: {
            args: Prisma.AIReplyTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIReplyTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIReplyTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIReplyTemplatePayload>
          }
          findMany: {
            args: Prisma.AIReplyTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIReplyTemplatePayload>[]
          }
          create: {
            args: Prisma.AIReplyTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIReplyTemplatePayload>
          }
          createMany: {
            args: Prisma.AIReplyTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIReplyTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIReplyTemplatePayload>[]
          }
          delete: {
            args: Prisma.AIReplyTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIReplyTemplatePayload>
          }
          update: {
            args: Prisma.AIReplyTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIReplyTemplatePayload>
          }
          deleteMany: {
            args: Prisma.AIReplyTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIReplyTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIReplyTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIReplyTemplatePayload>[]
          }
          upsert: {
            args: Prisma.AIReplyTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIReplyTemplatePayload>
          }
          aggregate: {
            args: Prisma.AIReplyTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIReplyTemplate>
          }
          groupBy: {
            args: Prisma.AIReplyTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIReplyTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIReplyTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<AIReplyTemplateCountAggregateOutputType> | number
          }
        }
      }
      Insight: {
        payload: Prisma.$InsightPayload<ExtArgs>
        fields: Prisma.InsightFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InsightFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InsightFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPayload>
          }
          findFirst: {
            args: Prisma.InsightFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InsightFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPayload>
          }
          findMany: {
            args: Prisma.InsightFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPayload>[]
          }
          create: {
            args: Prisma.InsightCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPayload>
          }
          createMany: {
            args: Prisma.InsightCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InsightCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPayload>[]
          }
          delete: {
            args: Prisma.InsightDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPayload>
          }
          update: {
            args: Prisma.InsightUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPayload>
          }
          deleteMany: {
            args: Prisma.InsightDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InsightUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InsightUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPayload>[]
          }
          upsert: {
            args: Prisma.InsightUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPayload>
          }
          aggregate: {
            args: Prisma.InsightAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInsight>
          }
          groupBy: {
            args: Prisma.InsightGroupByArgs<ExtArgs>
            result: $Utils.Optional<InsightGroupByOutputType>[]
          }
          count: {
            args: Prisma.InsightCountArgs<ExtArgs>
            result: $Utils.Optional<InsightCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      ReportJob: {
        payload: Prisma.$ReportJobPayload<ExtArgs>
        fields: Prisma.ReportJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportJobPayload>
          }
          findFirst: {
            args: Prisma.ReportJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportJobPayload>
          }
          findMany: {
            args: Prisma.ReportJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportJobPayload>[]
          }
          create: {
            args: Prisma.ReportJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportJobPayload>
          }
          createMany: {
            args: Prisma.ReportJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportJobPayload>[]
          }
          delete: {
            args: Prisma.ReportJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportJobPayload>
          }
          update: {
            args: Prisma.ReportJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportJobPayload>
          }
          deleteMany: {
            args: Prisma.ReportJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportJobUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportJobPayload>[]
          }
          upsert: {
            args: Prisma.ReportJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportJobPayload>
          }
          aggregate: {
            args: Prisma.ReportJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReportJob>
          }
          groupBy: {
            args: Prisma.ReportJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportJobCountArgs<ExtArgs>
            result: $Utils.Optional<ReportJobCountAggregateOutputType> | number
          }
        }
      }
      SearchKeyword: {
        payload: Prisma.$SearchKeywordPayload<ExtArgs>
        fields: Prisma.SearchKeywordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SearchKeywordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchKeywordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SearchKeywordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchKeywordPayload>
          }
          findFirst: {
            args: Prisma.SearchKeywordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchKeywordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SearchKeywordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchKeywordPayload>
          }
          findMany: {
            args: Prisma.SearchKeywordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchKeywordPayload>[]
          }
          create: {
            args: Prisma.SearchKeywordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchKeywordPayload>
          }
          createMany: {
            args: Prisma.SearchKeywordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SearchKeywordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchKeywordPayload>[]
          }
          delete: {
            args: Prisma.SearchKeywordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchKeywordPayload>
          }
          update: {
            args: Prisma.SearchKeywordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchKeywordPayload>
          }
          deleteMany: {
            args: Prisma.SearchKeywordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SearchKeywordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SearchKeywordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchKeywordPayload>[]
          }
          upsert: {
            args: Prisma.SearchKeywordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchKeywordPayload>
          }
          aggregate: {
            args: Prisma.SearchKeywordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSearchKeyword>
          }
          groupBy: {
            args: Prisma.SearchKeywordGroupByArgs<ExtArgs>
            result: $Utils.Optional<SearchKeywordGroupByOutputType>[]
          }
          count: {
            args: Prisma.SearchKeywordCountArgs<ExtArgs>
            result: $Utils.Optional<SearchKeywordCountAggregateOutputType> | number
          }
        }
      }
      RankTrackingResult: {
        payload: Prisma.$RankTrackingResultPayload<ExtArgs>
        fields: Prisma.RankTrackingResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RankTrackingResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankTrackingResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RankTrackingResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankTrackingResultPayload>
          }
          findFirst: {
            args: Prisma.RankTrackingResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankTrackingResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RankTrackingResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankTrackingResultPayload>
          }
          findMany: {
            args: Prisma.RankTrackingResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankTrackingResultPayload>[]
          }
          create: {
            args: Prisma.RankTrackingResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankTrackingResultPayload>
          }
          createMany: {
            args: Prisma.RankTrackingResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RankTrackingResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankTrackingResultPayload>[]
          }
          delete: {
            args: Prisma.RankTrackingResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankTrackingResultPayload>
          }
          update: {
            args: Prisma.RankTrackingResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankTrackingResultPayload>
          }
          deleteMany: {
            args: Prisma.RankTrackingResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RankTrackingResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RankTrackingResultUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankTrackingResultPayload>[]
          }
          upsert: {
            args: Prisma.RankTrackingResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankTrackingResultPayload>
          }
          aggregate: {
            args: Prisma.RankTrackingResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRankTrackingResult>
          }
          groupBy: {
            args: Prisma.RankTrackingResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<RankTrackingResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.RankTrackingResultCountArgs<ExtArgs>
            result: $Utils.Optional<RankTrackingResultCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    session?: SessionOmit
    organization?: OrganizationOmit
    location?: LocationOmit
    post?: PostOmit
    review?: ReviewOmit
    reviewReply?: ReviewReplyOmit
    aIReplyTemplate?: AIReplyTemplateOmit
    insight?: InsightOmit
    report?: ReportOmit
    reportJob?: ReportJobOmit
    searchKeyword?: SearchKeywordOmit
    rankTrackingResult?: RankTrackingResultOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    ownedOrganizations: number
    posts: number
    reviewReplies: number
    sessions: number
    locations: number
    organizations: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownedOrganizations?: boolean | UserCountOutputTypeCountOwnedOrganizationsArgs
    posts?: boolean | UserCountOutputTypeCountPostsArgs
    reviewReplies?: boolean | UserCountOutputTypeCountReviewRepliesArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    locations?: boolean | UserCountOutputTypeCountLocationsArgs
    organizations?: boolean | UserCountOutputTypeCountOrganizationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedOrganizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewReplyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrganizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
  }


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    aiTemplates: number
    locations: number
    reportJobs: number
    members: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aiTemplates?: boolean | OrganizationCountOutputTypeCountAiTemplatesArgs
    locations?: boolean | OrganizationCountOutputTypeCountLocationsArgs
    reportJobs?: boolean | OrganizationCountOutputTypeCountReportJobsArgs
    members?: boolean | OrganizationCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountAiTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIReplyTemplateWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountReportJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportJobWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    insights: number
    posts: number
    reports: number
    reviews: number
    users: number
    searchKeywords: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insights?: boolean | LocationCountOutputTypeCountInsightsArgs
    posts?: boolean | LocationCountOutputTypeCountPostsArgs
    reports?: boolean | LocationCountOutputTypeCountReportsArgs
    reviews?: boolean | LocationCountOutputTypeCountReviewsArgs
    users?: boolean | LocationCountOutputTypeCountUsersArgs
    searchKeywords?: boolean | LocationCountOutputTypeCountSearchKeywordsArgs
  }

  // Custom InputTypes
  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountInsightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsightWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountSearchKeywordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchKeywordWhereInput
  }


  /**
   * Count Type ReviewCountOutputType
   */

  export type ReviewCountOutputType = {
    replies: number
  }

  export type ReviewCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | ReviewCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes
  /**
   * ReviewCountOutputType without action
   */
  export type ReviewCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewCountOutputType
     */
    select?: ReviewCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReviewCountOutputType without action
   */
  export type ReviewCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewReplyWhereInput
  }


  /**
   * Count Type AIReplyTemplateCountOutputType
   */

  export type AIReplyTemplateCountOutputType = {
    replies: number
  }

  export type AIReplyTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | AIReplyTemplateCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes
  /**
   * AIReplyTemplateCountOutputType without action
   */
  export type AIReplyTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIReplyTemplateCountOutputType
     */
    select?: AIReplyTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AIReplyTemplateCountOutputType without action
   */
  export type AIReplyTemplateCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewReplyWhereInput
  }


  /**
   * Count Type SearchKeywordCountOutputType
   */

  export type SearchKeywordCountOutputType = {
    rankResults: number
  }

  export type SearchKeywordCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rankResults?: boolean | SearchKeywordCountOutputTypeCountRankResultsArgs
  }

  // Custom InputTypes
  /**
   * SearchKeywordCountOutputType without action
   */
  export type SearchKeywordCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchKeywordCountOutputType
     */
    select?: SearchKeywordCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SearchKeywordCountOutputType without action
   */
  export type SearchKeywordCountOutputTypeCountRankResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RankTrackingResultWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    emailVerificationToken: string | null
    password: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    googleAccessToken: string | null
    googleRefreshToken: string | null
    googleTokenExpiresAt: Date | null
    subscriptionId: string | null
    subscriptionStatus: $Enums.SubscriptionStatus | null
    subscriptionPlan: $Enums.SubscriptionPlan | null
    trialStartedAt: Date | null
    trialEndsAt: Date | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    razorpayCustomerId: string | null
    razorpayPaymentId: string | null
    razorpayOrderId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    emailVerificationToken: string | null
    password: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    googleAccessToken: string | null
    googleRefreshToken: string | null
    googleTokenExpiresAt: Date | null
    subscriptionId: string | null
    subscriptionStatus: $Enums.SubscriptionStatus | null
    subscriptionPlan: $Enums.SubscriptionPlan | null
    trialStartedAt: Date | null
    trialEndsAt: Date | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    razorpayCustomerId: string | null
    razorpayPaymentId: string | null
    razorpayOrderId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    emailVerificationToken: number
    password: number
    image: number
    createdAt: number
    updatedAt: number
    googleAccessToken: number
    googleRefreshToken: number
    googleTokenExpiresAt: number
    subscriptionId: number
    subscriptionStatus: number
    subscriptionPlan: number
    trialStartedAt: number
    trialEndsAt: number
    currentPeriodStart: number
    currentPeriodEnd: number
    razorpayCustomerId: number
    razorpayPaymentId: number
    razorpayOrderId: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    emailVerificationToken?: true
    password?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    googleAccessToken?: true
    googleRefreshToken?: true
    googleTokenExpiresAt?: true
    subscriptionId?: true
    subscriptionStatus?: true
    subscriptionPlan?: true
    trialStartedAt?: true
    trialEndsAt?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    razorpayCustomerId?: true
    razorpayPaymentId?: true
    razorpayOrderId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    emailVerificationToken?: true
    password?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    googleAccessToken?: true
    googleRefreshToken?: true
    googleTokenExpiresAt?: true
    subscriptionId?: true
    subscriptionStatus?: true
    subscriptionPlan?: true
    trialStartedAt?: true
    trialEndsAt?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    razorpayCustomerId?: true
    razorpayPaymentId?: true
    razorpayOrderId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    emailVerificationToken?: true
    password?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    googleAccessToken?: true
    googleRefreshToken?: true
    googleTokenExpiresAt?: true
    subscriptionId?: true
    subscriptionStatus?: true
    subscriptionPlan?: true
    trialStartedAt?: true
    trialEndsAt?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    razorpayCustomerId?: true
    razorpayPaymentId?: true
    razorpayOrderId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    emailVerified: Date | null
    emailVerificationToken: string | null
    password: string
    image: string | null
    createdAt: Date
    updatedAt: Date
    googleAccessToken: string | null
    googleRefreshToken: string | null
    googleTokenExpiresAt: Date | null
    subscriptionId: string | null
    subscriptionStatus: $Enums.SubscriptionStatus | null
    subscriptionPlan: $Enums.SubscriptionPlan | null
    trialStartedAt: Date | null
    trialEndsAt: Date | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    razorpayCustomerId: string | null
    razorpayPaymentId: string | null
    razorpayOrderId: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    emailVerificationToken?: boolean
    password?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    googleAccessToken?: boolean
    googleRefreshToken?: boolean
    googleTokenExpiresAt?: boolean
    subscriptionId?: boolean
    subscriptionStatus?: boolean
    subscriptionPlan?: boolean
    trialStartedAt?: boolean
    trialEndsAt?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    razorpayCustomerId?: boolean
    razorpayPaymentId?: boolean
    razorpayOrderId?: boolean
    ownedOrganizations?: boolean | User$ownedOrganizationsArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    reviewReplies?: boolean | User$reviewRepliesArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    locations?: boolean | User$locationsArgs<ExtArgs>
    organizations?: boolean | User$organizationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    emailVerificationToken?: boolean
    password?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    googleAccessToken?: boolean
    googleRefreshToken?: boolean
    googleTokenExpiresAt?: boolean
    subscriptionId?: boolean
    subscriptionStatus?: boolean
    subscriptionPlan?: boolean
    trialStartedAt?: boolean
    trialEndsAt?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    razorpayCustomerId?: boolean
    razorpayPaymentId?: boolean
    razorpayOrderId?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    emailVerificationToken?: boolean
    password?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    googleAccessToken?: boolean
    googleRefreshToken?: boolean
    googleTokenExpiresAt?: boolean
    subscriptionId?: boolean
    subscriptionStatus?: boolean
    subscriptionPlan?: boolean
    trialStartedAt?: boolean
    trialEndsAt?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    razorpayCustomerId?: boolean
    razorpayPaymentId?: boolean
    razorpayOrderId?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    emailVerificationToken?: boolean
    password?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    googleAccessToken?: boolean
    googleRefreshToken?: boolean
    googleTokenExpiresAt?: boolean
    subscriptionId?: boolean
    subscriptionStatus?: boolean
    subscriptionPlan?: boolean
    trialStartedAt?: boolean
    trialEndsAt?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    razorpayCustomerId?: boolean
    razorpayPaymentId?: boolean
    razorpayOrderId?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "emailVerificationToken" | "password" | "image" | "createdAt" | "updatedAt" | "googleAccessToken" | "googleRefreshToken" | "googleTokenExpiresAt" | "subscriptionId" | "subscriptionStatus" | "subscriptionPlan" | "trialStartedAt" | "trialEndsAt" | "currentPeriodStart" | "currentPeriodEnd" | "razorpayCustomerId" | "razorpayPaymentId" | "razorpayOrderId", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownedOrganizations?: boolean | User$ownedOrganizationsArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    reviewReplies?: boolean | User$reviewRepliesArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    locations?: boolean | User$locationsArgs<ExtArgs>
    organizations?: boolean | User$organizationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      ownedOrganizations: Prisma.$OrganizationPayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
      reviewReplies: Prisma.$ReviewReplyPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      locations: Prisma.$LocationPayload<ExtArgs>[]
      organizations: Prisma.$OrganizationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      emailVerified: Date | null
      emailVerificationToken: string | null
      password: string
      image: string | null
      createdAt: Date
      updatedAt: Date
      googleAccessToken: string | null
      googleRefreshToken: string | null
      googleTokenExpiresAt: Date | null
      subscriptionId: string | null
      subscriptionStatus: $Enums.SubscriptionStatus | null
      subscriptionPlan: $Enums.SubscriptionPlan | null
      trialStartedAt: Date | null
      trialEndsAt: Date | null
      currentPeriodStart: Date | null
      currentPeriodEnd: Date | null
      razorpayCustomerId: string | null
      razorpayPaymentId: string | null
      razorpayOrderId: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ownedOrganizations<T extends User$ownedOrganizationsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedOrganizationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posts<T extends User$postsArgs<ExtArgs> = {}>(args?: Subset<T, User$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviewReplies<T extends User$reviewRepliesArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewRepliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewReplyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    locations<T extends User$locationsArgs<ExtArgs> = {}>(args?: Subset<T, User$locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    organizations<T extends User$organizationsArgs<ExtArgs> = {}>(args?: Subset<T, User$organizationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly emailVerificationToken: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly googleAccessToken: FieldRef<"User", 'String'>
    readonly googleRefreshToken: FieldRef<"User", 'String'>
    readonly googleTokenExpiresAt: FieldRef<"User", 'DateTime'>
    readonly subscriptionId: FieldRef<"User", 'String'>
    readonly subscriptionStatus: FieldRef<"User", 'SubscriptionStatus'>
    readonly subscriptionPlan: FieldRef<"User", 'SubscriptionPlan'>
    readonly trialStartedAt: FieldRef<"User", 'DateTime'>
    readonly trialEndsAt: FieldRef<"User", 'DateTime'>
    readonly currentPeriodStart: FieldRef<"User", 'DateTime'>
    readonly currentPeriodEnd: FieldRef<"User", 'DateTime'>
    readonly razorpayCustomerId: FieldRef<"User", 'String'>
    readonly razorpayPaymentId: FieldRef<"User", 'String'>
    readonly razorpayOrderId: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.ownedOrganizations
   */
  export type User$ownedOrganizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    cursor?: OrganizationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * User.posts
   */
  export type User$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * User.reviewReplies
   */
  export type User$reviewRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReply
     */
    select?: ReviewReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReply
     */
    omit?: ReviewReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReplyInclude<ExtArgs> | null
    where?: ReviewReplyWhereInput
    orderBy?: ReviewReplyOrderByWithRelationInput | ReviewReplyOrderByWithRelationInput[]
    cursor?: ReviewReplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewReplyScalarFieldEnum | ReviewReplyScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.locations
   */
  export type User$locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    cursor?: LocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * User.organizations
   */
  export type User$organizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    cursor?: OrganizationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    expiresAt: Date
    createdAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "expiresAt" | "createdAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    name: string | null
    logo: string | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    logo: string | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    name: number
    logo: number
    ownerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrganizationMinAggregateInputType = {
    id?: true
    name?: true
    logo?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    name?: true
    logo?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    name?: true
    logo?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: string
    name: string
    logo: string | null
    ownerId: string
    createdAt: Date
    updatedAt: Date
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    logo?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aiTemplates?: boolean | Organization$aiTemplatesArgs<ExtArgs>
    locations?: boolean | Organization$locationsArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    reportJobs?: boolean | Organization$reportJobsArgs<ExtArgs>
    members?: boolean | Organization$membersArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    logo?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    logo?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    name?: boolean
    logo?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrganizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "logo" | "ownerId" | "createdAt" | "updatedAt", ExtArgs["result"]["organization"]>
  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aiTemplates?: boolean | Organization$aiTemplatesArgs<ExtArgs>
    locations?: boolean | Organization$locationsArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    reportJobs?: boolean | Organization$reportJobsArgs<ExtArgs>
    members?: boolean | Organization$membersArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OrganizationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      aiTemplates: Prisma.$AIReplyTemplatePayload<ExtArgs>[]
      locations: Prisma.$LocationPayload<ExtArgs>[]
      owner: Prisma.$UserPayload<ExtArgs>
      reportJobs: Prisma.$ReportJobPayload<ExtArgs>[]
      members: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      logo: string | null
      ownerId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationFindManyArgs>(args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends OrganizationCreateArgs>(args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationCreateManyArgs>(args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends OrganizationDeleteArgs>(args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUpdateArgs>(args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUpdateManyArgs>(args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations and returns the data updated in the database.
     * @param {OrganizationUpdateManyAndReturnArgs} args - Arguments to update many Organizations.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    aiTemplates<T extends Organization$aiTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, Organization$aiTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIReplyTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    locations<T extends Organization$locationsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reportJobs<T extends Organization$reportJobsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$reportJobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportJobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    members<T extends Organization$membersArgs<ExtArgs> = {}>(args?: Subset<T, Organization$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organization model
   */
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'String'>
    readonly name: FieldRef<"Organization", 'String'>
    readonly logo: FieldRef<"Organization", 'String'>
    readonly ownerId: FieldRef<"Organization", 'String'>
    readonly createdAt: FieldRef<"Organization", 'DateTime'>
    readonly updatedAt: FieldRef<"Organization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization updateManyAndReturn
   */
  export type OrganizationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to delete.
     */
    limit?: number
  }

  /**
   * Organization.aiTemplates
   */
  export type Organization$aiTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIReplyTemplate
     */
    select?: AIReplyTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIReplyTemplate
     */
    omit?: AIReplyTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIReplyTemplateInclude<ExtArgs> | null
    where?: AIReplyTemplateWhereInput
    orderBy?: AIReplyTemplateOrderByWithRelationInput | AIReplyTemplateOrderByWithRelationInput[]
    cursor?: AIReplyTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIReplyTemplateScalarFieldEnum | AIReplyTemplateScalarFieldEnum[]
  }

  /**
   * Organization.locations
   */
  export type Organization$locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    cursor?: LocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Organization.reportJobs
   */
  export type Organization$reportJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportJob
     */
    select?: ReportJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportJob
     */
    omit?: ReportJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportJobInclude<ExtArgs> | null
    where?: ReportJobWhereInput
    orderBy?: ReportJobOrderByWithRelationInput | ReportJobOrderByWithRelationInput[]
    cursor?: ReportJobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportJobScalarFieldEnum | ReportJobScalarFieldEnum[]
  }

  /**
   * Organization.members
   */
  export type Organization$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
  }


  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type LocationSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type LocationMinAggregateOutputType = {
    id: string | null
    name: string | null
    organizationId: string | null
    gmbLocationId: string | null
    gmbLocationName: string | null
    address: string | null
    phone: string | null
    websiteUrl: string | null
    latitude: number | null
    longitude: number | null
    timezone: string | null
    isVerified: boolean | null
    lastSyncedAt: Date | null
    lastFetchedTimestamp: Date | null
    autoReplyEnabled: boolean | null
    autoPostEnabled: boolean | null
    replyTonePreference: $Enums.ReplyTone | null
    accessToken: string | null
    refreshToken: string | null
    tokenExpiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    logoUrl: string | null
    gmbAccountId: string | null
  }

  export type LocationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    organizationId: string | null
    gmbLocationId: string | null
    gmbLocationName: string | null
    address: string | null
    phone: string | null
    websiteUrl: string | null
    latitude: number | null
    longitude: number | null
    timezone: string | null
    isVerified: boolean | null
    lastSyncedAt: Date | null
    lastFetchedTimestamp: Date | null
    autoReplyEnabled: boolean | null
    autoPostEnabled: boolean | null
    replyTonePreference: $Enums.ReplyTone | null
    accessToken: string | null
    refreshToken: string | null
    tokenExpiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    logoUrl: string | null
    gmbAccountId: string | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    name: number
    organizationId: number
    gmbLocationId: number
    gmbLocationName: number
    address: number
    phone: number
    websiteUrl: number
    latitude: number
    longitude: number
    timezone: number
    isVerified: number
    lastSyncedAt: number
    lastFetchedTimestamp: number
    autoReplyEnabled: number
    autoPostEnabled: number
    replyTonePreference: number
    accessToken: number
    refreshToken: number
    tokenExpiresAt: number
    createdAt: number
    updatedAt: number
    logoUrl: number
    gmbAccountId: number
    _all: number
  }


  export type LocationAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type LocationSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type LocationMinAggregateInputType = {
    id?: true
    name?: true
    organizationId?: true
    gmbLocationId?: true
    gmbLocationName?: true
    address?: true
    phone?: true
    websiteUrl?: true
    latitude?: true
    longitude?: true
    timezone?: true
    isVerified?: true
    lastSyncedAt?: true
    lastFetchedTimestamp?: true
    autoReplyEnabled?: true
    autoPostEnabled?: true
    replyTonePreference?: true
    accessToken?: true
    refreshToken?: true
    tokenExpiresAt?: true
    createdAt?: true
    updatedAt?: true
    logoUrl?: true
    gmbAccountId?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    name?: true
    organizationId?: true
    gmbLocationId?: true
    gmbLocationName?: true
    address?: true
    phone?: true
    websiteUrl?: true
    latitude?: true
    longitude?: true
    timezone?: true
    isVerified?: true
    lastSyncedAt?: true
    lastFetchedTimestamp?: true
    autoReplyEnabled?: true
    autoPostEnabled?: true
    replyTonePreference?: true
    accessToken?: true
    refreshToken?: true
    tokenExpiresAt?: true
    createdAt?: true
    updatedAt?: true
    logoUrl?: true
    gmbAccountId?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    name?: true
    organizationId?: true
    gmbLocationId?: true
    gmbLocationName?: true
    address?: true
    phone?: true
    websiteUrl?: true
    latitude?: true
    longitude?: true
    timezone?: true
    isVerified?: true
    lastSyncedAt?: true
    lastFetchedTimestamp?: true
    autoReplyEnabled?: true
    autoPostEnabled?: true
    replyTonePreference?: true
    accessToken?: true
    refreshToken?: true
    tokenExpiresAt?: true
    createdAt?: true
    updatedAt?: true
    logoUrl?: true
    gmbAccountId?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _avg?: LocationAvgAggregateInputType
    _sum?: LocationSumAggregateInputType
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: string
    name: string
    organizationId: string
    gmbLocationId: string
    gmbLocationName: string
    address: string | null
    phone: string | null
    websiteUrl: string | null
    latitude: number | null
    longitude: number | null
    timezone: string
    isVerified: boolean
    lastSyncedAt: Date
    lastFetchedTimestamp: Date | null
    autoReplyEnabled: boolean
    autoPostEnabled: boolean
    replyTonePreference: $Enums.ReplyTone | null
    accessToken: string | null
    refreshToken: string | null
    tokenExpiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    logoUrl: string | null
    gmbAccountId: string | null
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    organizationId?: boolean
    gmbLocationId?: boolean
    gmbLocationName?: boolean
    address?: boolean
    phone?: boolean
    websiteUrl?: boolean
    latitude?: boolean
    longitude?: boolean
    timezone?: boolean
    isVerified?: boolean
    lastSyncedAt?: boolean
    lastFetchedTimestamp?: boolean
    autoReplyEnabled?: boolean
    autoPostEnabled?: boolean
    replyTonePreference?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    logoUrl?: boolean
    gmbAccountId?: boolean
    insights?: boolean | Location$insightsArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    posts?: boolean | Location$postsArgs<ExtArgs>
    reports?: boolean | Location$reportsArgs<ExtArgs>
    reviews?: boolean | Location$reviewsArgs<ExtArgs>
    users?: boolean | Location$usersArgs<ExtArgs>
    searchKeywords?: boolean | Location$searchKeywordsArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    organizationId?: boolean
    gmbLocationId?: boolean
    gmbLocationName?: boolean
    address?: boolean
    phone?: boolean
    websiteUrl?: boolean
    latitude?: boolean
    longitude?: boolean
    timezone?: boolean
    isVerified?: boolean
    lastSyncedAt?: boolean
    lastFetchedTimestamp?: boolean
    autoReplyEnabled?: boolean
    autoPostEnabled?: boolean
    replyTonePreference?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    logoUrl?: boolean
    gmbAccountId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    organizationId?: boolean
    gmbLocationId?: boolean
    gmbLocationName?: boolean
    address?: boolean
    phone?: boolean
    websiteUrl?: boolean
    latitude?: boolean
    longitude?: boolean
    timezone?: boolean
    isVerified?: boolean
    lastSyncedAt?: boolean
    lastFetchedTimestamp?: boolean
    autoReplyEnabled?: boolean
    autoPostEnabled?: boolean
    replyTonePreference?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    logoUrl?: boolean
    gmbAccountId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectScalar = {
    id?: boolean
    name?: boolean
    organizationId?: boolean
    gmbLocationId?: boolean
    gmbLocationName?: boolean
    address?: boolean
    phone?: boolean
    websiteUrl?: boolean
    latitude?: boolean
    longitude?: boolean
    timezone?: boolean
    isVerified?: boolean
    lastSyncedAt?: boolean
    lastFetchedTimestamp?: boolean
    autoReplyEnabled?: boolean
    autoPostEnabled?: boolean
    replyTonePreference?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    logoUrl?: boolean
    gmbAccountId?: boolean
  }

  export type LocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "organizationId" | "gmbLocationId" | "gmbLocationName" | "address" | "phone" | "websiteUrl" | "latitude" | "longitude" | "timezone" | "isVerified" | "lastSyncedAt" | "lastFetchedTimestamp" | "autoReplyEnabled" | "autoPostEnabled" | "replyTonePreference" | "accessToken" | "refreshToken" | "tokenExpiresAt" | "createdAt" | "updatedAt" | "logoUrl" | "gmbAccountId", ExtArgs["result"]["location"]>
  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insights?: boolean | Location$insightsArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    posts?: boolean | Location$postsArgs<ExtArgs>
    reports?: boolean | Location$reportsArgs<ExtArgs>
    reviews?: boolean | Location$reviewsArgs<ExtArgs>
    users?: boolean | Location$usersArgs<ExtArgs>
    searchKeywords?: boolean | Location$searchKeywordsArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type LocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      insights: Prisma.$InsightPayload<ExtArgs>[]
      organization: Prisma.$OrganizationPayload<ExtArgs>
      posts: Prisma.$PostPayload<ExtArgs>[]
      reports: Prisma.$ReportPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      searchKeywords: Prisma.$SearchKeywordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      organizationId: string
      gmbLocationId: string
      gmbLocationName: string
      address: string | null
      phone: string | null
      websiteUrl: string | null
      latitude: number | null
      longitude: number | null
      timezone: string
      isVerified: boolean
      lastSyncedAt: Date
      lastFetchedTimestamp: Date | null
      autoReplyEnabled: boolean
      autoPostEnabled: boolean
      replyTonePreference: $Enums.ReplyTone | null
      accessToken: string | null
      refreshToken: string | null
      tokenExpiresAt: Date | null
      createdAt: Date
      updatedAt: Date
      logoUrl: string | null
      gmbAccountId: string | null
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationFindUniqueArgs>(args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationFindFirstArgs>(args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationFindManyArgs>(args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends LocationCreateArgs>(args: SelectSubset<T, LocationCreateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Locations.
     * @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationCreateManyArgs>(args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {LocationCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends LocationDeleteArgs>(args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateArgs>(args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDeleteManyArgs>(args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateManyArgs>(args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations and returns the data updated in the database.
     * @param {LocationUpdateManyAndReturnArgs} args - Arguments to update many Locations.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LocationUpdateManyAndReturnArgs>(args: SelectSubset<T, LocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpsertArgs>(args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    insights<T extends Location$insightsArgs<ExtArgs> = {}>(args?: Subset<T, Location$insightsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    posts<T extends Location$postsArgs<ExtArgs> = {}>(args?: Subset<T, Location$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reports<T extends Location$reportsArgs<ExtArgs> = {}>(args?: Subset<T, Location$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Location$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Location$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Location$usersArgs<ExtArgs> = {}>(args?: Subset<T, Location$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    searchKeywords<T extends Location$searchKeywordsArgs<ExtArgs> = {}>(args?: Subset<T, Location$searchKeywordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchKeywordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Location model
   */
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'String'>
    readonly name: FieldRef<"Location", 'String'>
    readonly organizationId: FieldRef<"Location", 'String'>
    readonly gmbLocationId: FieldRef<"Location", 'String'>
    readonly gmbLocationName: FieldRef<"Location", 'String'>
    readonly address: FieldRef<"Location", 'String'>
    readonly phone: FieldRef<"Location", 'String'>
    readonly websiteUrl: FieldRef<"Location", 'String'>
    readonly latitude: FieldRef<"Location", 'Float'>
    readonly longitude: FieldRef<"Location", 'Float'>
    readonly timezone: FieldRef<"Location", 'String'>
    readonly isVerified: FieldRef<"Location", 'Boolean'>
    readonly lastSyncedAt: FieldRef<"Location", 'DateTime'>
    readonly lastFetchedTimestamp: FieldRef<"Location", 'DateTime'>
    readonly autoReplyEnabled: FieldRef<"Location", 'Boolean'>
    readonly autoPostEnabled: FieldRef<"Location", 'Boolean'>
    readonly replyTonePreference: FieldRef<"Location", 'ReplyTone'>
    readonly accessToken: FieldRef<"Location", 'String'>
    readonly refreshToken: FieldRef<"Location", 'String'>
    readonly tokenExpiresAt: FieldRef<"Location", 'DateTime'>
    readonly createdAt: FieldRef<"Location", 'DateTime'>
    readonly updatedAt: FieldRef<"Location", 'DateTime'>
    readonly logoUrl: FieldRef<"Location", 'String'>
    readonly gmbAccountId: FieldRef<"Location", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location createManyAndReturn
   */
  export type LocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Location updateManyAndReturn
   */
  export type LocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to delete.
     */
    limit?: number
  }

  /**
   * Location.insights
   */
  export type Location$insightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Insight
     */
    omit?: InsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInclude<ExtArgs> | null
    where?: InsightWhereInput
    orderBy?: InsightOrderByWithRelationInput | InsightOrderByWithRelationInput[]
    cursor?: InsightWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InsightScalarFieldEnum | InsightScalarFieldEnum[]
  }

  /**
   * Location.posts
   */
  export type Location$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Location.reports
   */
  export type Location$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Location.reviews
   */
  export type Location$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Location.users
   */
  export type Location$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Location.searchKeywords
   */
  export type Location$searchKeywordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchKeyword
     */
    select?: SearchKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchKeyword
     */
    omit?: SearchKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchKeywordInclude<ExtArgs> | null
    where?: SearchKeywordWhereInput
    orderBy?: SearchKeywordOrderByWithRelationInput | SearchKeywordOrderByWithRelationInput[]
    cursor?: SearchKeywordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SearchKeywordScalarFieldEnum | SearchKeywordScalarFieldEnum[]
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostMinAggregateOutputType = {
    id: string | null
    locationId: string | null
    userId: string | null
    title: string | null
    content: string | null
    type: $Enums.PostType | null
    scheduledAt: Date | null
    publishedAt: Date | null
    status: $Enums.PostStatus | null
    eventStart: Date | null
    eventEnd: Date | null
    offerStart: Date | null
    offerEnd: Date | null
    couponCode: string | null
    callToAction: string | null
    recurType: $Enums.RecurType | null
    recurEndsAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostMaxAggregateOutputType = {
    id: string | null
    locationId: string | null
    userId: string | null
    title: string | null
    content: string | null
    type: $Enums.PostType | null
    scheduledAt: Date | null
    publishedAt: Date | null
    status: $Enums.PostStatus | null
    eventStart: Date | null
    eventEnd: Date | null
    offerStart: Date | null
    offerEnd: Date | null
    couponCode: string | null
    callToAction: string | null
    recurType: $Enums.RecurType | null
    recurEndsAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    locationId: number
    userId: number
    title: number
    content: number
    type: number
    mediaUrls: number
    scheduledAt: number
    publishedAt: number
    status: number
    eventStart: number
    eventEnd: number
    offerStart: number
    offerEnd: number
    couponCode: number
    callToAction: number
    recurType: number
    recurEndsAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PostMinAggregateInputType = {
    id?: true
    locationId?: true
    userId?: true
    title?: true
    content?: true
    type?: true
    scheduledAt?: true
    publishedAt?: true
    status?: true
    eventStart?: true
    eventEnd?: true
    offerStart?: true
    offerEnd?: true
    couponCode?: true
    callToAction?: true
    recurType?: true
    recurEndsAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    locationId?: true
    userId?: true
    title?: true
    content?: true
    type?: true
    scheduledAt?: true
    publishedAt?: true
    status?: true
    eventStart?: true
    eventEnd?: true
    offerStart?: true
    offerEnd?: true
    couponCode?: true
    callToAction?: true
    recurType?: true
    recurEndsAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    locationId?: true
    userId?: true
    title?: true
    content?: true
    type?: true
    mediaUrls?: true
    scheduledAt?: true
    publishedAt?: true
    status?: true
    eventStart?: true
    eventEnd?: true
    offerStart?: true
    offerEnd?: true
    couponCode?: true
    callToAction?: true
    recurType?: true
    recurEndsAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: string
    locationId: string
    userId: string
    title: string
    content: string
    type: $Enums.PostType
    mediaUrls: string[]
    scheduledAt: Date
    publishedAt: Date | null
    status: $Enums.PostStatus
    eventStart: Date | null
    eventEnd: Date | null
    offerStart: Date | null
    offerEnd: Date | null
    couponCode: string | null
    callToAction: string | null
    recurType: $Enums.RecurType | null
    recurEndsAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PostCountAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    mediaUrls?: boolean
    scheduledAt?: boolean
    publishedAt?: boolean
    status?: boolean
    eventStart?: boolean
    eventEnd?: boolean
    offerStart?: boolean
    offerEnd?: boolean
    couponCode?: boolean
    callToAction?: boolean
    recurType?: boolean
    recurEndsAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    mediaUrls?: boolean
    scheduledAt?: boolean
    publishedAt?: boolean
    status?: boolean
    eventStart?: boolean
    eventEnd?: boolean
    offerStart?: boolean
    offerEnd?: boolean
    couponCode?: boolean
    callToAction?: boolean
    recurType?: boolean
    recurEndsAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    mediaUrls?: boolean
    scheduledAt?: boolean
    publishedAt?: boolean
    status?: boolean
    eventStart?: boolean
    eventEnd?: boolean
    offerStart?: boolean
    offerEnd?: boolean
    couponCode?: boolean
    callToAction?: boolean
    recurType?: boolean
    recurEndsAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectScalar = {
    id?: boolean
    locationId?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    mediaUrls?: boolean
    scheduledAt?: boolean
    publishedAt?: boolean
    status?: boolean
    eventStart?: boolean
    eventEnd?: boolean
    offerStart?: boolean
    offerEnd?: boolean
    couponCode?: boolean
    callToAction?: boolean
    recurType?: boolean
    recurEndsAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "locationId" | "userId" | "title" | "content" | "type" | "mediaUrls" | "scheduledAt" | "publishedAt" | "status" | "eventStart" | "eventEnd" | "offerStart" | "offerEnd" | "couponCode" | "callToAction" | "recurType" | "recurEndsAt" | "createdAt" | "updatedAt", ExtArgs["result"]["post"]>
  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      location: Prisma.$LocationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      locationId: string
      userId: string
      title: string
      content: string
      type: $Enums.PostType
      mediaUrls: string[]
      scheduledAt: Date
      publishedAt: Date | null
      status: $Enums.PostStatus
      eventStart: Date | null
      eventEnd: Date | null
      offerStart: Date | null
      offerEnd: Date | null
      couponCode: string | null
      callToAction: string | null
      recurType: $Enums.RecurType | null
      recurEndsAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["post"]>
    composites: {}
  }

  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostFindUniqueArgs>(args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Post that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(args: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostFindFirstArgs>(args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostFindManyArgs>(args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
     */
    create<T extends PostCreateArgs>(args: SelectSubset<T, PostCreateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Posts.
     * @param {PostCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCreateManyArgs>(args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Posts and returns the data saved in the database.
     * @param {PostCreateManyAndReturnArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostCreateManyAndReturnArgs>(args?: SelectSubset<T, PostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
     */
    delete<T extends PostDeleteArgs>(args: SelectSubset<T, PostDeleteArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostUpdateArgs>(args: SelectSubset<T, PostUpdateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostDeleteManyArgs>(args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostUpdateManyArgs>(args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts and returns the data updated in the database.
     * @param {PostUpdateManyAndReturnArgs} args - Arguments to update many Posts.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostUpdateManyAndReturnArgs>(args: SelectSubset<T, PostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
     */
    upsert<T extends PostUpsertArgs>(args: SelectSubset<T, PostUpsertArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Post model
   */
  interface PostFieldRefs {
    readonly id: FieldRef<"Post", 'String'>
    readonly locationId: FieldRef<"Post", 'String'>
    readonly userId: FieldRef<"Post", 'String'>
    readonly title: FieldRef<"Post", 'String'>
    readonly content: FieldRef<"Post", 'String'>
    readonly type: FieldRef<"Post", 'PostType'>
    readonly mediaUrls: FieldRef<"Post", 'String[]'>
    readonly scheduledAt: FieldRef<"Post", 'DateTime'>
    readonly publishedAt: FieldRef<"Post", 'DateTime'>
    readonly status: FieldRef<"Post", 'PostStatus'>
    readonly eventStart: FieldRef<"Post", 'DateTime'>
    readonly eventEnd: FieldRef<"Post", 'DateTime'>
    readonly offerStart: FieldRef<"Post", 'DateTime'>
    readonly offerEnd: FieldRef<"Post", 'DateTime'>
    readonly couponCode: FieldRef<"Post", 'String'>
    readonly callToAction: FieldRef<"Post", 'String'>
    readonly recurType: FieldRef<"Post", 'RecurType'>
    readonly recurEndsAt: FieldRef<"Post", 'DateTime'>
    readonly createdAt: FieldRef<"Post", 'DateTime'>
    readonly updatedAt: FieldRef<"Post", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }

  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Post createManyAndReturn
   */
  export type PostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
  }

  /**
   * Post updateManyAndReturn
   */
  export type PostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }

  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to delete.
     */
    limit?: number
  }

  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type ReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    locationId: string | null
    reviewId: string | null
    authorName: string | null
    authorPhoto: string | null
    rating: number | null
    comment: string | null
    createTime: Date | null
    updateTime: Date | null
    status: $Enums.ReviewStatus | null
    isProcessed: boolean | null
    sentiment: $Enums.SentimentType | null
    language: string | null
    isReplyNeeded: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    locationId: string | null
    reviewId: string | null
    authorName: string | null
    authorPhoto: string | null
    rating: number | null
    comment: string | null
    createTime: Date | null
    updateTime: Date | null
    status: $Enums.ReviewStatus | null
    isProcessed: boolean | null
    sentiment: $Enums.SentimentType | null
    language: string | null
    isReplyNeeded: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    locationId: number
    reviewId: number
    authorName: number
    authorPhoto: number
    rating: number
    comment: number
    createTime: number
    updateTime: number
    status: number
    isProcessed: number
    sentiment: number
    language: number
    isReplyNeeded: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    rating?: true
  }

  export type ReviewSumAggregateInputType = {
    rating?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    locationId?: true
    reviewId?: true
    authorName?: true
    authorPhoto?: true
    rating?: true
    comment?: true
    createTime?: true
    updateTime?: true
    status?: true
    isProcessed?: true
    sentiment?: true
    language?: true
    isReplyNeeded?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    locationId?: true
    reviewId?: true
    authorName?: true
    authorPhoto?: true
    rating?: true
    comment?: true
    createTime?: true
    updateTime?: true
    status?: true
    isProcessed?: true
    sentiment?: true
    language?: true
    isReplyNeeded?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    locationId?: true
    reviewId?: true
    authorName?: true
    authorPhoto?: true
    rating?: true
    comment?: true
    createTime?: true
    updateTime?: true
    status?: true
    isProcessed?: true
    sentiment?: true
    language?: true
    isReplyNeeded?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: string
    locationId: string
    reviewId: string
    authorName: string
    authorPhoto: string | null
    rating: number
    comment: string | null
    createTime: Date
    updateTime: Date
    status: $Enums.ReviewStatus
    isProcessed: boolean
    sentiment: $Enums.SentimentType | null
    language: string | null
    isReplyNeeded: boolean
    createdAt: Date
    updatedAt: Date
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    reviewId?: boolean
    authorName?: boolean
    authorPhoto?: boolean
    rating?: boolean
    comment?: boolean
    createTime?: boolean
    updateTime?: boolean
    status?: boolean
    isProcessed?: boolean
    sentiment?: boolean
    language?: boolean
    isReplyNeeded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    replies?: boolean | Review$repliesArgs<ExtArgs>
    _count?: boolean | ReviewCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    reviewId?: boolean
    authorName?: boolean
    authorPhoto?: boolean
    rating?: boolean
    comment?: boolean
    createTime?: boolean
    updateTime?: boolean
    status?: boolean
    isProcessed?: boolean
    sentiment?: boolean
    language?: boolean
    isReplyNeeded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    reviewId?: boolean
    authorName?: boolean
    authorPhoto?: boolean
    rating?: boolean
    comment?: boolean
    createTime?: boolean
    updateTime?: boolean
    status?: boolean
    isProcessed?: boolean
    sentiment?: boolean
    language?: boolean
    isReplyNeeded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    locationId?: boolean
    reviewId?: boolean
    authorName?: boolean
    authorPhoto?: boolean
    rating?: boolean
    comment?: boolean
    createTime?: boolean
    updateTime?: boolean
    status?: boolean
    isProcessed?: boolean
    sentiment?: boolean
    language?: boolean
    isReplyNeeded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "locationId" | "reviewId" | "authorName" | "authorPhoto" | "rating" | "comment" | "createTime" | "updateTime" | "status" | "isProcessed" | "sentiment" | "language" | "isReplyNeeded" | "createdAt" | "updatedAt", ExtArgs["result"]["review"]>
  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    replies?: boolean | Review$repliesArgs<ExtArgs>
    _count?: boolean | ReviewCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      location: Prisma.$LocationPayload<ExtArgs>
      replies: Prisma.$ReviewReplyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      locationId: string
      reviewId: string
      authorName: string
      authorPhoto: string | null
      rating: number
      comment: string | null
      createTime: Date
      updateTime: Date
      status: $Enums.ReviewStatus
      isProcessed: boolean
      sentiment: $Enums.SentimentType | null
      language: string | null
      isReplyNeeded: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {ReviewUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    replies<T extends Review$repliesArgs<ExtArgs> = {}>(args?: Subset<T, Review$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewReplyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>
    readonly locationId: FieldRef<"Review", 'String'>
    readonly reviewId: FieldRef<"Review", 'String'>
    readonly authorName: FieldRef<"Review", 'String'>
    readonly authorPhoto: FieldRef<"Review", 'String'>
    readonly rating: FieldRef<"Review", 'Int'>
    readonly comment: FieldRef<"Review", 'String'>
    readonly createTime: FieldRef<"Review", 'DateTime'>
    readonly updateTime: FieldRef<"Review", 'DateTime'>
    readonly status: FieldRef<"Review", 'ReviewStatus'>
    readonly isProcessed: FieldRef<"Review", 'Boolean'>
    readonly sentiment: FieldRef<"Review", 'SentimentType'>
    readonly language: FieldRef<"Review", 'String'>
    readonly isReplyNeeded: FieldRef<"Review", 'Boolean'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
    readonly updatedAt: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
  }

  /**
   * Review updateManyAndReturn
   */
  export type ReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number
  }

  /**
   * Review.replies
   */
  export type Review$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReply
     */
    select?: ReviewReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReply
     */
    omit?: ReviewReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReplyInclude<ExtArgs> | null
    where?: ReviewReplyWhereInput
    orderBy?: ReviewReplyOrderByWithRelationInput | ReviewReplyOrderByWithRelationInput[]
    cursor?: ReviewReplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewReplyScalarFieldEnum | ReviewReplyScalarFieldEnum[]
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model ReviewReply
   */

  export type AggregateReviewReply = {
    _count: ReviewReplyCountAggregateOutputType | null
    _min: ReviewReplyMinAggregateOutputType | null
    _max: ReviewReplyMaxAggregateOutputType | null
  }

  export type ReviewReplyMinAggregateOutputType = {
    id: string | null
    reviewId: string | null
    userId: string | null
    content: string | null
    source: $Enums.ReplySource | null
    tone: $Enums.ReplyTone | null
    isPublished: boolean | null
    publishedAt: Date | null
    aiTemplateId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewReplyMaxAggregateOutputType = {
    id: string | null
    reviewId: string | null
    userId: string | null
    content: string | null
    source: $Enums.ReplySource | null
    tone: $Enums.ReplyTone | null
    isPublished: boolean | null
    publishedAt: Date | null
    aiTemplateId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewReplyCountAggregateOutputType = {
    id: number
    reviewId: number
    userId: number
    content: number
    source: number
    tone: number
    isPublished: number
    publishedAt: number
    aiTemplateId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReviewReplyMinAggregateInputType = {
    id?: true
    reviewId?: true
    userId?: true
    content?: true
    source?: true
    tone?: true
    isPublished?: true
    publishedAt?: true
    aiTemplateId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewReplyMaxAggregateInputType = {
    id?: true
    reviewId?: true
    userId?: true
    content?: true
    source?: true
    tone?: true
    isPublished?: true
    publishedAt?: true
    aiTemplateId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewReplyCountAggregateInputType = {
    id?: true
    reviewId?: true
    userId?: true
    content?: true
    source?: true
    tone?: true
    isPublished?: true
    publishedAt?: true
    aiTemplateId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReviewReplyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewReply to aggregate.
     */
    where?: ReviewReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewReplies to fetch.
     */
    orderBy?: ReviewReplyOrderByWithRelationInput | ReviewReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReviewReplies
    **/
    _count?: true | ReviewReplyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewReplyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewReplyMaxAggregateInputType
  }

  export type GetReviewReplyAggregateType<T extends ReviewReplyAggregateArgs> = {
        [P in keyof T & keyof AggregateReviewReply]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviewReply[P]>
      : GetScalarType<T[P], AggregateReviewReply[P]>
  }




  export type ReviewReplyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewReplyWhereInput
    orderBy?: ReviewReplyOrderByWithAggregationInput | ReviewReplyOrderByWithAggregationInput[]
    by: ReviewReplyScalarFieldEnum[] | ReviewReplyScalarFieldEnum
    having?: ReviewReplyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewReplyCountAggregateInputType | true
    _min?: ReviewReplyMinAggregateInputType
    _max?: ReviewReplyMaxAggregateInputType
  }

  export type ReviewReplyGroupByOutputType = {
    id: string
    reviewId: string
    userId: string | null
    content: string
    source: $Enums.ReplySource
    tone: $Enums.ReplyTone
    isPublished: boolean
    publishedAt: Date | null
    aiTemplateId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ReviewReplyCountAggregateOutputType | null
    _min: ReviewReplyMinAggregateOutputType | null
    _max: ReviewReplyMaxAggregateOutputType | null
  }

  type GetReviewReplyGroupByPayload<T extends ReviewReplyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewReplyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewReplyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewReplyGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewReplyGroupByOutputType[P]>
        }
      >
    >


  export type ReviewReplySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    userId?: boolean
    content?: boolean
    source?: boolean
    tone?: boolean
    isPublished?: boolean
    publishedAt?: boolean
    aiTemplateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aiTemplate?: boolean | ReviewReply$aiTemplateArgs<ExtArgs>
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | ReviewReply$userArgs<ExtArgs>
  }, ExtArgs["result"]["reviewReply"]>

  export type ReviewReplySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    userId?: boolean
    content?: boolean
    source?: boolean
    tone?: boolean
    isPublished?: boolean
    publishedAt?: boolean
    aiTemplateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aiTemplate?: boolean | ReviewReply$aiTemplateArgs<ExtArgs>
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | ReviewReply$userArgs<ExtArgs>
  }, ExtArgs["result"]["reviewReply"]>

  export type ReviewReplySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    userId?: boolean
    content?: boolean
    source?: boolean
    tone?: boolean
    isPublished?: boolean
    publishedAt?: boolean
    aiTemplateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aiTemplate?: boolean | ReviewReply$aiTemplateArgs<ExtArgs>
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | ReviewReply$userArgs<ExtArgs>
  }, ExtArgs["result"]["reviewReply"]>

  export type ReviewReplySelectScalar = {
    id?: boolean
    reviewId?: boolean
    userId?: boolean
    content?: boolean
    source?: boolean
    tone?: boolean
    isPublished?: boolean
    publishedAt?: boolean
    aiTemplateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReviewReplyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reviewId" | "userId" | "content" | "source" | "tone" | "isPublished" | "publishedAt" | "aiTemplateId" | "createdAt" | "updatedAt", ExtArgs["result"]["reviewReply"]>
  export type ReviewReplyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aiTemplate?: boolean | ReviewReply$aiTemplateArgs<ExtArgs>
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | ReviewReply$userArgs<ExtArgs>
  }
  export type ReviewReplyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aiTemplate?: boolean | ReviewReply$aiTemplateArgs<ExtArgs>
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | ReviewReply$userArgs<ExtArgs>
  }
  export type ReviewReplyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aiTemplate?: boolean | ReviewReply$aiTemplateArgs<ExtArgs>
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | ReviewReply$userArgs<ExtArgs>
  }

  export type $ReviewReplyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReviewReply"
    objects: {
      aiTemplate: Prisma.$AIReplyTemplatePayload<ExtArgs> | null
      review: Prisma.$ReviewPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reviewId: string
      userId: string | null
      content: string
      source: $Enums.ReplySource
      tone: $Enums.ReplyTone
      isPublished: boolean
      publishedAt: Date | null
      aiTemplateId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["reviewReply"]>
    composites: {}
  }

  type ReviewReplyGetPayload<S extends boolean | null | undefined | ReviewReplyDefaultArgs> = $Result.GetResult<Prisma.$ReviewReplyPayload, S>

  type ReviewReplyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewReplyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewReplyCountAggregateInputType | true
    }

  export interface ReviewReplyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReviewReply'], meta: { name: 'ReviewReply' } }
    /**
     * Find zero or one ReviewReply that matches the filter.
     * @param {ReviewReplyFindUniqueArgs} args - Arguments to find a ReviewReply
     * @example
     * // Get one ReviewReply
     * const reviewReply = await prisma.reviewReply.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewReplyFindUniqueArgs>(args: SelectSubset<T, ReviewReplyFindUniqueArgs<ExtArgs>>): Prisma__ReviewReplyClient<$Result.GetResult<Prisma.$ReviewReplyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReviewReply that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewReplyFindUniqueOrThrowArgs} args - Arguments to find a ReviewReply
     * @example
     * // Get one ReviewReply
     * const reviewReply = await prisma.reviewReply.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewReplyFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewReplyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewReplyClient<$Result.GetResult<Prisma.$ReviewReplyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewReply that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewReplyFindFirstArgs} args - Arguments to find a ReviewReply
     * @example
     * // Get one ReviewReply
     * const reviewReply = await prisma.reviewReply.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewReplyFindFirstArgs>(args?: SelectSubset<T, ReviewReplyFindFirstArgs<ExtArgs>>): Prisma__ReviewReplyClient<$Result.GetResult<Prisma.$ReviewReplyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewReply that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewReplyFindFirstOrThrowArgs} args - Arguments to find a ReviewReply
     * @example
     * // Get one ReviewReply
     * const reviewReply = await prisma.reviewReply.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewReplyFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewReplyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewReplyClient<$Result.GetResult<Prisma.$ReviewReplyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReviewReplies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewReplyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReviewReplies
     * const reviewReplies = await prisma.reviewReply.findMany()
     * 
     * // Get first 10 ReviewReplies
     * const reviewReplies = await prisma.reviewReply.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewReplyWithIdOnly = await prisma.reviewReply.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewReplyFindManyArgs>(args?: SelectSubset<T, ReviewReplyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewReplyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReviewReply.
     * @param {ReviewReplyCreateArgs} args - Arguments to create a ReviewReply.
     * @example
     * // Create one ReviewReply
     * const ReviewReply = await prisma.reviewReply.create({
     *   data: {
     *     // ... data to create a ReviewReply
     *   }
     * })
     * 
     */
    create<T extends ReviewReplyCreateArgs>(args: SelectSubset<T, ReviewReplyCreateArgs<ExtArgs>>): Prisma__ReviewReplyClient<$Result.GetResult<Prisma.$ReviewReplyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReviewReplies.
     * @param {ReviewReplyCreateManyArgs} args - Arguments to create many ReviewReplies.
     * @example
     * // Create many ReviewReplies
     * const reviewReply = await prisma.reviewReply.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewReplyCreateManyArgs>(args?: SelectSubset<T, ReviewReplyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReviewReplies and returns the data saved in the database.
     * @param {ReviewReplyCreateManyAndReturnArgs} args - Arguments to create many ReviewReplies.
     * @example
     * // Create many ReviewReplies
     * const reviewReply = await prisma.reviewReply.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReviewReplies and only return the `id`
     * const reviewReplyWithIdOnly = await prisma.reviewReply.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewReplyCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewReplyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewReplyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReviewReply.
     * @param {ReviewReplyDeleteArgs} args - Arguments to delete one ReviewReply.
     * @example
     * // Delete one ReviewReply
     * const ReviewReply = await prisma.reviewReply.delete({
     *   where: {
     *     // ... filter to delete one ReviewReply
     *   }
     * })
     * 
     */
    delete<T extends ReviewReplyDeleteArgs>(args: SelectSubset<T, ReviewReplyDeleteArgs<ExtArgs>>): Prisma__ReviewReplyClient<$Result.GetResult<Prisma.$ReviewReplyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReviewReply.
     * @param {ReviewReplyUpdateArgs} args - Arguments to update one ReviewReply.
     * @example
     * // Update one ReviewReply
     * const reviewReply = await prisma.reviewReply.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewReplyUpdateArgs>(args: SelectSubset<T, ReviewReplyUpdateArgs<ExtArgs>>): Prisma__ReviewReplyClient<$Result.GetResult<Prisma.$ReviewReplyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReviewReplies.
     * @param {ReviewReplyDeleteManyArgs} args - Arguments to filter ReviewReplies to delete.
     * @example
     * // Delete a few ReviewReplies
     * const { count } = await prisma.reviewReply.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewReplyDeleteManyArgs>(args?: SelectSubset<T, ReviewReplyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewReplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewReplyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReviewReplies
     * const reviewReply = await prisma.reviewReply.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewReplyUpdateManyArgs>(args: SelectSubset<T, ReviewReplyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewReplies and returns the data updated in the database.
     * @param {ReviewReplyUpdateManyAndReturnArgs} args - Arguments to update many ReviewReplies.
     * @example
     * // Update many ReviewReplies
     * const reviewReply = await prisma.reviewReply.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReviewReplies and only return the `id`
     * const reviewReplyWithIdOnly = await prisma.reviewReply.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewReplyUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewReplyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewReplyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReviewReply.
     * @param {ReviewReplyUpsertArgs} args - Arguments to update or create a ReviewReply.
     * @example
     * // Update or create a ReviewReply
     * const reviewReply = await prisma.reviewReply.upsert({
     *   create: {
     *     // ... data to create a ReviewReply
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReviewReply we want to update
     *   }
     * })
     */
    upsert<T extends ReviewReplyUpsertArgs>(args: SelectSubset<T, ReviewReplyUpsertArgs<ExtArgs>>): Prisma__ReviewReplyClient<$Result.GetResult<Prisma.$ReviewReplyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReviewReplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewReplyCountArgs} args - Arguments to filter ReviewReplies to count.
     * @example
     * // Count the number of ReviewReplies
     * const count = await prisma.reviewReply.count({
     *   where: {
     *     // ... the filter for the ReviewReplies we want to count
     *   }
     * })
    **/
    count<T extends ReviewReplyCountArgs>(
      args?: Subset<T, ReviewReplyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewReplyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReviewReply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewReplyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewReplyAggregateArgs>(args: Subset<T, ReviewReplyAggregateArgs>): Prisma.PrismaPromise<GetReviewReplyAggregateType<T>>

    /**
     * Group by ReviewReply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewReplyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewReplyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewReplyGroupByArgs['orderBy'] }
        : { orderBy?: ReviewReplyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewReplyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewReplyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReviewReply model
   */
  readonly fields: ReviewReplyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReviewReply.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewReplyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    aiTemplate<T extends ReviewReply$aiTemplateArgs<ExtArgs> = {}>(args?: Subset<T, ReviewReply$aiTemplateArgs<ExtArgs>>): Prisma__AIReplyTemplateClient<$Result.GetResult<Prisma.$AIReplyTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    review<T extends ReviewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReviewDefaultArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends ReviewReply$userArgs<ExtArgs> = {}>(args?: Subset<T, ReviewReply$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReviewReply model
   */
  interface ReviewReplyFieldRefs {
    readonly id: FieldRef<"ReviewReply", 'String'>
    readonly reviewId: FieldRef<"ReviewReply", 'String'>
    readonly userId: FieldRef<"ReviewReply", 'String'>
    readonly content: FieldRef<"ReviewReply", 'String'>
    readonly source: FieldRef<"ReviewReply", 'ReplySource'>
    readonly tone: FieldRef<"ReviewReply", 'ReplyTone'>
    readonly isPublished: FieldRef<"ReviewReply", 'Boolean'>
    readonly publishedAt: FieldRef<"ReviewReply", 'DateTime'>
    readonly aiTemplateId: FieldRef<"ReviewReply", 'String'>
    readonly createdAt: FieldRef<"ReviewReply", 'DateTime'>
    readonly updatedAt: FieldRef<"ReviewReply", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReviewReply findUnique
   */
  export type ReviewReplyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReply
     */
    select?: ReviewReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReply
     */
    omit?: ReviewReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReplyInclude<ExtArgs> | null
    /**
     * Filter, which ReviewReply to fetch.
     */
    where: ReviewReplyWhereUniqueInput
  }

  /**
   * ReviewReply findUniqueOrThrow
   */
  export type ReviewReplyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReply
     */
    select?: ReviewReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReply
     */
    omit?: ReviewReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReplyInclude<ExtArgs> | null
    /**
     * Filter, which ReviewReply to fetch.
     */
    where: ReviewReplyWhereUniqueInput
  }

  /**
   * ReviewReply findFirst
   */
  export type ReviewReplyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReply
     */
    select?: ReviewReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReply
     */
    omit?: ReviewReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReplyInclude<ExtArgs> | null
    /**
     * Filter, which ReviewReply to fetch.
     */
    where?: ReviewReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewReplies to fetch.
     */
    orderBy?: ReviewReplyOrderByWithRelationInput | ReviewReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewReplies.
     */
    cursor?: ReviewReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewReplies.
     */
    distinct?: ReviewReplyScalarFieldEnum | ReviewReplyScalarFieldEnum[]
  }

  /**
   * ReviewReply findFirstOrThrow
   */
  export type ReviewReplyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReply
     */
    select?: ReviewReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReply
     */
    omit?: ReviewReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReplyInclude<ExtArgs> | null
    /**
     * Filter, which ReviewReply to fetch.
     */
    where?: ReviewReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewReplies to fetch.
     */
    orderBy?: ReviewReplyOrderByWithRelationInput | ReviewReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewReplies.
     */
    cursor?: ReviewReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewReplies.
     */
    distinct?: ReviewReplyScalarFieldEnum | ReviewReplyScalarFieldEnum[]
  }

  /**
   * ReviewReply findMany
   */
  export type ReviewReplyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReply
     */
    select?: ReviewReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReply
     */
    omit?: ReviewReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReplyInclude<ExtArgs> | null
    /**
     * Filter, which ReviewReplies to fetch.
     */
    where?: ReviewReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewReplies to fetch.
     */
    orderBy?: ReviewReplyOrderByWithRelationInput | ReviewReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReviewReplies.
     */
    cursor?: ReviewReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewReplies.
     */
    skip?: number
    distinct?: ReviewReplyScalarFieldEnum | ReviewReplyScalarFieldEnum[]
  }

  /**
   * ReviewReply create
   */
  export type ReviewReplyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReply
     */
    select?: ReviewReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReply
     */
    omit?: ReviewReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReplyInclude<ExtArgs> | null
    /**
     * The data needed to create a ReviewReply.
     */
    data: XOR<ReviewReplyCreateInput, ReviewReplyUncheckedCreateInput>
  }

  /**
   * ReviewReply createMany
   */
  export type ReviewReplyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReviewReplies.
     */
    data: ReviewReplyCreateManyInput | ReviewReplyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReviewReply createManyAndReturn
   */
  export type ReviewReplyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReply
     */
    select?: ReviewReplySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReply
     */
    omit?: ReviewReplyOmit<ExtArgs> | null
    /**
     * The data used to create many ReviewReplies.
     */
    data: ReviewReplyCreateManyInput | ReviewReplyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReplyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewReply update
   */
  export type ReviewReplyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReply
     */
    select?: ReviewReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReply
     */
    omit?: ReviewReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReplyInclude<ExtArgs> | null
    /**
     * The data needed to update a ReviewReply.
     */
    data: XOR<ReviewReplyUpdateInput, ReviewReplyUncheckedUpdateInput>
    /**
     * Choose, which ReviewReply to update.
     */
    where: ReviewReplyWhereUniqueInput
  }

  /**
   * ReviewReply updateMany
   */
  export type ReviewReplyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReviewReplies.
     */
    data: XOR<ReviewReplyUpdateManyMutationInput, ReviewReplyUncheckedUpdateManyInput>
    /**
     * Filter which ReviewReplies to update
     */
    where?: ReviewReplyWhereInput
    /**
     * Limit how many ReviewReplies to update.
     */
    limit?: number
  }

  /**
   * ReviewReply updateManyAndReturn
   */
  export type ReviewReplyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReply
     */
    select?: ReviewReplySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReply
     */
    omit?: ReviewReplyOmit<ExtArgs> | null
    /**
     * The data used to update ReviewReplies.
     */
    data: XOR<ReviewReplyUpdateManyMutationInput, ReviewReplyUncheckedUpdateManyInput>
    /**
     * Filter which ReviewReplies to update
     */
    where?: ReviewReplyWhereInput
    /**
     * Limit how many ReviewReplies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReplyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewReply upsert
   */
  export type ReviewReplyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReply
     */
    select?: ReviewReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReply
     */
    omit?: ReviewReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReplyInclude<ExtArgs> | null
    /**
     * The filter to search for the ReviewReply to update in case it exists.
     */
    where: ReviewReplyWhereUniqueInput
    /**
     * In case the ReviewReply found by the `where` argument doesn't exist, create a new ReviewReply with this data.
     */
    create: XOR<ReviewReplyCreateInput, ReviewReplyUncheckedCreateInput>
    /**
     * In case the ReviewReply was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewReplyUpdateInput, ReviewReplyUncheckedUpdateInput>
  }

  /**
   * ReviewReply delete
   */
  export type ReviewReplyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReply
     */
    select?: ReviewReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReply
     */
    omit?: ReviewReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReplyInclude<ExtArgs> | null
    /**
     * Filter which ReviewReply to delete.
     */
    where: ReviewReplyWhereUniqueInput
  }

  /**
   * ReviewReply deleteMany
   */
  export type ReviewReplyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewReplies to delete
     */
    where?: ReviewReplyWhereInput
    /**
     * Limit how many ReviewReplies to delete.
     */
    limit?: number
  }

  /**
   * ReviewReply.aiTemplate
   */
  export type ReviewReply$aiTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIReplyTemplate
     */
    select?: AIReplyTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIReplyTemplate
     */
    omit?: AIReplyTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIReplyTemplateInclude<ExtArgs> | null
    where?: AIReplyTemplateWhereInput
  }

  /**
   * ReviewReply.user
   */
  export type ReviewReply$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ReviewReply without action
   */
  export type ReviewReplyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReply
     */
    select?: ReviewReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReply
     */
    omit?: ReviewReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReplyInclude<ExtArgs> | null
  }


  /**
   * Model AIReplyTemplate
   */

  export type AggregateAIReplyTemplate = {
    _count: AIReplyTemplateCountAggregateOutputType | null
    _min: AIReplyTemplateMinAggregateOutputType | null
    _max: AIReplyTemplateMaxAggregateOutputType | null
  }

  export type AIReplyTemplateMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    name: string | null
    content: string | null
    tone: $Enums.ReplyTone | null
    sentiment: $Enums.SentimentType | null
    isDefault: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIReplyTemplateMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    name: string | null
    content: string | null
    tone: $Enums.ReplyTone | null
    sentiment: $Enums.SentimentType | null
    isDefault: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIReplyTemplateCountAggregateOutputType = {
    id: number
    organizationId: number
    name: number
    content: number
    tone: number
    sentiment: number
    isDefault: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AIReplyTemplateMinAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    content?: true
    tone?: true
    sentiment?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIReplyTemplateMaxAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    content?: true
    tone?: true
    sentiment?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIReplyTemplateCountAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    content?: true
    tone?: true
    sentiment?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AIReplyTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIReplyTemplate to aggregate.
     */
    where?: AIReplyTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIReplyTemplates to fetch.
     */
    orderBy?: AIReplyTemplateOrderByWithRelationInput | AIReplyTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIReplyTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIReplyTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIReplyTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIReplyTemplates
    **/
    _count?: true | AIReplyTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIReplyTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIReplyTemplateMaxAggregateInputType
  }

  export type GetAIReplyTemplateAggregateType<T extends AIReplyTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateAIReplyTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIReplyTemplate[P]>
      : GetScalarType<T[P], AggregateAIReplyTemplate[P]>
  }




  export type AIReplyTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIReplyTemplateWhereInput
    orderBy?: AIReplyTemplateOrderByWithAggregationInput | AIReplyTemplateOrderByWithAggregationInput[]
    by: AIReplyTemplateScalarFieldEnum[] | AIReplyTemplateScalarFieldEnum
    having?: AIReplyTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIReplyTemplateCountAggregateInputType | true
    _min?: AIReplyTemplateMinAggregateInputType
    _max?: AIReplyTemplateMaxAggregateInputType
  }

  export type AIReplyTemplateGroupByOutputType = {
    id: string
    organizationId: string
    name: string
    content: string
    tone: $Enums.ReplyTone
    sentiment: $Enums.SentimentType
    isDefault: boolean
    createdAt: Date
    updatedAt: Date
    _count: AIReplyTemplateCountAggregateOutputType | null
    _min: AIReplyTemplateMinAggregateOutputType | null
    _max: AIReplyTemplateMaxAggregateOutputType | null
  }

  type GetAIReplyTemplateGroupByPayload<T extends AIReplyTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIReplyTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIReplyTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIReplyTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], AIReplyTemplateGroupByOutputType[P]>
        }
      >
    >


  export type AIReplyTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    name?: boolean
    content?: boolean
    tone?: boolean
    sentiment?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    replies?: boolean | AIReplyTemplate$repliesArgs<ExtArgs>
    _count?: boolean | AIReplyTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIReplyTemplate"]>

  export type AIReplyTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    name?: boolean
    content?: boolean
    tone?: boolean
    sentiment?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIReplyTemplate"]>

  export type AIReplyTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    name?: boolean
    content?: boolean
    tone?: boolean
    sentiment?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIReplyTemplate"]>

  export type AIReplyTemplateSelectScalar = {
    id?: boolean
    organizationId?: boolean
    name?: boolean
    content?: boolean
    tone?: boolean
    sentiment?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AIReplyTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "name" | "content" | "tone" | "sentiment" | "isDefault" | "createdAt" | "updatedAt", ExtArgs["result"]["aIReplyTemplate"]>
  export type AIReplyTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    replies?: boolean | AIReplyTemplate$repliesArgs<ExtArgs>
    _count?: boolean | AIReplyTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AIReplyTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type AIReplyTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $AIReplyTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIReplyTemplate"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      replies: Prisma.$ReviewReplyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      name: string
      content: string
      tone: $Enums.ReplyTone
      sentiment: $Enums.SentimentType
      isDefault: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aIReplyTemplate"]>
    composites: {}
  }

  type AIReplyTemplateGetPayload<S extends boolean | null | undefined | AIReplyTemplateDefaultArgs> = $Result.GetResult<Prisma.$AIReplyTemplatePayload, S>

  type AIReplyTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIReplyTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIReplyTemplateCountAggregateInputType | true
    }

  export interface AIReplyTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIReplyTemplate'], meta: { name: 'AIReplyTemplate' } }
    /**
     * Find zero or one AIReplyTemplate that matches the filter.
     * @param {AIReplyTemplateFindUniqueArgs} args - Arguments to find a AIReplyTemplate
     * @example
     * // Get one AIReplyTemplate
     * const aIReplyTemplate = await prisma.aIReplyTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIReplyTemplateFindUniqueArgs>(args: SelectSubset<T, AIReplyTemplateFindUniqueArgs<ExtArgs>>): Prisma__AIReplyTemplateClient<$Result.GetResult<Prisma.$AIReplyTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIReplyTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIReplyTemplateFindUniqueOrThrowArgs} args - Arguments to find a AIReplyTemplate
     * @example
     * // Get one AIReplyTemplate
     * const aIReplyTemplate = await prisma.aIReplyTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIReplyTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, AIReplyTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIReplyTemplateClient<$Result.GetResult<Prisma.$AIReplyTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIReplyTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIReplyTemplateFindFirstArgs} args - Arguments to find a AIReplyTemplate
     * @example
     * // Get one AIReplyTemplate
     * const aIReplyTemplate = await prisma.aIReplyTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIReplyTemplateFindFirstArgs>(args?: SelectSubset<T, AIReplyTemplateFindFirstArgs<ExtArgs>>): Prisma__AIReplyTemplateClient<$Result.GetResult<Prisma.$AIReplyTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIReplyTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIReplyTemplateFindFirstOrThrowArgs} args - Arguments to find a AIReplyTemplate
     * @example
     * // Get one AIReplyTemplate
     * const aIReplyTemplate = await prisma.aIReplyTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIReplyTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, AIReplyTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIReplyTemplateClient<$Result.GetResult<Prisma.$AIReplyTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIReplyTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIReplyTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIReplyTemplates
     * const aIReplyTemplates = await prisma.aIReplyTemplate.findMany()
     * 
     * // Get first 10 AIReplyTemplates
     * const aIReplyTemplates = await prisma.aIReplyTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIReplyTemplateWithIdOnly = await prisma.aIReplyTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIReplyTemplateFindManyArgs>(args?: SelectSubset<T, AIReplyTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIReplyTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIReplyTemplate.
     * @param {AIReplyTemplateCreateArgs} args - Arguments to create a AIReplyTemplate.
     * @example
     * // Create one AIReplyTemplate
     * const AIReplyTemplate = await prisma.aIReplyTemplate.create({
     *   data: {
     *     // ... data to create a AIReplyTemplate
     *   }
     * })
     * 
     */
    create<T extends AIReplyTemplateCreateArgs>(args: SelectSubset<T, AIReplyTemplateCreateArgs<ExtArgs>>): Prisma__AIReplyTemplateClient<$Result.GetResult<Prisma.$AIReplyTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIReplyTemplates.
     * @param {AIReplyTemplateCreateManyArgs} args - Arguments to create many AIReplyTemplates.
     * @example
     * // Create many AIReplyTemplates
     * const aIReplyTemplate = await prisma.aIReplyTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIReplyTemplateCreateManyArgs>(args?: SelectSubset<T, AIReplyTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIReplyTemplates and returns the data saved in the database.
     * @param {AIReplyTemplateCreateManyAndReturnArgs} args - Arguments to create many AIReplyTemplates.
     * @example
     * // Create many AIReplyTemplates
     * const aIReplyTemplate = await prisma.aIReplyTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIReplyTemplates and only return the `id`
     * const aIReplyTemplateWithIdOnly = await prisma.aIReplyTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIReplyTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, AIReplyTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIReplyTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIReplyTemplate.
     * @param {AIReplyTemplateDeleteArgs} args - Arguments to delete one AIReplyTemplate.
     * @example
     * // Delete one AIReplyTemplate
     * const AIReplyTemplate = await prisma.aIReplyTemplate.delete({
     *   where: {
     *     // ... filter to delete one AIReplyTemplate
     *   }
     * })
     * 
     */
    delete<T extends AIReplyTemplateDeleteArgs>(args: SelectSubset<T, AIReplyTemplateDeleteArgs<ExtArgs>>): Prisma__AIReplyTemplateClient<$Result.GetResult<Prisma.$AIReplyTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIReplyTemplate.
     * @param {AIReplyTemplateUpdateArgs} args - Arguments to update one AIReplyTemplate.
     * @example
     * // Update one AIReplyTemplate
     * const aIReplyTemplate = await prisma.aIReplyTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIReplyTemplateUpdateArgs>(args: SelectSubset<T, AIReplyTemplateUpdateArgs<ExtArgs>>): Prisma__AIReplyTemplateClient<$Result.GetResult<Prisma.$AIReplyTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIReplyTemplates.
     * @param {AIReplyTemplateDeleteManyArgs} args - Arguments to filter AIReplyTemplates to delete.
     * @example
     * // Delete a few AIReplyTemplates
     * const { count } = await prisma.aIReplyTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIReplyTemplateDeleteManyArgs>(args?: SelectSubset<T, AIReplyTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIReplyTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIReplyTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIReplyTemplates
     * const aIReplyTemplate = await prisma.aIReplyTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIReplyTemplateUpdateManyArgs>(args: SelectSubset<T, AIReplyTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIReplyTemplates and returns the data updated in the database.
     * @param {AIReplyTemplateUpdateManyAndReturnArgs} args - Arguments to update many AIReplyTemplates.
     * @example
     * // Update many AIReplyTemplates
     * const aIReplyTemplate = await prisma.aIReplyTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIReplyTemplates and only return the `id`
     * const aIReplyTemplateWithIdOnly = await prisma.aIReplyTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIReplyTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, AIReplyTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIReplyTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIReplyTemplate.
     * @param {AIReplyTemplateUpsertArgs} args - Arguments to update or create a AIReplyTemplate.
     * @example
     * // Update or create a AIReplyTemplate
     * const aIReplyTemplate = await prisma.aIReplyTemplate.upsert({
     *   create: {
     *     // ... data to create a AIReplyTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIReplyTemplate we want to update
     *   }
     * })
     */
    upsert<T extends AIReplyTemplateUpsertArgs>(args: SelectSubset<T, AIReplyTemplateUpsertArgs<ExtArgs>>): Prisma__AIReplyTemplateClient<$Result.GetResult<Prisma.$AIReplyTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIReplyTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIReplyTemplateCountArgs} args - Arguments to filter AIReplyTemplates to count.
     * @example
     * // Count the number of AIReplyTemplates
     * const count = await prisma.aIReplyTemplate.count({
     *   where: {
     *     // ... the filter for the AIReplyTemplates we want to count
     *   }
     * })
    **/
    count<T extends AIReplyTemplateCountArgs>(
      args?: Subset<T, AIReplyTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIReplyTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIReplyTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIReplyTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIReplyTemplateAggregateArgs>(args: Subset<T, AIReplyTemplateAggregateArgs>): Prisma.PrismaPromise<GetAIReplyTemplateAggregateType<T>>

    /**
     * Group by AIReplyTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIReplyTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIReplyTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIReplyTemplateGroupByArgs['orderBy'] }
        : { orderBy?: AIReplyTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIReplyTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIReplyTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIReplyTemplate model
   */
  readonly fields: AIReplyTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIReplyTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIReplyTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    replies<T extends AIReplyTemplate$repliesArgs<ExtArgs> = {}>(args?: Subset<T, AIReplyTemplate$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewReplyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIReplyTemplate model
   */
  interface AIReplyTemplateFieldRefs {
    readonly id: FieldRef<"AIReplyTemplate", 'String'>
    readonly organizationId: FieldRef<"AIReplyTemplate", 'String'>
    readonly name: FieldRef<"AIReplyTemplate", 'String'>
    readonly content: FieldRef<"AIReplyTemplate", 'String'>
    readonly tone: FieldRef<"AIReplyTemplate", 'ReplyTone'>
    readonly sentiment: FieldRef<"AIReplyTemplate", 'SentimentType'>
    readonly isDefault: FieldRef<"AIReplyTemplate", 'Boolean'>
    readonly createdAt: FieldRef<"AIReplyTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"AIReplyTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIReplyTemplate findUnique
   */
  export type AIReplyTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIReplyTemplate
     */
    select?: AIReplyTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIReplyTemplate
     */
    omit?: AIReplyTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIReplyTemplateInclude<ExtArgs> | null
    /**
     * Filter, which AIReplyTemplate to fetch.
     */
    where: AIReplyTemplateWhereUniqueInput
  }

  /**
   * AIReplyTemplate findUniqueOrThrow
   */
  export type AIReplyTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIReplyTemplate
     */
    select?: AIReplyTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIReplyTemplate
     */
    omit?: AIReplyTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIReplyTemplateInclude<ExtArgs> | null
    /**
     * Filter, which AIReplyTemplate to fetch.
     */
    where: AIReplyTemplateWhereUniqueInput
  }

  /**
   * AIReplyTemplate findFirst
   */
  export type AIReplyTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIReplyTemplate
     */
    select?: AIReplyTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIReplyTemplate
     */
    omit?: AIReplyTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIReplyTemplateInclude<ExtArgs> | null
    /**
     * Filter, which AIReplyTemplate to fetch.
     */
    where?: AIReplyTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIReplyTemplates to fetch.
     */
    orderBy?: AIReplyTemplateOrderByWithRelationInput | AIReplyTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIReplyTemplates.
     */
    cursor?: AIReplyTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIReplyTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIReplyTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIReplyTemplates.
     */
    distinct?: AIReplyTemplateScalarFieldEnum | AIReplyTemplateScalarFieldEnum[]
  }

  /**
   * AIReplyTemplate findFirstOrThrow
   */
  export type AIReplyTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIReplyTemplate
     */
    select?: AIReplyTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIReplyTemplate
     */
    omit?: AIReplyTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIReplyTemplateInclude<ExtArgs> | null
    /**
     * Filter, which AIReplyTemplate to fetch.
     */
    where?: AIReplyTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIReplyTemplates to fetch.
     */
    orderBy?: AIReplyTemplateOrderByWithRelationInput | AIReplyTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIReplyTemplates.
     */
    cursor?: AIReplyTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIReplyTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIReplyTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIReplyTemplates.
     */
    distinct?: AIReplyTemplateScalarFieldEnum | AIReplyTemplateScalarFieldEnum[]
  }

  /**
   * AIReplyTemplate findMany
   */
  export type AIReplyTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIReplyTemplate
     */
    select?: AIReplyTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIReplyTemplate
     */
    omit?: AIReplyTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIReplyTemplateInclude<ExtArgs> | null
    /**
     * Filter, which AIReplyTemplates to fetch.
     */
    where?: AIReplyTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIReplyTemplates to fetch.
     */
    orderBy?: AIReplyTemplateOrderByWithRelationInput | AIReplyTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIReplyTemplates.
     */
    cursor?: AIReplyTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIReplyTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIReplyTemplates.
     */
    skip?: number
    distinct?: AIReplyTemplateScalarFieldEnum | AIReplyTemplateScalarFieldEnum[]
  }

  /**
   * AIReplyTemplate create
   */
  export type AIReplyTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIReplyTemplate
     */
    select?: AIReplyTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIReplyTemplate
     */
    omit?: AIReplyTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIReplyTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a AIReplyTemplate.
     */
    data: XOR<AIReplyTemplateCreateInput, AIReplyTemplateUncheckedCreateInput>
  }

  /**
   * AIReplyTemplate createMany
   */
  export type AIReplyTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIReplyTemplates.
     */
    data: AIReplyTemplateCreateManyInput | AIReplyTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIReplyTemplate createManyAndReturn
   */
  export type AIReplyTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIReplyTemplate
     */
    select?: AIReplyTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIReplyTemplate
     */
    omit?: AIReplyTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many AIReplyTemplates.
     */
    data: AIReplyTemplateCreateManyInput | AIReplyTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIReplyTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIReplyTemplate update
   */
  export type AIReplyTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIReplyTemplate
     */
    select?: AIReplyTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIReplyTemplate
     */
    omit?: AIReplyTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIReplyTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a AIReplyTemplate.
     */
    data: XOR<AIReplyTemplateUpdateInput, AIReplyTemplateUncheckedUpdateInput>
    /**
     * Choose, which AIReplyTemplate to update.
     */
    where: AIReplyTemplateWhereUniqueInput
  }

  /**
   * AIReplyTemplate updateMany
   */
  export type AIReplyTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIReplyTemplates.
     */
    data: XOR<AIReplyTemplateUpdateManyMutationInput, AIReplyTemplateUncheckedUpdateManyInput>
    /**
     * Filter which AIReplyTemplates to update
     */
    where?: AIReplyTemplateWhereInput
    /**
     * Limit how many AIReplyTemplates to update.
     */
    limit?: number
  }

  /**
   * AIReplyTemplate updateManyAndReturn
   */
  export type AIReplyTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIReplyTemplate
     */
    select?: AIReplyTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIReplyTemplate
     */
    omit?: AIReplyTemplateOmit<ExtArgs> | null
    /**
     * The data used to update AIReplyTemplates.
     */
    data: XOR<AIReplyTemplateUpdateManyMutationInput, AIReplyTemplateUncheckedUpdateManyInput>
    /**
     * Filter which AIReplyTemplates to update
     */
    where?: AIReplyTemplateWhereInput
    /**
     * Limit how many AIReplyTemplates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIReplyTemplateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIReplyTemplate upsert
   */
  export type AIReplyTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIReplyTemplate
     */
    select?: AIReplyTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIReplyTemplate
     */
    omit?: AIReplyTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIReplyTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the AIReplyTemplate to update in case it exists.
     */
    where: AIReplyTemplateWhereUniqueInput
    /**
     * In case the AIReplyTemplate found by the `where` argument doesn't exist, create a new AIReplyTemplate with this data.
     */
    create: XOR<AIReplyTemplateCreateInput, AIReplyTemplateUncheckedCreateInput>
    /**
     * In case the AIReplyTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIReplyTemplateUpdateInput, AIReplyTemplateUncheckedUpdateInput>
  }

  /**
   * AIReplyTemplate delete
   */
  export type AIReplyTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIReplyTemplate
     */
    select?: AIReplyTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIReplyTemplate
     */
    omit?: AIReplyTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIReplyTemplateInclude<ExtArgs> | null
    /**
     * Filter which AIReplyTemplate to delete.
     */
    where: AIReplyTemplateWhereUniqueInput
  }

  /**
   * AIReplyTemplate deleteMany
   */
  export type AIReplyTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIReplyTemplates to delete
     */
    where?: AIReplyTemplateWhereInput
    /**
     * Limit how many AIReplyTemplates to delete.
     */
    limit?: number
  }

  /**
   * AIReplyTemplate.replies
   */
  export type AIReplyTemplate$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReply
     */
    select?: ReviewReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReply
     */
    omit?: ReviewReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReplyInclude<ExtArgs> | null
    where?: ReviewReplyWhereInput
    orderBy?: ReviewReplyOrderByWithRelationInput | ReviewReplyOrderByWithRelationInput[]
    cursor?: ReviewReplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewReplyScalarFieldEnum | ReviewReplyScalarFieldEnum[]
  }

  /**
   * AIReplyTemplate without action
   */
  export type AIReplyTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIReplyTemplate
     */
    select?: AIReplyTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIReplyTemplate
     */
    omit?: AIReplyTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIReplyTemplateInclude<ExtArgs> | null
  }


  /**
   * Model Insight
   */

  export type AggregateInsight = {
    _count: InsightCountAggregateOutputType | null
    _avg: InsightAvgAggregateOutputType | null
    _sum: InsightSumAggregateOutputType | null
    _min: InsightMinAggregateOutputType | null
    _max: InsightMaxAggregateOutputType | null
  }

  export type InsightAvgAggregateOutputType = {
    value: number | null
  }

  export type InsightSumAggregateOutputType = {
    value: number | null
  }

  export type InsightMinAggregateOutputType = {
    id: string | null
    locationId: string | null
    date: Date | null
    type: $Enums.InsightType | null
    value: number | null
    createdAt: Date | null
  }

  export type InsightMaxAggregateOutputType = {
    id: string | null
    locationId: string | null
    date: Date | null
    type: $Enums.InsightType | null
    value: number | null
    createdAt: Date | null
  }

  export type InsightCountAggregateOutputType = {
    id: number
    locationId: number
    date: number
    type: number
    value: number
    createdAt: number
    _all: number
  }


  export type InsightAvgAggregateInputType = {
    value?: true
  }

  export type InsightSumAggregateInputType = {
    value?: true
  }

  export type InsightMinAggregateInputType = {
    id?: true
    locationId?: true
    date?: true
    type?: true
    value?: true
    createdAt?: true
  }

  export type InsightMaxAggregateInputType = {
    id?: true
    locationId?: true
    date?: true
    type?: true
    value?: true
    createdAt?: true
  }

  export type InsightCountAggregateInputType = {
    id?: true
    locationId?: true
    date?: true
    type?: true
    value?: true
    createdAt?: true
    _all?: true
  }

  export type InsightAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Insight to aggregate.
     */
    where?: InsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Insights to fetch.
     */
    orderBy?: InsightOrderByWithRelationInput | InsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Insights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Insights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Insights
    **/
    _count?: true | InsightCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InsightAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InsightSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InsightMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InsightMaxAggregateInputType
  }

  export type GetInsightAggregateType<T extends InsightAggregateArgs> = {
        [P in keyof T & keyof AggregateInsight]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInsight[P]>
      : GetScalarType<T[P], AggregateInsight[P]>
  }




  export type InsightGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsightWhereInput
    orderBy?: InsightOrderByWithAggregationInput | InsightOrderByWithAggregationInput[]
    by: InsightScalarFieldEnum[] | InsightScalarFieldEnum
    having?: InsightScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InsightCountAggregateInputType | true
    _avg?: InsightAvgAggregateInputType
    _sum?: InsightSumAggregateInputType
    _min?: InsightMinAggregateInputType
    _max?: InsightMaxAggregateInputType
  }

  export type InsightGroupByOutputType = {
    id: string
    locationId: string
    date: Date
    type: $Enums.InsightType
    value: number
    createdAt: Date
    _count: InsightCountAggregateOutputType | null
    _avg: InsightAvgAggregateOutputType | null
    _sum: InsightSumAggregateOutputType | null
    _min: InsightMinAggregateOutputType | null
    _max: InsightMaxAggregateOutputType | null
  }

  type GetInsightGroupByPayload<T extends InsightGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InsightGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InsightGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InsightGroupByOutputType[P]>
            : GetScalarType<T[P], InsightGroupByOutputType[P]>
        }
      >
    >


  export type InsightSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    date?: boolean
    type?: boolean
    value?: boolean
    createdAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insight"]>

  export type InsightSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    date?: boolean
    type?: boolean
    value?: boolean
    createdAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insight"]>

  export type InsightSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    date?: boolean
    type?: boolean
    value?: boolean
    createdAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insight"]>

  export type InsightSelectScalar = {
    id?: boolean
    locationId?: boolean
    date?: boolean
    type?: boolean
    value?: boolean
    createdAt?: boolean
  }

  export type InsightOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "locationId" | "date" | "type" | "value" | "createdAt", ExtArgs["result"]["insight"]>
  export type InsightInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type InsightIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type InsightIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $InsightPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Insight"
    objects: {
      location: Prisma.$LocationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      locationId: string
      date: Date
      type: $Enums.InsightType
      value: number
      createdAt: Date
    }, ExtArgs["result"]["insight"]>
    composites: {}
  }

  type InsightGetPayload<S extends boolean | null | undefined | InsightDefaultArgs> = $Result.GetResult<Prisma.$InsightPayload, S>

  type InsightCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InsightFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InsightCountAggregateInputType | true
    }

  export interface InsightDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Insight'], meta: { name: 'Insight' } }
    /**
     * Find zero or one Insight that matches the filter.
     * @param {InsightFindUniqueArgs} args - Arguments to find a Insight
     * @example
     * // Get one Insight
     * const insight = await prisma.insight.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InsightFindUniqueArgs>(args: SelectSubset<T, InsightFindUniqueArgs<ExtArgs>>): Prisma__InsightClient<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Insight that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InsightFindUniqueOrThrowArgs} args - Arguments to find a Insight
     * @example
     * // Get one Insight
     * const insight = await prisma.insight.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InsightFindUniqueOrThrowArgs>(args: SelectSubset<T, InsightFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InsightClient<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Insight that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightFindFirstArgs} args - Arguments to find a Insight
     * @example
     * // Get one Insight
     * const insight = await prisma.insight.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InsightFindFirstArgs>(args?: SelectSubset<T, InsightFindFirstArgs<ExtArgs>>): Prisma__InsightClient<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Insight that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightFindFirstOrThrowArgs} args - Arguments to find a Insight
     * @example
     * // Get one Insight
     * const insight = await prisma.insight.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InsightFindFirstOrThrowArgs>(args?: SelectSubset<T, InsightFindFirstOrThrowArgs<ExtArgs>>): Prisma__InsightClient<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Insights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Insights
     * const insights = await prisma.insight.findMany()
     * 
     * // Get first 10 Insights
     * const insights = await prisma.insight.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const insightWithIdOnly = await prisma.insight.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InsightFindManyArgs>(args?: SelectSubset<T, InsightFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Insight.
     * @param {InsightCreateArgs} args - Arguments to create a Insight.
     * @example
     * // Create one Insight
     * const Insight = await prisma.insight.create({
     *   data: {
     *     // ... data to create a Insight
     *   }
     * })
     * 
     */
    create<T extends InsightCreateArgs>(args: SelectSubset<T, InsightCreateArgs<ExtArgs>>): Prisma__InsightClient<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Insights.
     * @param {InsightCreateManyArgs} args - Arguments to create many Insights.
     * @example
     * // Create many Insights
     * const insight = await prisma.insight.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InsightCreateManyArgs>(args?: SelectSubset<T, InsightCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Insights and returns the data saved in the database.
     * @param {InsightCreateManyAndReturnArgs} args - Arguments to create many Insights.
     * @example
     * // Create many Insights
     * const insight = await prisma.insight.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Insights and only return the `id`
     * const insightWithIdOnly = await prisma.insight.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InsightCreateManyAndReturnArgs>(args?: SelectSubset<T, InsightCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Insight.
     * @param {InsightDeleteArgs} args - Arguments to delete one Insight.
     * @example
     * // Delete one Insight
     * const Insight = await prisma.insight.delete({
     *   where: {
     *     // ... filter to delete one Insight
     *   }
     * })
     * 
     */
    delete<T extends InsightDeleteArgs>(args: SelectSubset<T, InsightDeleteArgs<ExtArgs>>): Prisma__InsightClient<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Insight.
     * @param {InsightUpdateArgs} args - Arguments to update one Insight.
     * @example
     * // Update one Insight
     * const insight = await prisma.insight.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InsightUpdateArgs>(args: SelectSubset<T, InsightUpdateArgs<ExtArgs>>): Prisma__InsightClient<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Insights.
     * @param {InsightDeleteManyArgs} args - Arguments to filter Insights to delete.
     * @example
     * // Delete a few Insights
     * const { count } = await prisma.insight.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InsightDeleteManyArgs>(args?: SelectSubset<T, InsightDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Insights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Insights
     * const insight = await prisma.insight.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InsightUpdateManyArgs>(args: SelectSubset<T, InsightUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Insights and returns the data updated in the database.
     * @param {InsightUpdateManyAndReturnArgs} args - Arguments to update many Insights.
     * @example
     * // Update many Insights
     * const insight = await prisma.insight.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Insights and only return the `id`
     * const insightWithIdOnly = await prisma.insight.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InsightUpdateManyAndReturnArgs>(args: SelectSubset<T, InsightUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Insight.
     * @param {InsightUpsertArgs} args - Arguments to update or create a Insight.
     * @example
     * // Update or create a Insight
     * const insight = await prisma.insight.upsert({
     *   create: {
     *     // ... data to create a Insight
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Insight we want to update
     *   }
     * })
     */
    upsert<T extends InsightUpsertArgs>(args: SelectSubset<T, InsightUpsertArgs<ExtArgs>>): Prisma__InsightClient<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Insights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightCountArgs} args - Arguments to filter Insights to count.
     * @example
     * // Count the number of Insights
     * const count = await prisma.insight.count({
     *   where: {
     *     // ... the filter for the Insights we want to count
     *   }
     * })
    **/
    count<T extends InsightCountArgs>(
      args?: Subset<T, InsightCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InsightCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Insight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InsightAggregateArgs>(args: Subset<T, InsightAggregateArgs>): Prisma.PrismaPromise<GetInsightAggregateType<T>>

    /**
     * Group by Insight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InsightGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InsightGroupByArgs['orderBy'] }
        : { orderBy?: InsightGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InsightGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInsightGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Insight model
   */
  readonly fields: InsightFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Insight.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InsightClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Insight model
   */
  interface InsightFieldRefs {
    readonly id: FieldRef<"Insight", 'String'>
    readonly locationId: FieldRef<"Insight", 'String'>
    readonly date: FieldRef<"Insight", 'DateTime'>
    readonly type: FieldRef<"Insight", 'InsightType'>
    readonly value: FieldRef<"Insight", 'Int'>
    readonly createdAt: FieldRef<"Insight", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Insight findUnique
   */
  export type InsightFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Insight
     */
    omit?: InsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInclude<ExtArgs> | null
    /**
     * Filter, which Insight to fetch.
     */
    where: InsightWhereUniqueInput
  }

  /**
   * Insight findUniqueOrThrow
   */
  export type InsightFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Insight
     */
    omit?: InsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInclude<ExtArgs> | null
    /**
     * Filter, which Insight to fetch.
     */
    where: InsightWhereUniqueInput
  }

  /**
   * Insight findFirst
   */
  export type InsightFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Insight
     */
    omit?: InsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInclude<ExtArgs> | null
    /**
     * Filter, which Insight to fetch.
     */
    where?: InsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Insights to fetch.
     */
    orderBy?: InsightOrderByWithRelationInput | InsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Insights.
     */
    cursor?: InsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Insights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Insights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Insights.
     */
    distinct?: InsightScalarFieldEnum | InsightScalarFieldEnum[]
  }

  /**
   * Insight findFirstOrThrow
   */
  export type InsightFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Insight
     */
    omit?: InsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInclude<ExtArgs> | null
    /**
     * Filter, which Insight to fetch.
     */
    where?: InsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Insights to fetch.
     */
    orderBy?: InsightOrderByWithRelationInput | InsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Insights.
     */
    cursor?: InsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Insights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Insights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Insights.
     */
    distinct?: InsightScalarFieldEnum | InsightScalarFieldEnum[]
  }

  /**
   * Insight findMany
   */
  export type InsightFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Insight
     */
    omit?: InsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInclude<ExtArgs> | null
    /**
     * Filter, which Insights to fetch.
     */
    where?: InsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Insights to fetch.
     */
    orderBy?: InsightOrderByWithRelationInput | InsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Insights.
     */
    cursor?: InsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Insights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Insights.
     */
    skip?: number
    distinct?: InsightScalarFieldEnum | InsightScalarFieldEnum[]
  }

  /**
   * Insight create
   */
  export type InsightCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Insight
     */
    omit?: InsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInclude<ExtArgs> | null
    /**
     * The data needed to create a Insight.
     */
    data: XOR<InsightCreateInput, InsightUncheckedCreateInput>
  }

  /**
   * Insight createMany
   */
  export type InsightCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Insights.
     */
    data: InsightCreateManyInput | InsightCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Insight createManyAndReturn
   */
  export type InsightCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Insight
     */
    omit?: InsightOmit<ExtArgs> | null
    /**
     * The data used to create many Insights.
     */
    data: InsightCreateManyInput | InsightCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Insight update
   */
  export type InsightUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Insight
     */
    omit?: InsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInclude<ExtArgs> | null
    /**
     * The data needed to update a Insight.
     */
    data: XOR<InsightUpdateInput, InsightUncheckedUpdateInput>
    /**
     * Choose, which Insight to update.
     */
    where: InsightWhereUniqueInput
  }

  /**
   * Insight updateMany
   */
  export type InsightUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Insights.
     */
    data: XOR<InsightUpdateManyMutationInput, InsightUncheckedUpdateManyInput>
    /**
     * Filter which Insights to update
     */
    where?: InsightWhereInput
    /**
     * Limit how many Insights to update.
     */
    limit?: number
  }

  /**
   * Insight updateManyAndReturn
   */
  export type InsightUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Insight
     */
    omit?: InsightOmit<ExtArgs> | null
    /**
     * The data used to update Insights.
     */
    data: XOR<InsightUpdateManyMutationInput, InsightUncheckedUpdateManyInput>
    /**
     * Filter which Insights to update
     */
    where?: InsightWhereInput
    /**
     * Limit how many Insights to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Insight upsert
   */
  export type InsightUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Insight
     */
    omit?: InsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInclude<ExtArgs> | null
    /**
     * The filter to search for the Insight to update in case it exists.
     */
    where: InsightWhereUniqueInput
    /**
     * In case the Insight found by the `where` argument doesn't exist, create a new Insight with this data.
     */
    create: XOR<InsightCreateInput, InsightUncheckedCreateInput>
    /**
     * In case the Insight was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InsightUpdateInput, InsightUncheckedUpdateInput>
  }

  /**
   * Insight delete
   */
  export type InsightDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Insight
     */
    omit?: InsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInclude<ExtArgs> | null
    /**
     * Filter which Insight to delete.
     */
    where: InsightWhereUniqueInput
  }

  /**
   * Insight deleteMany
   */
  export type InsightDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Insights to delete
     */
    where?: InsightWhereInput
    /**
     * Limit how many Insights to delete.
     */
    limit?: number
  }

  /**
   * Insight without action
   */
  export type InsightDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Insight
     */
    omit?: InsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInclude<ExtArgs> | null
  }


  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportMinAggregateOutputType = {
    id: string | null
    locationId: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    reportType: $Enums.ReportType | null
    fileUrl: string | null
    status: $Enums.ReportStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportMaxAggregateOutputType = {
    id: string | null
    locationId: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    reportType: $Enums.ReportType | null
    fileUrl: string | null
    status: $Enums.ReportStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    locationId: number
    name: number
    startDate: number
    endDate: number
    reportType: number
    fileUrl: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReportMinAggregateInputType = {
    id?: true
    locationId?: true
    name?: true
    startDate?: true
    endDate?: true
    reportType?: true
    fileUrl?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    locationId?: true
    name?: true
    startDate?: true
    endDate?: true
    reportType?: true
    fileUrl?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    locationId?: true
    name?: true
    startDate?: true
    endDate?: true
    reportType?: true
    fileUrl?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: string
    locationId: string
    name: string
    startDate: Date
    endDate: Date
    reportType: $Enums.ReportType
    fileUrl: string | null
    status: $Enums.ReportStatus
    createdAt: Date
    updatedAt: Date
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    reportType?: boolean
    fileUrl?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    reportType?: boolean
    fileUrl?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    reportType?: boolean
    fileUrl?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectScalar = {
    id?: boolean
    locationId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    reportType?: boolean
    fileUrl?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "locationId" | "name" | "startDate" | "endDate" | "reportType" | "fileUrl" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["report"]>
  export type ReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type ReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type ReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {
      location: Prisma.$LocationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      locationId: string
      name: string
      startDate: Date
      endDate: Date
      reportType: $Enums.ReportType
      fileUrl: string | null
      status: $Enums.ReportStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["report"]>
    composites: {}
  }

  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportFindUniqueArgs>(args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportFindFirstArgs>(args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportFindManyArgs>(args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
     */
    create<T extends ReportCreateArgs>(args: SelectSubset<T, ReportCreateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reports.
     * @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportCreateManyArgs>(args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reports and returns the data saved in the database.
     * @param {ReportCreateManyAndReturnArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
     */
    delete<T extends ReportDeleteArgs>(args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportUpdateArgs>(args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportDeleteManyArgs>(args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportUpdateManyArgs>(args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports and returns the data updated in the database.
     * @param {ReportUpdateManyAndReturnArgs} args - Arguments to update many Reports.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
     */
    upsert<T extends ReportUpsertArgs>(args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Report model
   */
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'String'>
    readonly locationId: FieldRef<"Report", 'String'>
    readonly name: FieldRef<"Report", 'String'>
    readonly startDate: FieldRef<"Report", 'DateTime'>
    readonly endDate: FieldRef<"Report", 'DateTime'>
    readonly reportType: FieldRef<"Report", 'ReportType'>
    readonly fileUrl: FieldRef<"Report", 'String'>
    readonly status: FieldRef<"Report", 'ReportStatus'>
    readonly createdAt: FieldRef<"Report", 'DateTime'>
    readonly updatedAt: FieldRef<"Report", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }

  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Report createManyAndReturn
   */
  export type ReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to update.
     */
    limit?: number
  }

  /**
   * Report updateManyAndReturn
   */
  export type ReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }

  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to delete.
     */
    limit?: number
  }

  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
  }


  /**
   * Model ReportJob
   */

  export type AggregateReportJob = {
    _count: ReportJobCountAggregateOutputType | null
    _min: ReportJobMinAggregateOutputType | null
    _max: ReportJobMaxAggregateOutputType | null
  }

  export type ReportJobMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    name: string | null
    frequency: $Enums.ReportFrequency | null
    isActive: boolean | null
    lastRunAt: Date | null
    nextRunAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportJobMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    name: string | null
    frequency: $Enums.ReportFrequency | null
    isActive: boolean | null
    lastRunAt: Date | null
    nextRunAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportJobCountAggregateOutputType = {
    id: number
    organizationId: number
    name: number
    locations: number
    frequency: number
    emailRecipients: number
    isActive: number
    lastRunAt: number
    nextRunAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReportJobMinAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    frequency?: true
    isActive?: true
    lastRunAt?: true
    nextRunAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportJobMaxAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    frequency?: true
    isActive?: true
    lastRunAt?: true
    nextRunAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportJobCountAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    locations?: true
    frequency?: true
    emailRecipients?: true
    isActive?: true
    lastRunAt?: true
    nextRunAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReportJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportJob to aggregate.
     */
    where?: ReportJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportJobs to fetch.
     */
    orderBy?: ReportJobOrderByWithRelationInput | ReportJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportJobs
    **/
    _count?: true | ReportJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportJobMaxAggregateInputType
  }

  export type GetReportJobAggregateType<T extends ReportJobAggregateArgs> = {
        [P in keyof T & keyof AggregateReportJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportJob[P]>
      : GetScalarType<T[P], AggregateReportJob[P]>
  }




  export type ReportJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportJobWhereInput
    orderBy?: ReportJobOrderByWithAggregationInput | ReportJobOrderByWithAggregationInput[]
    by: ReportJobScalarFieldEnum[] | ReportJobScalarFieldEnum
    having?: ReportJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportJobCountAggregateInputType | true
    _min?: ReportJobMinAggregateInputType
    _max?: ReportJobMaxAggregateInputType
  }

  export type ReportJobGroupByOutputType = {
    id: string
    organizationId: string
    name: string
    locations: string[]
    frequency: $Enums.ReportFrequency
    emailRecipients: string[]
    isActive: boolean
    lastRunAt: Date | null
    nextRunAt: Date
    createdAt: Date
    updatedAt: Date
    _count: ReportJobCountAggregateOutputType | null
    _min: ReportJobMinAggregateOutputType | null
    _max: ReportJobMaxAggregateOutputType | null
  }

  type GetReportJobGroupByPayload<T extends ReportJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportJobGroupByOutputType[P]>
            : GetScalarType<T[P], ReportJobGroupByOutputType[P]>
        }
      >
    >


  export type ReportJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    name?: boolean
    locations?: boolean
    frequency?: boolean
    emailRecipients?: boolean
    isActive?: boolean
    lastRunAt?: boolean
    nextRunAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportJob"]>

  export type ReportJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    name?: boolean
    locations?: boolean
    frequency?: boolean
    emailRecipients?: boolean
    isActive?: boolean
    lastRunAt?: boolean
    nextRunAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportJob"]>

  export type ReportJobSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    name?: boolean
    locations?: boolean
    frequency?: boolean
    emailRecipients?: boolean
    isActive?: boolean
    lastRunAt?: boolean
    nextRunAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportJob"]>

  export type ReportJobSelectScalar = {
    id?: boolean
    organizationId?: boolean
    name?: boolean
    locations?: boolean
    frequency?: boolean
    emailRecipients?: boolean
    isActive?: boolean
    lastRunAt?: boolean
    nextRunAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReportJobOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "name" | "locations" | "frequency" | "emailRecipients" | "isActive" | "lastRunAt" | "nextRunAt" | "createdAt" | "updatedAt", ExtArgs["result"]["reportJob"]>
  export type ReportJobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type ReportJobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type ReportJobIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $ReportJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReportJob"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      name: string
      locations: string[]
      frequency: $Enums.ReportFrequency
      emailRecipients: string[]
      isActive: boolean
      lastRunAt: Date | null
      nextRunAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["reportJob"]>
    composites: {}
  }

  type ReportJobGetPayload<S extends boolean | null | undefined | ReportJobDefaultArgs> = $Result.GetResult<Prisma.$ReportJobPayload, S>

  type ReportJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportJobFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportJobCountAggregateInputType | true
    }

  export interface ReportJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReportJob'], meta: { name: 'ReportJob' } }
    /**
     * Find zero or one ReportJob that matches the filter.
     * @param {ReportJobFindUniqueArgs} args - Arguments to find a ReportJob
     * @example
     * // Get one ReportJob
     * const reportJob = await prisma.reportJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportJobFindUniqueArgs>(args: SelectSubset<T, ReportJobFindUniqueArgs<ExtArgs>>): Prisma__ReportJobClient<$Result.GetResult<Prisma.$ReportJobPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReportJob that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportJobFindUniqueOrThrowArgs} args - Arguments to find a ReportJob
     * @example
     * // Get one ReportJob
     * const reportJob = await prisma.reportJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportJobFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportJobClient<$Result.GetResult<Prisma.$ReportJobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportJobFindFirstArgs} args - Arguments to find a ReportJob
     * @example
     * // Get one ReportJob
     * const reportJob = await prisma.reportJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportJobFindFirstArgs>(args?: SelectSubset<T, ReportJobFindFirstArgs<ExtArgs>>): Prisma__ReportJobClient<$Result.GetResult<Prisma.$ReportJobPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportJobFindFirstOrThrowArgs} args - Arguments to find a ReportJob
     * @example
     * // Get one ReportJob
     * const reportJob = await prisma.reportJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportJobFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportJobClient<$Result.GetResult<Prisma.$ReportJobPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReportJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportJobs
     * const reportJobs = await prisma.reportJob.findMany()
     * 
     * // Get first 10 ReportJobs
     * const reportJobs = await prisma.reportJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportJobWithIdOnly = await prisma.reportJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportJobFindManyArgs>(args?: SelectSubset<T, ReportJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportJobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReportJob.
     * @param {ReportJobCreateArgs} args - Arguments to create a ReportJob.
     * @example
     * // Create one ReportJob
     * const ReportJob = await prisma.reportJob.create({
     *   data: {
     *     // ... data to create a ReportJob
     *   }
     * })
     * 
     */
    create<T extends ReportJobCreateArgs>(args: SelectSubset<T, ReportJobCreateArgs<ExtArgs>>): Prisma__ReportJobClient<$Result.GetResult<Prisma.$ReportJobPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReportJobs.
     * @param {ReportJobCreateManyArgs} args - Arguments to create many ReportJobs.
     * @example
     * // Create many ReportJobs
     * const reportJob = await prisma.reportJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportJobCreateManyArgs>(args?: SelectSubset<T, ReportJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReportJobs and returns the data saved in the database.
     * @param {ReportJobCreateManyAndReturnArgs} args - Arguments to create many ReportJobs.
     * @example
     * // Create many ReportJobs
     * const reportJob = await prisma.reportJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReportJobs and only return the `id`
     * const reportJobWithIdOnly = await prisma.reportJob.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportJobCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportJobPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReportJob.
     * @param {ReportJobDeleteArgs} args - Arguments to delete one ReportJob.
     * @example
     * // Delete one ReportJob
     * const ReportJob = await prisma.reportJob.delete({
     *   where: {
     *     // ... filter to delete one ReportJob
     *   }
     * })
     * 
     */
    delete<T extends ReportJobDeleteArgs>(args: SelectSubset<T, ReportJobDeleteArgs<ExtArgs>>): Prisma__ReportJobClient<$Result.GetResult<Prisma.$ReportJobPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReportJob.
     * @param {ReportJobUpdateArgs} args - Arguments to update one ReportJob.
     * @example
     * // Update one ReportJob
     * const reportJob = await prisma.reportJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportJobUpdateArgs>(args: SelectSubset<T, ReportJobUpdateArgs<ExtArgs>>): Prisma__ReportJobClient<$Result.GetResult<Prisma.$ReportJobPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReportJobs.
     * @param {ReportJobDeleteManyArgs} args - Arguments to filter ReportJobs to delete.
     * @example
     * // Delete a few ReportJobs
     * const { count } = await prisma.reportJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportJobDeleteManyArgs>(args?: SelectSubset<T, ReportJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportJobs
     * const reportJob = await prisma.reportJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportJobUpdateManyArgs>(args: SelectSubset<T, ReportJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportJobs and returns the data updated in the database.
     * @param {ReportJobUpdateManyAndReturnArgs} args - Arguments to update many ReportJobs.
     * @example
     * // Update many ReportJobs
     * const reportJob = await prisma.reportJob.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReportJobs and only return the `id`
     * const reportJobWithIdOnly = await prisma.reportJob.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportJobUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportJobUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportJobPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReportJob.
     * @param {ReportJobUpsertArgs} args - Arguments to update or create a ReportJob.
     * @example
     * // Update or create a ReportJob
     * const reportJob = await prisma.reportJob.upsert({
     *   create: {
     *     // ... data to create a ReportJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportJob we want to update
     *   }
     * })
     */
    upsert<T extends ReportJobUpsertArgs>(args: SelectSubset<T, ReportJobUpsertArgs<ExtArgs>>): Prisma__ReportJobClient<$Result.GetResult<Prisma.$ReportJobPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReportJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportJobCountArgs} args - Arguments to filter ReportJobs to count.
     * @example
     * // Count the number of ReportJobs
     * const count = await prisma.reportJob.count({
     *   where: {
     *     // ... the filter for the ReportJobs we want to count
     *   }
     * })
    **/
    count<T extends ReportJobCountArgs>(
      args?: Subset<T, ReportJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportJobAggregateArgs>(args: Subset<T, ReportJobAggregateArgs>): Prisma.PrismaPromise<GetReportJobAggregateType<T>>

    /**
     * Group by ReportJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportJobGroupByArgs['orderBy'] }
        : { orderBy?: ReportJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReportJob model
   */
  readonly fields: ReportJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReportJob model
   */
  interface ReportJobFieldRefs {
    readonly id: FieldRef<"ReportJob", 'String'>
    readonly organizationId: FieldRef<"ReportJob", 'String'>
    readonly name: FieldRef<"ReportJob", 'String'>
    readonly locations: FieldRef<"ReportJob", 'String[]'>
    readonly frequency: FieldRef<"ReportJob", 'ReportFrequency'>
    readonly emailRecipients: FieldRef<"ReportJob", 'String[]'>
    readonly isActive: FieldRef<"ReportJob", 'Boolean'>
    readonly lastRunAt: FieldRef<"ReportJob", 'DateTime'>
    readonly nextRunAt: FieldRef<"ReportJob", 'DateTime'>
    readonly createdAt: FieldRef<"ReportJob", 'DateTime'>
    readonly updatedAt: FieldRef<"ReportJob", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReportJob findUnique
   */
  export type ReportJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportJob
     */
    select?: ReportJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportJob
     */
    omit?: ReportJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportJobInclude<ExtArgs> | null
    /**
     * Filter, which ReportJob to fetch.
     */
    where: ReportJobWhereUniqueInput
  }

  /**
   * ReportJob findUniqueOrThrow
   */
  export type ReportJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportJob
     */
    select?: ReportJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportJob
     */
    omit?: ReportJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportJobInclude<ExtArgs> | null
    /**
     * Filter, which ReportJob to fetch.
     */
    where: ReportJobWhereUniqueInput
  }

  /**
   * ReportJob findFirst
   */
  export type ReportJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportJob
     */
    select?: ReportJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportJob
     */
    omit?: ReportJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportJobInclude<ExtArgs> | null
    /**
     * Filter, which ReportJob to fetch.
     */
    where?: ReportJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportJobs to fetch.
     */
    orderBy?: ReportJobOrderByWithRelationInput | ReportJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportJobs.
     */
    cursor?: ReportJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportJobs.
     */
    distinct?: ReportJobScalarFieldEnum | ReportJobScalarFieldEnum[]
  }

  /**
   * ReportJob findFirstOrThrow
   */
  export type ReportJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportJob
     */
    select?: ReportJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportJob
     */
    omit?: ReportJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportJobInclude<ExtArgs> | null
    /**
     * Filter, which ReportJob to fetch.
     */
    where?: ReportJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportJobs to fetch.
     */
    orderBy?: ReportJobOrderByWithRelationInput | ReportJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportJobs.
     */
    cursor?: ReportJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportJobs.
     */
    distinct?: ReportJobScalarFieldEnum | ReportJobScalarFieldEnum[]
  }

  /**
   * ReportJob findMany
   */
  export type ReportJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportJob
     */
    select?: ReportJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportJob
     */
    omit?: ReportJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportJobInclude<ExtArgs> | null
    /**
     * Filter, which ReportJobs to fetch.
     */
    where?: ReportJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportJobs to fetch.
     */
    orderBy?: ReportJobOrderByWithRelationInput | ReportJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportJobs.
     */
    cursor?: ReportJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportJobs.
     */
    skip?: number
    distinct?: ReportJobScalarFieldEnum | ReportJobScalarFieldEnum[]
  }

  /**
   * ReportJob create
   */
  export type ReportJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportJob
     */
    select?: ReportJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportJob
     */
    omit?: ReportJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportJobInclude<ExtArgs> | null
    /**
     * The data needed to create a ReportJob.
     */
    data: XOR<ReportJobCreateInput, ReportJobUncheckedCreateInput>
  }

  /**
   * ReportJob createMany
   */
  export type ReportJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReportJobs.
     */
    data: ReportJobCreateManyInput | ReportJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportJob createManyAndReturn
   */
  export type ReportJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportJob
     */
    select?: ReportJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportJob
     */
    omit?: ReportJobOmit<ExtArgs> | null
    /**
     * The data used to create many ReportJobs.
     */
    data: ReportJobCreateManyInput | ReportJobCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportJobIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportJob update
   */
  export type ReportJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportJob
     */
    select?: ReportJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportJob
     */
    omit?: ReportJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportJobInclude<ExtArgs> | null
    /**
     * The data needed to update a ReportJob.
     */
    data: XOR<ReportJobUpdateInput, ReportJobUncheckedUpdateInput>
    /**
     * Choose, which ReportJob to update.
     */
    where: ReportJobWhereUniqueInput
  }

  /**
   * ReportJob updateMany
   */
  export type ReportJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReportJobs.
     */
    data: XOR<ReportJobUpdateManyMutationInput, ReportJobUncheckedUpdateManyInput>
    /**
     * Filter which ReportJobs to update
     */
    where?: ReportJobWhereInput
    /**
     * Limit how many ReportJobs to update.
     */
    limit?: number
  }

  /**
   * ReportJob updateManyAndReturn
   */
  export type ReportJobUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportJob
     */
    select?: ReportJobSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportJob
     */
    omit?: ReportJobOmit<ExtArgs> | null
    /**
     * The data used to update ReportJobs.
     */
    data: XOR<ReportJobUpdateManyMutationInput, ReportJobUncheckedUpdateManyInput>
    /**
     * Filter which ReportJobs to update
     */
    where?: ReportJobWhereInput
    /**
     * Limit how many ReportJobs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportJobIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportJob upsert
   */
  export type ReportJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportJob
     */
    select?: ReportJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportJob
     */
    omit?: ReportJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportJobInclude<ExtArgs> | null
    /**
     * The filter to search for the ReportJob to update in case it exists.
     */
    where: ReportJobWhereUniqueInput
    /**
     * In case the ReportJob found by the `where` argument doesn't exist, create a new ReportJob with this data.
     */
    create: XOR<ReportJobCreateInput, ReportJobUncheckedCreateInput>
    /**
     * In case the ReportJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportJobUpdateInput, ReportJobUncheckedUpdateInput>
  }

  /**
   * ReportJob delete
   */
  export type ReportJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportJob
     */
    select?: ReportJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportJob
     */
    omit?: ReportJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportJobInclude<ExtArgs> | null
    /**
     * Filter which ReportJob to delete.
     */
    where: ReportJobWhereUniqueInput
  }

  /**
   * ReportJob deleteMany
   */
  export type ReportJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportJobs to delete
     */
    where?: ReportJobWhereInput
    /**
     * Limit how many ReportJobs to delete.
     */
    limit?: number
  }

  /**
   * ReportJob without action
   */
  export type ReportJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportJob
     */
    select?: ReportJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportJob
     */
    omit?: ReportJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportJobInclude<ExtArgs> | null
  }


  /**
   * Model SearchKeyword
   */

  export type AggregateSearchKeyword = {
    _count: SearchKeywordCountAggregateOutputType | null
    _avg: SearchKeywordAvgAggregateOutputType | null
    _sum: SearchKeywordSumAggregateOutputType | null
    _min: SearchKeywordMinAggregateOutputType | null
    _max: SearchKeywordMaxAggregateOutputType | null
  }

  export type SearchKeywordAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type SearchKeywordSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type SearchKeywordMinAggregateOutputType = {
    id: string | null
    keyword: string | null
    locationId: string | null
    latitude: number | null
    longitude: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SearchKeywordMaxAggregateOutputType = {
    id: string | null
    keyword: string | null
    locationId: string | null
    latitude: number | null
    longitude: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SearchKeywordCountAggregateOutputType = {
    id: number
    keyword: number
    locationId: number
    latitude: number
    longitude: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SearchKeywordAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type SearchKeywordSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type SearchKeywordMinAggregateInputType = {
    id?: true
    keyword?: true
    locationId?: true
    latitude?: true
    longitude?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SearchKeywordMaxAggregateInputType = {
    id?: true
    keyword?: true
    locationId?: true
    latitude?: true
    longitude?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SearchKeywordCountAggregateInputType = {
    id?: true
    keyword?: true
    locationId?: true
    latitude?: true
    longitude?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SearchKeywordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchKeyword to aggregate.
     */
    where?: SearchKeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchKeywords to fetch.
     */
    orderBy?: SearchKeywordOrderByWithRelationInput | SearchKeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SearchKeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchKeywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchKeywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SearchKeywords
    **/
    _count?: true | SearchKeywordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SearchKeywordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SearchKeywordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SearchKeywordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SearchKeywordMaxAggregateInputType
  }

  export type GetSearchKeywordAggregateType<T extends SearchKeywordAggregateArgs> = {
        [P in keyof T & keyof AggregateSearchKeyword]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSearchKeyword[P]>
      : GetScalarType<T[P], AggregateSearchKeyword[P]>
  }




  export type SearchKeywordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchKeywordWhereInput
    orderBy?: SearchKeywordOrderByWithAggregationInput | SearchKeywordOrderByWithAggregationInput[]
    by: SearchKeywordScalarFieldEnum[] | SearchKeywordScalarFieldEnum
    having?: SearchKeywordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SearchKeywordCountAggregateInputType | true
    _avg?: SearchKeywordAvgAggregateInputType
    _sum?: SearchKeywordSumAggregateInputType
    _min?: SearchKeywordMinAggregateInputType
    _max?: SearchKeywordMaxAggregateInputType
  }

  export type SearchKeywordGroupByOutputType = {
    id: string
    keyword: string
    locationId: string
    latitude: number
    longitude: number
    createdAt: Date
    updatedAt: Date
    _count: SearchKeywordCountAggregateOutputType | null
    _avg: SearchKeywordAvgAggregateOutputType | null
    _sum: SearchKeywordSumAggregateOutputType | null
    _min: SearchKeywordMinAggregateOutputType | null
    _max: SearchKeywordMaxAggregateOutputType | null
  }

  type GetSearchKeywordGroupByPayload<T extends SearchKeywordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SearchKeywordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SearchKeywordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SearchKeywordGroupByOutputType[P]>
            : GetScalarType<T[P], SearchKeywordGroupByOutputType[P]>
        }
      >
    >


  export type SearchKeywordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keyword?: boolean
    locationId?: boolean
    latitude?: boolean
    longitude?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    rankResults?: boolean | SearchKeyword$rankResultsArgs<ExtArgs>
    _count?: boolean | SearchKeywordCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["searchKeyword"]>

  export type SearchKeywordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keyword?: boolean
    locationId?: boolean
    latitude?: boolean
    longitude?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["searchKeyword"]>

  export type SearchKeywordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keyword?: boolean
    locationId?: boolean
    latitude?: boolean
    longitude?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["searchKeyword"]>

  export type SearchKeywordSelectScalar = {
    id?: boolean
    keyword?: boolean
    locationId?: boolean
    latitude?: boolean
    longitude?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SearchKeywordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "keyword" | "locationId" | "latitude" | "longitude" | "createdAt" | "updatedAt", ExtArgs["result"]["searchKeyword"]>
  export type SearchKeywordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    rankResults?: boolean | SearchKeyword$rankResultsArgs<ExtArgs>
    _count?: boolean | SearchKeywordCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SearchKeywordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type SearchKeywordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $SearchKeywordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SearchKeyword"
    objects: {
      location: Prisma.$LocationPayload<ExtArgs>
      rankResults: Prisma.$RankTrackingResultPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      keyword: string
      locationId: string
      latitude: number
      longitude: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["searchKeyword"]>
    composites: {}
  }

  type SearchKeywordGetPayload<S extends boolean | null | undefined | SearchKeywordDefaultArgs> = $Result.GetResult<Prisma.$SearchKeywordPayload, S>

  type SearchKeywordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SearchKeywordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SearchKeywordCountAggregateInputType | true
    }

  export interface SearchKeywordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SearchKeyword'], meta: { name: 'SearchKeyword' } }
    /**
     * Find zero or one SearchKeyword that matches the filter.
     * @param {SearchKeywordFindUniqueArgs} args - Arguments to find a SearchKeyword
     * @example
     * // Get one SearchKeyword
     * const searchKeyword = await prisma.searchKeyword.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SearchKeywordFindUniqueArgs>(args: SelectSubset<T, SearchKeywordFindUniqueArgs<ExtArgs>>): Prisma__SearchKeywordClient<$Result.GetResult<Prisma.$SearchKeywordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SearchKeyword that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SearchKeywordFindUniqueOrThrowArgs} args - Arguments to find a SearchKeyword
     * @example
     * // Get one SearchKeyword
     * const searchKeyword = await prisma.searchKeyword.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SearchKeywordFindUniqueOrThrowArgs>(args: SelectSubset<T, SearchKeywordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SearchKeywordClient<$Result.GetResult<Prisma.$SearchKeywordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SearchKeyword that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchKeywordFindFirstArgs} args - Arguments to find a SearchKeyword
     * @example
     * // Get one SearchKeyword
     * const searchKeyword = await prisma.searchKeyword.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SearchKeywordFindFirstArgs>(args?: SelectSubset<T, SearchKeywordFindFirstArgs<ExtArgs>>): Prisma__SearchKeywordClient<$Result.GetResult<Prisma.$SearchKeywordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SearchKeyword that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchKeywordFindFirstOrThrowArgs} args - Arguments to find a SearchKeyword
     * @example
     * // Get one SearchKeyword
     * const searchKeyword = await prisma.searchKeyword.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SearchKeywordFindFirstOrThrowArgs>(args?: SelectSubset<T, SearchKeywordFindFirstOrThrowArgs<ExtArgs>>): Prisma__SearchKeywordClient<$Result.GetResult<Prisma.$SearchKeywordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SearchKeywords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchKeywordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SearchKeywords
     * const searchKeywords = await prisma.searchKeyword.findMany()
     * 
     * // Get first 10 SearchKeywords
     * const searchKeywords = await prisma.searchKeyword.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const searchKeywordWithIdOnly = await prisma.searchKeyword.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SearchKeywordFindManyArgs>(args?: SelectSubset<T, SearchKeywordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchKeywordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SearchKeyword.
     * @param {SearchKeywordCreateArgs} args - Arguments to create a SearchKeyword.
     * @example
     * // Create one SearchKeyword
     * const SearchKeyword = await prisma.searchKeyword.create({
     *   data: {
     *     // ... data to create a SearchKeyword
     *   }
     * })
     * 
     */
    create<T extends SearchKeywordCreateArgs>(args: SelectSubset<T, SearchKeywordCreateArgs<ExtArgs>>): Prisma__SearchKeywordClient<$Result.GetResult<Prisma.$SearchKeywordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SearchKeywords.
     * @param {SearchKeywordCreateManyArgs} args - Arguments to create many SearchKeywords.
     * @example
     * // Create many SearchKeywords
     * const searchKeyword = await prisma.searchKeyword.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SearchKeywordCreateManyArgs>(args?: SelectSubset<T, SearchKeywordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SearchKeywords and returns the data saved in the database.
     * @param {SearchKeywordCreateManyAndReturnArgs} args - Arguments to create many SearchKeywords.
     * @example
     * // Create many SearchKeywords
     * const searchKeyword = await prisma.searchKeyword.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SearchKeywords and only return the `id`
     * const searchKeywordWithIdOnly = await prisma.searchKeyword.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SearchKeywordCreateManyAndReturnArgs>(args?: SelectSubset<T, SearchKeywordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchKeywordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SearchKeyword.
     * @param {SearchKeywordDeleteArgs} args - Arguments to delete one SearchKeyword.
     * @example
     * // Delete one SearchKeyword
     * const SearchKeyword = await prisma.searchKeyword.delete({
     *   where: {
     *     // ... filter to delete one SearchKeyword
     *   }
     * })
     * 
     */
    delete<T extends SearchKeywordDeleteArgs>(args: SelectSubset<T, SearchKeywordDeleteArgs<ExtArgs>>): Prisma__SearchKeywordClient<$Result.GetResult<Prisma.$SearchKeywordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SearchKeyword.
     * @param {SearchKeywordUpdateArgs} args - Arguments to update one SearchKeyword.
     * @example
     * // Update one SearchKeyword
     * const searchKeyword = await prisma.searchKeyword.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SearchKeywordUpdateArgs>(args: SelectSubset<T, SearchKeywordUpdateArgs<ExtArgs>>): Prisma__SearchKeywordClient<$Result.GetResult<Prisma.$SearchKeywordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SearchKeywords.
     * @param {SearchKeywordDeleteManyArgs} args - Arguments to filter SearchKeywords to delete.
     * @example
     * // Delete a few SearchKeywords
     * const { count } = await prisma.searchKeyword.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SearchKeywordDeleteManyArgs>(args?: SelectSubset<T, SearchKeywordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SearchKeywords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchKeywordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SearchKeywords
     * const searchKeyword = await prisma.searchKeyword.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SearchKeywordUpdateManyArgs>(args: SelectSubset<T, SearchKeywordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SearchKeywords and returns the data updated in the database.
     * @param {SearchKeywordUpdateManyAndReturnArgs} args - Arguments to update many SearchKeywords.
     * @example
     * // Update many SearchKeywords
     * const searchKeyword = await prisma.searchKeyword.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SearchKeywords and only return the `id`
     * const searchKeywordWithIdOnly = await prisma.searchKeyword.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SearchKeywordUpdateManyAndReturnArgs>(args: SelectSubset<T, SearchKeywordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchKeywordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SearchKeyword.
     * @param {SearchKeywordUpsertArgs} args - Arguments to update or create a SearchKeyword.
     * @example
     * // Update or create a SearchKeyword
     * const searchKeyword = await prisma.searchKeyword.upsert({
     *   create: {
     *     // ... data to create a SearchKeyword
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SearchKeyword we want to update
     *   }
     * })
     */
    upsert<T extends SearchKeywordUpsertArgs>(args: SelectSubset<T, SearchKeywordUpsertArgs<ExtArgs>>): Prisma__SearchKeywordClient<$Result.GetResult<Prisma.$SearchKeywordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SearchKeywords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchKeywordCountArgs} args - Arguments to filter SearchKeywords to count.
     * @example
     * // Count the number of SearchKeywords
     * const count = await prisma.searchKeyword.count({
     *   where: {
     *     // ... the filter for the SearchKeywords we want to count
     *   }
     * })
    **/
    count<T extends SearchKeywordCountArgs>(
      args?: Subset<T, SearchKeywordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SearchKeywordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SearchKeyword.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchKeywordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SearchKeywordAggregateArgs>(args: Subset<T, SearchKeywordAggregateArgs>): Prisma.PrismaPromise<GetSearchKeywordAggregateType<T>>

    /**
     * Group by SearchKeyword.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchKeywordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SearchKeywordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SearchKeywordGroupByArgs['orderBy'] }
        : { orderBy?: SearchKeywordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SearchKeywordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSearchKeywordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SearchKeyword model
   */
  readonly fields: SearchKeywordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SearchKeyword.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SearchKeywordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rankResults<T extends SearchKeyword$rankResultsArgs<ExtArgs> = {}>(args?: Subset<T, SearchKeyword$rankResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RankTrackingResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SearchKeyword model
   */
  interface SearchKeywordFieldRefs {
    readonly id: FieldRef<"SearchKeyword", 'String'>
    readonly keyword: FieldRef<"SearchKeyword", 'String'>
    readonly locationId: FieldRef<"SearchKeyword", 'String'>
    readonly latitude: FieldRef<"SearchKeyword", 'Float'>
    readonly longitude: FieldRef<"SearchKeyword", 'Float'>
    readonly createdAt: FieldRef<"SearchKeyword", 'DateTime'>
    readonly updatedAt: FieldRef<"SearchKeyword", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SearchKeyword findUnique
   */
  export type SearchKeywordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchKeyword
     */
    select?: SearchKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchKeyword
     */
    omit?: SearchKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchKeywordInclude<ExtArgs> | null
    /**
     * Filter, which SearchKeyword to fetch.
     */
    where: SearchKeywordWhereUniqueInput
  }

  /**
   * SearchKeyword findUniqueOrThrow
   */
  export type SearchKeywordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchKeyword
     */
    select?: SearchKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchKeyword
     */
    omit?: SearchKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchKeywordInclude<ExtArgs> | null
    /**
     * Filter, which SearchKeyword to fetch.
     */
    where: SearchKeywordWhereUniqueInput
  }

  /**
   * SearchKeyword findFirst
   */
  export type SearchKeywordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchKeyword
     */
    select?: SearchKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchKeyword
     */
    omit?: SearchKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchKeywordInclude<ExtArgs> | null
    /**
     * Filter, which SearchKeyword to fetch.
     */
    where?: SearchKeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchKeywords to fetch.
     */
    orderBy?: SearchKeywordOrderByWithRelationInput | SearchKeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchKeywords.
     */
    cursor?: SearchKeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchKeywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchKeywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchKeywords.
     */
    distinct?: SearchKeywordScalarFieldEnum | SearchKeywordScalarFieldEnum[]
  }

  /**
   * SearchKeyword findFirstOrThrow
   */
  export type SearchKeywordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchKeyword
     */
    select?: SearchKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchKeyword
     */
    omit?: SearchKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchKeywordInclude<ExtArgs> | null
    /**
     * Filter, which SearchKeyword to fetch.
     */
    where?: SearchKeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchKeywords to fetch.
     */
    orderBy?: SearchKeywordOrderByWithRelationInput | SearchKeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchKeywords.
     */
    cursor?: SearchKeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchKeywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchKeywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchKeywords.
     */
    distinct?: SearchKeywordScalarFieldEnum | SearchKeywordScalarFieldEnum[]
  }

  /**
   * SearchKeyword findMany
   */
  export type SearchKeywordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchKeyword
     */
    select?: SearchKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchKeyword
     */
    omit?: SearchKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchKeywordInclude<ExtArgs> | null
    /**
     * Filter, which SearchKeywords to fetch.
     */
    where?: SearchKeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchKeywords to fetch.
     */
    orderBy?: SearchKeywordOrderByWithRelationInput | SearchKeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SearchKeywords.
     */
    cursor?: SearchKeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchKeywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchKeywords.
     */
    skip?: number
    distinct?: SearchKeywordScalarFieldEnum | SearchKeywordScalarFieldEnum[]
  }

  /**
   * SearchKeyword create
   */
  export type SearchKeywordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchKeyword
     */
    select?: SearchKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchKeyword
     */
    omit?: SearchKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchKeywordInclude<ExtArgs> | null
    /**
     * The data needed to create a SearchKeyword.
     */
    data: XOR<SearchKeywordCreateInput, SearchKeywordUncheckedCreateInput>
  }

  /**
   * SearchKeyword createMany
   */
  export type SearchKeywordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SearchKeywords.
     */
    data: SearchKeywordCreateManyInput | SearchKeywordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SearchKeyword createManyAndReturn
   */
  export type SearchKeywordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchKeyword
     */
    select?: SearchKeywordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SearchKeyword
     */
    omit?: SearchKeywordOmit<ExtArgs> | null
    /**
     * The data used to create many SearchKeywords.
     */
    data: SearchKeywordCreateManyInput | SearchKeywordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchKeywordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SearchKeyword update
   */
  export type SearchKeywordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchKeyword
     */
    select?: SearchKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchKeyword
     */
    omit?: SearchKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchKeywordInclude<ExtArgs> | null
    /**
     * The data needed to update a SearchKeyword.
     */
    data: XOR<SearchKeywordUpdateInput, SearchKeywordUncheckedUpdateInput>
    /**
     * Choose, which SearchKeyword to update.
     */
    where: SearchKeywordWhereUniqueInput
  }

  /**
   * SearchKeyword updateMany
   */
  export type SearchKeywordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SearchKeywords.
     */
    data: XOR<SearchKeywordUpdateManyMutationInput, SearchKeywordUncheckedUpdateManyInput>
    /**
     * Filter which SearchKeywords to update
     */
    where?: SearchKeywordWhereInput
    /**
     * Limit how many SearchKeywords to update.
     */
    limit?: number
  }

  /**
   * SearchKeyword updateManyAndReturn
   */
  export type SearchKeywordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchKeyword
     */
    select?: SearchKeywordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SearchKeyword
     */
    omit?: SearchKeywordOmit<ExtArgs> | null
    /**
     * The data used to update SearchKeywords.
     */
    data: XOR<SearchKeywordUpdateManyMutationInput, SearchKeywordUncheckedUpdateManyInput>
    /**
     * Filter which SearchKeywords to update
     */
    where?: SearchKeywordWhereInput
    /**
     * Limit how many SearchKeywords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchKeywordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SearchKeyword upsert
   */
  export type SearchKeywordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchKeyword
     */
    select?: SearchKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchKeyword
     */
    omit?: SearchKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchKeywordInclude<ExtArgs> | null
    /**
     * The filter to search for the SearchKeyword to update in case it exists.
     */
    where: SearchKeywordWhereUniqueInput
    /**
     * In case the SearchKeyword found by the `where` argument doesn't exist, create a new SearchKeyword with this data.
     */
    create: XOR<SearchKeywordCreateInput, SearchKeywordUncheckedCreateInput>
    /**
     * In case the SearchKeyword was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SearchKeywordUpdateInput, SearchKeywordUncheckedUpdateInput>
  }

  /**
   * SearchKeyword delete
   */
  export type SearchKeywordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchKeyword
     */
    select?: SearchKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchKeyword
     */
    omit?: SearchKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchKeywordInclude<ExtArgs> | null
    /**
     * Filter which SearchKeyword to delete.
     */
    where: SearchKeywordWhereUniqueInput
  }

  /**
   * SearchKeyword deleteMany
   */
  export type SearchKeywordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchKeywords to delete
     */
    where?: SearchKeywordWhereInput
    /**
     * Limit how many SearchKeywords to delete.
     */
    limit?: number
  }

  /**
   * SearchKeyword.rankResults
   */
  export type SearchKeyword$rankResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankTrackingResult
     */
    select?: RankTrackingResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RankTrackingResult
     */
    omit?: RankTrackingResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RankTrackingResultInclude<ExtArgs> | null
    where?: RankTrackingResultWhereInput
    orderBy?: RankTrackingResultOrderByWithRelationInput | RankTrackingResultOrderByWithRelationInput[]
    cursor?: RankTrackingResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RankTrackingResultScalarFieldEnum | RankTrackingResultScalarFieldEnum[]
  }

  /**
   * SearchKeyword without action
   */
  export type SearchKeywordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchKeyword
     */
    select?: SearchKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchKeyword
     */
    omit?: SearchKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchKeywordInclude<ExtArgs> | null
  }


  /**
   * Model RankTrackingResult
   */

  export type AggregateRankTrackingResult = {
    _count: RankTrackingResultCountAggregateOutputType | null
    _avg: RankTrackingResultAvgAggregateOutputType | null
    _sum: RankTrackingResultSumAggregateOutputType | null
    _min: RankTrackingResultMinAggregateOutputType | null
    _max: RankTrackingResultMaxAggregateOutputType | null
  }

  export type RankTrackingResultAvgAggregateOutputType = {
    rankPosition: number | null
  }

  export type RankTrackingResultSumAggregateOutputType = {
    rankPosition: number | null
  }

  export type RankTrackingResultMinAggregateOutputType = {
    id: string | null
    keywordId: string | null
    rankPosition: number | null
    searchDate: Date | null
    searchUrl: string | null
    businessUrl: string | null
    businessName: string | null
    htmlSnapshot: string | null
    createdAt: Date | null
  }

  export type RankTrackingResultMaxAggregateOutputType = {
    id: string | null
    keywordId: string | null
    rankPosition: number | null
    searchDate: Date | null
    searchUrl: string | null
    businessUrl: string | null
    businessName: string | null
    htmlSnapshot: string | null
    createdAt: Date | null
  }

  export type RankTrackingResultCountAggregateOutputType = {
    id: number
    keywordId: number
    rankPosition: number
    searchDate: number
    searchUrl: number
    businessUrl: number
    businessName: number
    htmlSnapshot: number
    createdAt: number
    _all: number
  }


  export type RankTrackingResultAvgAggregateInputType = {
    rankPosition?: true
  }

  export type RankTrackingResultSumAggregateInputType = {
    rankPosition?: true
  }

  export type RankTrackingResultMinAggregateInputType = {
    id?: true
    keywordId?: true
    rankPosition?: true
    searchDate?: true
    searchUrl?: true
    businessUrl?: true
    businessName?: true
    htmlSnapshot?: true
    createdAt?: true
  }

  export type RankTrackingResultMaxAggregateInputType = {
    id?: true
    keywordId?: true
    rankPosition?: true
    searchDate?: true
    searchUrl?: true
    businessUrl?: true
    businessName?: true
    htmlSnapshot?: true
    createdAt?: true
  }

  export type RankTrackingResultCountAggregateInputType = {
    id?: true
    keywordId?: true
    rankPosition?: true
    searchDate?: true
    searchUrl?: true
    businessUrl?: true
    businessName?: true
    htmlSnapshot?: true
    createdAt?: true
    _all?: true
  }

  export type RankTrackingResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RankTrackingResult to aggregate.
     */
    where?: RankTrackingResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RankTrackingResults to fetch.
     */
    orderBy?: RankTrackingResultOrderByWithRelationInput | RankTrackingResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RankTrackingResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RankTrackingResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RankTrackingResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RankTrackingResults
    **/
    _count?: true | RankTrackingResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RankTrackingResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RankTrackingResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RankTrackingResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RankTrackingResultMaxAggregateInputType
  }

  export type GetRankTrackingResultAggregateType<T extends RankTrackingResultAggregateArgs> = {
        [P in keyof T & keyof AggregateRankTrackingResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRankTrackingResult[P]>
      : GetScalarType<T[P], AggregateRankTrackingResult[P]>
  }




  export type RankTrackingResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RankTrackingResultWhereInput
    orderBy?: RankTrackingResultOrderByWithAggregationInput | RankTrackingResultOrderByWithAggregationInput[]
    by: RankTrackingResultScalarFieldEnum[] | RankTrackingResultScalarFieldEnum
    having?: RankTrackingResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RankTrackingResultCountAggregateInputType | true
    _avg?: RankTrackingResultAvgAggregateInputType
    _sum?: RankTrackingResultSumAggregateInputType
    _min?: RankTrackingResultMinAggregateInputType
    _max?: RankTrackingResultMaxAggregateInputType
  }

  export type RankTrackingResultGroupByOutputType = {
    id: string
    keywordId: string
    rankPosition: number | null
    searchDate: Date
    searchUrl: string | null
    businessUrl: string | null
    businessName: string | null
    htmlSnapshot: string | null
    createdAt: Date
    _count: RankTrackingResultCountAggregateOutputType | null
    _avg: RankTrackingResultAvgAggregateOutputType | null
    _sum: RankTrackingResultSumAggregateOutputType | null
    _min: RankTrackingResultMinAggregateOutputType | null
    _max: RankTrackingResultMaxAggregateOutputType | null
  }

  type GetRankTrackingResultGroupByPayload<T extends RankTrackingResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RankTrackingResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RankTrackingResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RankTrackingResultGroupByOutputType[P]>
            : GetScalarType<T[P], RankTrackingResultGroupByOutputType[P]>
        }
      >
    >


  export type RankTrackingResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keywordId?: boolean
    rankPosition?: boolean
    searchDate?: boolean
    searchUrl?: boolean
    businessUrl?: boolean
    businessName?: boolean
    htmlSnapshot?: boolean
    createdAt?: boolean
    keyword?: boolean | SearchKeywordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rankTrackingResult"]>

  export type RankTrackingResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keywordId?: boolean
    rankPosition?: boolean
    searchDate?: boolean
    searchUrl?: boolean
    businessUrl?: boolean
    businessName?: boolean
    htmlSnapshot?: boolean
    createdAt?: boolean
    keyword?: boolean | SearchKeywordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rankTrackingResult"]>

  export type RankTrackingResultSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keywordId?: boolean
    rankPosition?: boolean
    searchDate?: boolean
    searchUrl?: boolean
    businessUrl?: boolean
    businessName?: boolean
    htmlSnapshot?: boolean
    createdAt?: boolean
    keyword?: boolean | SearchKeywordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rankTrackingResult"]>

  export type RankTrackingResultSelectScalar = {
    id?: boolean
    keywordId?: boolean
    rankPosition?: boolean
    searchDate?: boolean
    searchUrl?: boolean
    businessUrl?: boolean
    businessName?: boolean
    htmlSnapshot?: boolean
    createdAt?: boolean
  }

  export type RankTrackingResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "keywordId" | "rankPosition" | "searchDate" | "searchUrl" | "businessUrl" | "businessName" | "htmlSnapshot" | "createdAt", ExtArgs["result"]["rankTrackingResult"]>
  export type RankTrackingResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    keyword?: boolean | SearchKeywordDefaultArgs<ExtArgs>
  }
  export type RankTrackingResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    keyword?: boolean | SearchKeywordDefaultArgs<ExtArgs>
  }
  export type RankTrackingResultIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    keyword?: boolean | SearchKeywordDefaultArgs<ExtArgs>
  }

  export type $RankTrackingResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RankTrackingResult"
    objects: {
      keyword: Prisma.$SearchKeywordPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      keywordId: string
      rankPosition: number | null
      searchDate: Date
      searchUrl: string | null
      businessUrl: string | null
      businessName: string | null
      htmlSnapshot: string | null
      createdAt: Date
    }, ExtArgs["result"]["rankTrackingResult"]>
    composites: {}
  }

  type RankTrackingResultGetPayload<S extends boolean | null | undefined | RankTrackingResultDefaultArgs> = $Result.GetResult<Prisma.$RankTrackingResultPayload, S>

  type RankTrackingResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RankTrackingResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RankTrackingResultCountAggregateInputType | true
    }

  export interface RankTrackingResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RankTrackingResult'], meta: { name: 'RankTrackingResult' } }
    /**
     * Find zero or one RankTrackingResult that matches the filter.
     * @param {RankTrackingResultFindUniqueArgs} args - Arguments to find a RankTrackingResult
     * @example
     * // Get one RankTrackingResult
     * const rankTrackingResult = await prisma.rankTrackingResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RankTrackingResultFindUniqueArgs>(args: SelectSubset<T, RankTrackingResultFindUniqueArgs<ExtArgs>>): Prisma__RankTrackingResultClient<$Result.GetResult<Prisma.$RankTrackingResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RankTrackingResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RankTrackingResultFindUniqueOrThrowArgs} args - Arguments to find a RankTrackingResult
     * @example
     * // Get one RankTrackingResult
     * const rankTrackingResult = await prisma.rankTrackingResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RankTrackingResultFindUniqueOrThrowArgs>(args: SelectSubset<T, RankTrackingResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RankTrackingResultClient<$Result.GetResult<Prisma.$RankTrackingResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RankTrackingResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankTrackingResultFindFirstArgs} args - Arguments to find a RankTrackingResult
     * @example
     * // Get one RankTrackingResult
     * const rankTrackingResult = await prisma.rankTrackingResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RankTrackingResultFindFirstArgs>(args?: SelectSubset<T, RankTrackingResultFindFirstArgs<ExtArgs>>): Prisma__RankTrackingResultClient<$Result.GetResult<Prisma.$RankTrackingResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RankTrackingResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankTrackingResultFindFirstOrThrowArgs} args - Arguments to find a RankTrackingResult
     * @example
     * // Get one RankTrackingResult
     * const rankTrackingResult = await prisma.rankTrackingResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RankTrackingResultFindFirstOrThrowArgs>(args?: SelectSubset<T, RankTrackingResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__RankTrackingResultClient<$Result.GetResult<Prisma.$RankTrackingResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RankTrackingResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankTrackingResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RankTrackingResults
     * const rankTrackingResults = await prisma.rankTrackingResult.findMany()
     * 
     * // Get first 10 RankTrackingResults
     * const rankTrackingResults = await prisma.rankTrackingResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rankTrackingResultWithIdOnly = await prisma.rankTrackingResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RankTrackingResultFindManyArgs>(args?: SelectSubset<T, RankTrackingResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RankTrackingResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RankTrackingResult.
     * @param {RankTrackingResultCreateArgs} args - Arguments to create a RankTrackingResult.
     * @example
     * // Create one RankTrackingResult
     * const RankTrackingResult = await prisma.rankTrackingResult.create({
     *   data: {
     *     // ... data to create a RankTrackingResult
     *   }
     * })
     * 
     */
    create<T extends RankTrackingResultCreateArgs>(args: SelectSubset<T, RankTrackingResultCreateArgs<ExtArgs>>): Prisma__RankTrackingResultClient<$Result.GetResult<Prisma.$RankTrackingResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RankTrackingResults.
     * @param {RankTrackingResultCreateManyArgs} args - Arguments to create many RankTrackingResults.
     * @example
     * // Create many RankTrackingResults
     * const rankTrackingResult = await prisma.rankTrackingResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RankTrackingResultCreateManyArgs>(args?: SelectSubset<T, RankTrackingResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RankTrackingResults and returns the data saved in the database.
     * @param {RankTrackingResultCreateManyAndReturnArgs} args - Arguments to create many RankTrackingResults.
     * @example
     * // Create many RankTrackingResults
     * const rankTrackingResult = await prisma.rankTrackingResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RankTrackingResults and only return the `id`
     * const rankTrackingResultWithIdOnly = await prisma.rankTrackingResult.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RankTrackingResultCreateManyAndReturnArgs>(args?: SelectSubset<T, RankTrackingResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RankTrackingResultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RankTrackingResult.
     * @param {RankTrackingResultDeleteArgs} args - Arguments to delete one RankTrackingResult.
     * @example
     * // Delete one RankTrackingResult
     * const RankTrackingResult = await prisma.rankTrackingResult.delete({
     *   where: {
     *     // ... filter to delete one RankTrackingResult
     *   }
     * })
     * 
     */
    delete<T extends RankTrackingResultDeleteArgs>(args: SelectSubset<T, RankTrackingResultDeleteArgs<ExtArgs>>): Prisma__RankTrackingResultClient<$Result.GetResult<Prisma.$RankTrackingResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RankTrackingResult.
     * @param {RankTrackingResultUpdateArgs} args - Arguments to update one RankTrackingResult.
     * @example
     * // Update one RankTrackingResult
     * const rankTrackingResult = await prisma.rankTrackingResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RankTrackingResultUpdateArgs>(args: SelectSubset<T, RankTrackingResultUpdateArgs<ExtArgs>>): Prisma__RankTrackingResultClient<$Result.GetResult<Prisma.$RankTrackingResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RankTrackingResults.
     * @param {RankTrackingResultDeleteManyArgs} args - Arguments to filter RankTrackingResults to delete.
     * @example
     * // Delete a few RankTrackingResults
     * const { count } = await prisma.rankTrackingResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RankTrackingResultDeleteManyArgs>(args?: SelectSubset<T, RankTrackingResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RankTrackingResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankTrackingResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RankTrackingResults
     * const rankTrackingResult = await prisma.rankTrackingResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RankTrackingResultUpdateManyArgs>(args: SelectSubset<T, RankTrackingResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RankTrackingResults and returns the data updated in the database.
     * @param {RankTrackingResultUpdateManyAndReturnArgs} args - Arguments to update many RankTrackingResults.
     * @example
     * // Update many RankTrackingResults
     * const rankTrackingResult = await prisma.rankTrackingResult.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RankTrackingResults and only return the `id`
     * const rankTrackingResultWithIdOnly = await prisma.rankTrackingResult.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RankTrackingResultUpdateManyAndReturnArgs>(args: SelectSubset<T, RankTrackingResultUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RankTrackingResultPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RankTrackingResult.
     * @param {RankTrackingResultUpsertArgs} args - Arguments to update or create a RankTrackingResult.
     * @example
     * // Update or create a RankTrackingResult
     * const rankTrackingResult = await prisma.rankTrackingResult.upsert({
     *   create: {
     *     // ... data to create a RankTrackingResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RankTrackingResult we want to update
     *   }
     * })
     */
    upsert<T extends RankTrackingResultUpsertArgs>(args: SelectSubset<T, RankTrackingResultUpsertArgs<ExtArgs>>): Prisma__RankTrackingResultClient<$Result.GetResult<Prisma.$RankTrackingResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RankTrackingResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankTrackingResultCountArgs} args - Arguments to filter RankTrackingResults to count.
     * @example
     * // Count the number of RankTrackingResults
     * const count = await prisma.rankTrackingResult.count({
     *   where: {
     *     // ... the filter for the RankTrackingResults we want to count
     *   }
     * })
    **/
    count<T extends RankTrackingResultCountArgs>(
      args?: Subset<T, RankTrackingResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RankTrackingResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RankTrackingResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankTrackingResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RankTrackingResultAggregateArgs>(args: Subset<T, RankTrackingResultAggregateArgs>): Prisma.PrismaPromise<GetRankTrackingResultAggregateType<T>>

    /**
     * Group by RankTrackingResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankTrackingResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RankTrackingResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RankTrackingResultGroupByArgs['orderBy'] }
        : { orderBy?: RankTrackingResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RankTrackingResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRankTrackingResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RankTrackingResult model
   */
  readonly fields: RankTrackingResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RankTrackingResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RankTrackingResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    keyword<T extends SearchKeywordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SearchKeywordDefaultArgs<ExtArgs>>): Prisma__SearchKeywordClient<$Result.GetResult<Prisma.$SearchKeywordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RankTrackingResult model
   */
  interface RankTrackingResultFieldRefs {
    readonly id: FieldRef<"RankTrackingResult", 'String'>
    readonly keywordId: FieldRef<"RankTrackingResult", 'String'>
    readonly rankPosition: FieldRef<"RankTrackingResult", 'Int'>
    readonly searchDate: FieldRef<"RankTrackingResult", 'DateTime'>
    readonly searchUrl: FieldRef<"RankTrackingResult", 'String'>
    readonly businessUrl: FieldRef<"RankTrackingResult", 'String'>
    readonly businessName: FieldRef<"RankTrackingResult", 'String'>
    readonly htmlSnapshot: FieldRef<"RankTrackingResult", 'String'>
    readonly createdAt: FieldRef<"RankTrackingResult", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RankTrackingResult findUnique
   */
  export type RankTrackingResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankTrackingResult
     */
    select?: RankTrackingResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RankTrackingResult
     */
    omit?: RankTrackingResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RankTrackingResultInclude<ExtArgs> | null
    /**
     * Filter, which RankTrackingResult to fetch.
     */
    where: RankTrackingResultWhereUniqueInput
  }

  /**
   * RankTrackingResult findUniqueOrThrow
   */
  export type RankTrackingResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankTrackingResult
     */
    select?: RankTrackingResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RankTrackingResult
     */
    omit?: RankTrackingResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RankTrackingResultInclude<ExtArgs> | null
    /**
     * Filter, which RankTrackingResult to fetch.
     */
    where: RankTrackingResultWhereUniqueInput
  }

  /**
   * RankTrackingResult findFirst
   */
  export type RankTrackingResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankTrackingResult
     */
    select?: RankTrackingResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RankTrackingResult
     */
    omit?: RankTrackingResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RankTrackingResultInclude<ExtArgs> | null
    /**
     * Filter, which RankTrackingResult to fetch.
     */
    where?: RankTrackingResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RankTrackingResults to fetch.
     */
    orderBy?: RankTrackingResultOrderByWithRelationInput | RankTrackingResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RankTrackingResults.
     */
    cursor?: RankTrackingResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RankTrackingResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RankTrackingResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RankTrackingResults.
     */
    distinct?: RankTrackingResultScalarFieldEnum | RankTrackingResultScalarFieldEnum[]
  }

  /**
   * RankTrackingResult findFirstOrThrow
   */
  export type RankTrackingResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankTrackingResult
     */
    select?: RankTrackingResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RankTrackingResult
     */
    omit?: RankTrackingResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RankTrackingResultInclude<ExtArgs> | null
    /**
     * Filter, which RankTrackingResult to fetch.
     */
    where?: RankTrackingResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RankTrackingResults to fetch.
     */
    orderBy?: RankTrackingResultOrderByWithRelationInput | RankTrackingResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RankTrackingResults.
     */
    cursor?: RankTrackingResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RankTrackingResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RankTrackingResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RankTrackingResults.
     */
    distinct?: RankTrackingResultScalarFieldEnum | RankTrackingResultScalarFieldEnum[]
  }

  /**
   * RankTrackingResult findMany
   */
  export type RankTrackingResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankTrackingResult
     */
    select?: RankTrackingResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RankTrackingResult
     */
    omit?: RankTrackingResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RankTrackingResultInclude<ExtArgs> | null
    /**
     * Filter, which RankTrackingResults to fetch.
     */
    where?: RankTrackingResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RankTrackingResults to fetch.
     */
    orderBy?: RankTrackingResultOrderByWithRelationInput | RankTrackingResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RankTrackingResults.
     */
    cursor?: RankTrackingResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RankTrackingResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RankTrackingResults.
     */
    skip?: number
    distinct?: RankTrackingResultScalarFieldEnum | RankTrackingResultScalarFieldEnum[]
  }

  /**
   * RankTrackingResult create
   */
  export type RankTrackingResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankTrackingResult
     */
    select?: RankTrackingResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RankTrackingResult
     */
    omit?: RankTrackingResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RankTrackingResultInclude<ExtArgs> | null
    /**
     * The data needed to create a RankTrackingResult.
     */
    data: XOR<RankTrackingResultCreateInput, RankTrackingResultUncheckedCreateInput>
  }

  /**
   * RankTrackingResult createMany
   */
  export type RankTrackingResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RankTrackingResults.
     */
    data: RankTrackingResultCreateManyInput | RankTrackingResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RankTrackingResult createManyAndReturn
   */
  export type RankTrackingResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankTrackingResult
     */
    select?: RankTrackingResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RankTrackingResult
     */
    omit?: RankTrackingResultOmit<ExtArgs> | null
    /**
     * The data used to create many RankTrackingResults.
     */
    data: RankTrackingResultCreateManyInput | RankTrackingResultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RankTrackingResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RankTrackingResult update
   */
  export type RankTrackingResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankTrackingResult
     */
    select?: RankTrackingResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RankTrackingResult
     */
    omit?: RankTrackingResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RankTrackingResultInclude<ExtArgs> | null
    /**
     * The data needed to update a RankTrackingResult.
     */
    data: XOR<RankTrackingResultUpdateInput, RankTrackingResultUncheckedUpdateInput>
    /**
     * Choose, which RankTrackingResult to update.
     */
    where: RankTrackingResultWhereUniqueInput
  }

  /**
   * RankTrackingResult updateMany
   */
  export type RankTrackingResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RankTrackingResults.
     */
    data: XOR<RankTrackingResultUpdateManyMutationInput, RankTrackingResultUncheckedUpdateManyInput>
    /**
     * Filter which RankTrackingResults to update
     */
    where?: RankTrackingResultWhereInput
    /**
     * Limit how many RankTrackingResults to update.
     */
    limit?: number
  }

  /**
   * RankTrackingResult updateManyAndReturn
   */
  export type RankTrackingResultUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankTrackingResult
     */
    select?: RankTrackingResultSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RankTrackingResult
     */
    omit?: RankTrackingResultOmit<ExtArgs> | null
    /**
     * The data used to update RankTrackingResults.
     */
    data: XOR<RankTrackingResultUpdateManyMutationInput, RankTrackingResultUncheckedUpdateManyInput>
    /**
     * Filter which RankTrackingResults to update
     */
    where?: RankTrackingResultWhereInput
    /**
     * Limit how many RankTrackingResults to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RankTrackingResultIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RankTrackingResult upsert
   */
  export type RankTrackingResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankTrackingResult
     */
    select?: RankTrackingResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RankTrackingResult
     */
    omit?: RankTrackingResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RankTrackingResultInclude<ExtArgs> | null
    /**
     * The filter to search for the RankTrackingResult to update in case it exists.
     */
    where: RankTrackingResultWhereUniqueInput
    /**
     * In case the RankTrackingResult found by the `where` argument doesn't exist, create a new RankTrackingResult with this data.
     */
    create: XOR<RankTrackingResultCreateInput, RankTrackingResultUncheckedCreateInput>
    /**
     * In case the RankTrackingResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RankTrackingResultUpdateInput, RankTrackingResultUncheckedUpdateInput>
  }

  /**
   * RankTrackingResult delete
   */
  export type RankTrackingResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankTrackingResult
     */
    select?: RankTrackingResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RankTrackingResult
     */
    omit?: RankTrackingResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RankTrackingResultInclude<ExtArgs> | null
    /**
     * Filter which RankTrackingResult to delete.
     */
    where: RankTrackingResultWhereUniqueInput
  }

  /**
   * RankTrackingResult deleteMany
   */
  export type RankTrackingResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RankTrackingResults to delete
     */
    where?: RankTrackingResultWhereInput
    /**
     * Limit how many RankTrackingResults to delete.
     */
    limit?: number
  }

  /**
   * RankTrackingResult without action
   */
  export type RankTrackingResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankTrackingResult
     */
    select?: RankTrackingResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RankTrackingResult
     */
    omit?: RankTrackingResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RankTrackingResultInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    emailVerificationToken: 'emailVerificationToken',
    password: 'password',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    googleAccessToken: 'googleAccessToken',
    googleRefreshToken: 'googleRefreshToken',
    googleTokenExpiresAt: 'googleTokenExpiresAt',
    subscriptionId: 'subscriptionId',
    subscriptionStatus: 'subscriptionStatus',
    subscriptionPlan: 'subscriptionPlan',
    trialStartedAt: 'trialStartedAt',
    trialEndsAt: 'trialEndsAt',
    currentPeriodStart: 'currentPeriodStart',
    currentPeriodEnd: 'currentPeriodEnd',
    razorpayCustomerId: 'razorpayCustomerId',
    razorpayPaymentId: 'razorpayPaymentId',
    razorpayOrderId: 'razorpayOrderId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    logo: 'logo',
    ownerId: 'ownerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    organizationId: 'organizationId',
    gmbLocationId: 'gmbLocationId',
    gmbLocationName: 'gmbLocationName',
    address: 'address',
    phone: 'phone',
    websiteUrl: 'websiteUrl',
    latitude: 'latitude',
    longitude: 'longitude',
    timezone: 'timezone',
    isVerified: 'isVerified',
    lastSyncedAt: 'lastSyncedAt',
    lastFetchedTimestamp: 'lastFetchedTimestamp',
    autoReplyEnabled: 'autoReplyEnabled',
    autoPostEnabled: 'autoPostEnabled',
    replyTonePreference: 'replyTonePreference',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    tokenExpiresAt: 'tokenExpiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    logoUrl: 'logoUrl',
    gmbAccountId: 'gmbAccountId'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    locationId: 'locationId',
    userId: 'userId',
    title: 'title',
    content: 'content',
    type: 'type',
    mediaUrls: 'mediaUrls',
    scheduledAt: 'scheduledAt',
    publishedAt: 'publishedAt',
    status: 'status',
    eventStart: 'eventStart',
    eventEnd: 'eventEnd',
    offerStart: 'offerStart',
    offerEnd: 'offerEnd',
    couponCode: 'couponCode',
    callToAction: 'callToAction',
    recurType: 'recurType',
    recurEndsAt: 'recurEndsAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    locationId: 'locationId',
    reviewId: 'reviewId',
    authorName: 'authorName',
    authorPhoto: 'authorPhoto',
    rating: 'rating',
    comment: 'comment',
    createTime: 'createTime',
    updateTime: 'updateTime',
    status: 'status',
    isProcessed: 'isProcessed',
    sentiment: 'sentiment',
    language: 'language',
    isReplyNeeded: 'isReplyNeeded',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const ReviewReplyScalarFieldEnum: {
    id: 'id',
    reviewId: 'reviewId',
    userId: 'userId',
    content: 'content',
    source: 'source',
    tone: 'tone',
    isPublished: 'isPublished',
    publishedAt: 'publishedAt',
    aiTemplateId: 'aiTemplateId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReviewReplyScalarFieldEnum = (typeof ReviewReplyScalarFieldEnum)[keyof typeof ReviewReplyScalarFieldEnum]


  export const AIReplyTemplateScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    name: 'name',
    content: 'content',
    tone: 'tone',
    sentiment: 'sentiment',
    isDefault: 'isDefault',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AIReplyTemplateScalarFieldEnum = (typeof AIReplyTemplateScalarFieldEnum)[keyof typeof AIReplyTemplateScalarFieldEnum]


  export const InsightScalarFieldEnum: {
    id: 'id',
    locationId: 'locationId',
    date: 'date',
    type: 'type',
    value: 'value',
    createdAt: 'createdAt'
  };

  export type InsightScalarFieldEnum = (typeof InsightScalarFieldEnum)[keyof typeof InsightScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    locationId: 'locationId',
    name: 'name',
    startDate: 'startDate',
    endDate: 'endDate',
    reportType: 'reportType',
    fileUrl: 'fileUrl',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const ReportJobScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    name: 'name',
    locations: 'locations',
    frequency: 'frequency',
    emailRecipients: 'emailRecipients',
    isActive: 'isActive',
    lastRunAt: 'lastRunAt',
    nextRunAt: 'nextRunAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReportJobScalarFieldEnum = (typeof ReportJobScalarFieldEnum)[keyof typeof ReportJobScalarFieldEnum]


  export const SearchKeywordScalarFieldEnum: {
    id: 'id',
    keyword: 'keyword',
    locationId: 'locationId',
    latitude: 'latitude',
    longitude: 'longitude',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SearchKeywordScalarFieldEnum = (typeof SearchKeywordScalarFieldEnum)[keyof typeof SearchKeywordScalarFieldEnum]


  export const RankTrackingResultScalarFieldEnum: {
    id: 'id',
    keywordId: 'keywordId',
    rankPosition: 'rankPosition',
    searchDate: 'searchDate',
    searchUrl: 'searchUrl',
    businessUrl: 'businessUrl',
    businessName: 'businessName',
    htmlSnapshot: 'htmlSnapshot',
    createdAt: 'createdAt'
  };

  export type RankTrackingResultScalarFieldEnum = (typeof RankTrackingResultScalarFieldEnum)[keyof typeof RankTrackingResultScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    


  /**
   * Reference to a field of type 'SubscriptionPlan'
   */
  export type EnumSubscriptionPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionPlan'>
    


  /**
   * Reference to a field of type 'SubscriptionPlan[]'
   */
  export type ListEnumSubscriptionPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionPlan[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ReplyTone'
   */
  export type EnumReplyToneFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReplyTone'>
    


  /**
   * Reference to a field of type 'ReplyTone[]'
   */
  export type ListEnumReplyToneFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReplyTone[]'>
    


  /**
   * Reference to a field of type 'PostType'
   */
  export type EnumPostTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostType'>
    


  /**
   * Reference to a field of type 'PostType[]'
   */
  export type ListEnumPostTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostType[]'>
    


  /**
   * Reference to a field of type 'PostStatus'
   */
  export type EnumPostStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostStatus'>
    


  /**
   * Reference to a field of type 'PostStatus[]'
   */
  export type ListEnumPostStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostStatus[]'>
    


  /**
   * Reference to a field of type 'RecurType'
   */
  export type EnumRecurTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecurType'>
    


  /**
   * Reference to a field of type 'RecurType[]'
   */
  export type ListEnumRecurTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecurType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'ReviewStatus'
   */
  export type EnumReviewStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewStatus'>
    


  /**
   * Reference to a field of type 'ReviewStatus[]'
   */
  export type ListEnumReviewStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewStatus[]'>
    


  /**
   * Reference to a field of type 'SentimentType'
   */
  export type EnumSentimentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SentimentType'>
    


  /**
   * Reference to a field of type 'SentimentType[]'
   */
  export type ListEnumSentimentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SentimentType[]'>
    


  /**
   * Reference to a field of type 'ReplySource'
   */
  export type EnumReplySourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReplySource'>
    


  /**
   * Reference to a field of type 'ReplySource[]'
   */
  export type ListEnumReplySourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReplySource[]'>
    


  /**
   * Reference to a field of type 'InsightType'
   */
  export type EnumInsightTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InsightType'>
    


  /**
   * Reference to a field of type 'InsightType[]'
   */
  export type ListEnumInsightTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InsightType[]'>
    


  /**
   * Reference to a field of type 'ReportType'
   */
  export type EnumReportTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportType'>
    


  /**
   * Reference to a field of type 'ReportType[]'
   */
  export type ListEnumReportTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportType[]'>
    


  /**
   * Reference to a field of type 'ReportStatus'
   */
  export type EnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus'>
    


  /**
   * Reference to a field of type 'ReportStatus[]'
   */
  export type ListEnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus[]'>
    


  /**
   * Reference to a field of type 'ReportFrequency'
   */
  export type EnumReportFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportFrequency'>
    


  /**
   * Reference to a field of type 'ReportFrequency[]'
   */
  export type ListEnumReportFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportFrequency[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    emailVerificationToken?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    googleAccessToken?: StringNullableFilter<"User"> | string | null
    googleRefreshToken?: StringNullableFilter<"User"> | string | null
    googleTokenExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    subscriptionId?: StringNullableFilter<"User"> | string | null
    subscriptionStatus?: EnumSubscriptionStatusNullableFilter<"User"> | $Enums.SubscriptionStatus | null
    subscriptionPlan?: EnumSubscriptionPlanNullableFilter<"User"> | $Enums.SubscriptionPlan | null
    trialStartedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    trialEndsAt?: DateTimeNullableFilter<"User"> | Date | string | null
    currentPeriodStart?: DateTimeNullableFilter<"User"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"User"> | Date | string | null
    razorpayCustomerId?: StringNullableFilter<"User"> | string | null
    razorpayPaymentId?: StringNullableFilter<"User"> | string | null
    razorpayOrderId?: StringNullableFilter<"User"> | string | null
    ownedOrganizations?: OrganizationListRelationFilter
    posts?: PostListRelationFilter
    reviewReplies?: ReviewReplyListRelationFilter
    sessions?: SessionListRelationFilter
    locations?: LocationListRelationFilter
    organizations?: OrganizationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    emailVerificationToken?: SortOrderInput | SortOrder
    password?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    googleAccessToken?: SortOrderInput | SortOrder
    googleRefreshToken?: SortOrderInput | SortOrder
    googleTokenExpiresAt?: SortOrderInput | SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    subscriptionStatus?: SortOrderInput | SortOrder
    subscriptionPlan?: SortOrderInput | SortOrder
    trialStartedAt?: SortOrderInput | SortOrder
    trialEndsAt?: SortOrderInput | SortOrder
    currentPeriodStart?: SortOrderInput | SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    razorpayCustomerId?: SortOrderInput | SortOrder
    razorpayPaymentId?: SortOrderInput | SortOrder
    razorpayOrderId?: SortOrderInput | SortOrder
    ownedOrganizations?: OrganizationOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    reviewReplies?: ReviewReplyOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    locations?: LocationOrderByRelationAggregateInput
    organizations?: OrganizationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    emailVerificationToken?: string
    subscriptionId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    password?: StringFilter<"User"> | string
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    googleAccessToken?: StringNullableFilter<"User"> | string | null
    googleRefreshToken?: StringNullableFilter<"User"> | string | null
    googleTokenExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    subscriptionStatus?: EnumSubscriptionStatusNullableFilter<"User"> | $Enums.SubscriptionStatus | null
    subscriptionPlan?: EnumSubscriptionPlanNullableFilter<"User"> | $Enums.SubscriptionPlan | null
    trialStartedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    trialEndsAt?: DateTimeNullableFilter<"User"> | Date | string | null
    currentPeriodStart?: DateTimeNullableFilter<"User"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"User"> | Date | string | null
    razorpayCustomerId?: StringNullableFilter<"User"> | string | null
    razorpayPaymentId?: StringNullableFilter<"User"> | string | null
    razorpayOrderId?: StringNullableFilter<"User"> | string | null
    ownedOrganizations?: OrganizationListRelationFilter
    posts?: PostListRelationFilter
    reviewReplies?: ReviewReplyListRelationFilter
    sessions?: SessionListRelationFilter
    locations?: LocationListRelationFilter
    organizations?: OrganizationListRelationFilter
  }, "id" | "email" | "emailVerificationToken" | "subscriptionId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    emailVerificationToken?: SortOrderInput | SortOrder
    password?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    googleAccessToken?: SortOrderInput | SortOrder
    googleRefreshToken?: SortOrderInput | SortOrder
    googleTokenExpiresAt?: SortOrderInput | SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    subscriptionStatus?: SortOrderInput | SortOrder
    subscriptionPlan?: SortOrderInput | SortOrder
    trialStartedAt?: SortOrderInput | SortOrder
    trialEndsAt?: SortOrderInput | SortOrder
    currentPeriodStart?: SortOrderInput | SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    razorpayCustomerId?: SortOrderInput | SortOrder
    razorpayPaymentId?: SortOrderInput | SortOrder
    razorpayOrderId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    emailVerificationToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringWithAggregatesFilter<"User"> | string
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    googleAccessToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    googleRefreshToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    googleTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    subscriptionId?: StringNullableWithAggregatesFilter<"User"> | string | null
    subscriptionStatus?: EnumSubscriptionStatusNullableWithAggregatesFilter<"User"> | $Enums.SubscriptionStatus | null
    subscriptionPlan?: EnumSubscriptionPlanNullableWithAggregatesFilter<"User"> | $Enums.SubscriptionPlan | null
    trialStartedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    trialEndsAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    currentPeriodStart?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    razorpayCustomerId?: StringNullableWithAggregatesFilter<"User"> | string | null
    razorpayPaymentId?: StringNullableWithAggregatesFilter<"User"> | string | null
    razorpayOrderId?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: StringFilter<"Organization"> | string
    name?: StringFilter<"Organization"> | string
    logo?: StringNullableFilter<"Organization"> | string | null
    ownerId?: StringFilter<"Organization"> | string
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    aiTemplates?: AIReplyTemplateListRelationFilter
    locations?: LocationListRelationFilter
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    reportJobs?: ReportJobListRelationFilter
    members?: UserListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aiTemplates?: AIReplyTemplateOrderByRelationAggregateInput
    locations?: LocationOrderByRelationAggregateInput
    owner?: UserOrderByWithRelationInput
    reportJobs?: ReportJobOrderByRelationAggregateInput
    members?: UserOrderByRelationAggregateInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    name?: StringFilter<"Organization"> | string
    logo?: StringNullableFilter<"Organization"> | string | null
    ownerId?: StringFilter<"Organization"> | string
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    aiTemplates?: AIReplyTemplateListRelationFilter
    locations?: LocationListRelationFilter
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    reportJobs?: ReportJobListRelationFilter
    members?: UserListRelationFilter
  }, "id">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Organization"> | string
    name?: StringWithAggregatesFilter<"Organization"> | string
    logo?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    ownerId?: StringWithAggregatesFilter<"Organization"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: StringFilter<"Location"> | string
    name?: StringFilter<"Location"> | string
    organizationId?: StringFilter<"Location"> | string
    gmbLocationId?: StringFilter<"Location"> | string
    gmbLocationName?: StringFilter<"Location"> | string
    address?: StringNullableFilter<"Location"> | string | null
    phone?: StringNullableFilter<"Location"> | string | null
    websiteUrl?: StringNullableFilter<"Location"> | string | null
    latitude?: FloatNullableFilter<"Location"> | number | null
    longitude?: FloatNullableFilter<"Location"> | number | null
    timezone?: StringFilter<"Location"> | string
    isVerified?: BoolFilter<"Location"> | boolean
    lastSyncedAt?: DateTimeFilter<"Location"> | Date | string
    lastFetchedTimestamp?: DateTimeNullableFilter<"Location"> | Date | string | null
    autoReplyEnabled?: BoolFilter<"Location"> | boolean
    autoPostEnabled?: BoolFilter<"Location"> | boolean
    replyTonePreference?: EnumReplyToneNullableFilter<"Location"> | $Enums.ReplyTone | null
    accessToken?: StringNullableFilter<"Location"> | string | null
    refreshToken?: StringNullableFilter<"Location"> | string | null
    tokenExpiresAt?: DateTimeNullableFilter<"Location"> | Date | string | null
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    logoUrl?: StringNullableFilter<"Location"> | string | null
    gmbAccountId?: StringNullableFilter<"Location"> | string | null
    insights?: InsightListRelationFilter
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    posts?: PostListRelationFilter
    reports?: ReportListRelationFilter
    reviews?: ReviewListRelationFilter
    users?: UserListRelationFilter
    searchKeywords?: SearchKeywordListRelationFilter
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    organizationId?: SortOrder
    gmbLocationId?: SortOrder
    gmbLocationName?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    websiteUrl?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    timezone?: SortOrder
    isVerified?: SortOrder
    lastSyncedAt?: SortOrder
    lastFetchedTimestamp?: SortOrderInput | SortOrder
    autoReplyEnabled?: SortOrder
    autoPostEnabled?: SortOrder
    replyTonePreference?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    tokenExpiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    gmbAccountId?: SortOrderInput | SortOrder
    insights?: InsightOrderByRelationAggregateInput
    organization?: OrganizationOrderByWithRelationInput
    posts?: PostOrderByRelationAggregateInput
    reports?: ReportOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    searchKeywords?: SearchKeywordOrderByRelationAggregateInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gmbLocationId?: string
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    name?: StringFilter<"Location"> | string
    organizationId?: StringFilter<"Location"> | string
    gmbLocationName?: StringFilter<"Location"> | string
    address?: StringNullableFilter<"Location"> | string | null
    phone?: StringNullableFilter<"Location"> | string | null
    websiteUrl?: StringNullableFilter<"Location"> | string | null
    latitude?: FloatNullableFilter<"Location"> | number | null
    longitude?: FloatNullableFilter<"Location"> | number | null
    timezone?: StringFilter<"Location"> | string
    isVerified?: BoolFilter<"Location"> | boolean
    lastSyncedAt?: DateTimeFilter<"Location"> | Date | string
    lastFetchedTimestamp?: DateTimeNullableFilter<"Location"> | Date | string | null
    autoReplyEnabled?: BoolFilter<"Location"> | boolean
    autoPostEnabled?: BoolFilter<"Location"> | boolean
    replyTonePreference?: EnumReplyToneNullableFilter<"Location"> | $Enums.ReplyTone | null
    accessToken?: StringNullableFilter<"Location"> | string | null
    refreshToken?: StringNullableFilter<"Location"> | string | null
    tokenExpiresAt?: DateTimeNullableFilter<"Location"> | Date | string | null
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    logoUrl?: StringNullableFilter<"Location"> | string | null
    gmbAccountId?: StringNullableFilter<"Location"> | string | null
    insights?: InsightListRelationFilter
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    posts?: PostListRelationFilter
    reports?: ReportListRelationFilter
    reviews?: ReviewListRelationFilter
    users?: UserListRelationFilter
    searchKeywords?: SearchKeywordListRelationFilter
  }, "id" | "gmbLocationId">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    organizationId?: SortOrder
    gmbLocationId?: SortOrder
    gmbLocationName?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    websiteUrl?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    timezone?: SortOrder
    isVerified?: SortOrder
    lastSyncedAt?: SortOrder
    lastFetchedTimestamp?: SortOrderInput | SortOrder
    autoReplyEnabled?: SortOrder
    autoPostEnabled?: SortOrder
    replyTonePreference?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    tokenExpiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    gmbAccountId?: SortOrderInput | SortOrder
    _count?: LocationCountOrderByAggregateInput
    _avg?: LocationAvgOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
    _sum?: LocationSumOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Location"> | string
    name?: StringWithAggregatesFilter<"Location"> | string
    organizationId?: StringWithAggregatesFilter<"Location"> | string
    gmbLocationId?: StringWithAggregatesFilter<"Location"> | string
    gmbLocationName?: StringWithAggregatesFilter<"Location"> | string
    address?: StringNullableWithAggregatesFilter<"Location"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Location"> | string | null
    websiteUrl?: StringNullableWithAggregatesFilter<"Location"> | string | null
    latitude?: FloatNullableWithAggregatesFilter<"Location"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Location"> | number | null
    timezone?: StringWithAggregatesFilter<"Location"> | string
    isVerified?: BoolWithAggregatesFilter<"Location"> | boolean
    lastSyncedAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
    lastFetchedTimestamp?: DateTimeNullableWithAggregatesFilter<"Location"> | Date | string | null
    autoReplyEnabled?: BoolWithAggregatesFilter<"Location"> | boolean
    autoPostEnabled?: BoolWithAggregatesFilter<"Location"> | boolean
    replyTonePreference?: EnumReplyToneNullableWithAggregatesFilter<"Location"> | $Enums.ReplyTone | null
    accessToken?: StringNullableWithAggregatesFilter<"Location"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Location"> | string | null
    tokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Location"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
    logoUrl?: StringNullableWithAggregatesFilter<"Location"> | string | null
    gmbAccountId?: StringNullableWithAggregatesFilter<"Location"> | string | null
  }

  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    id?: StringFilter<"Post"> | string
    locationId?: StringFilter<"Post"> | string
    userId?: StringFilter<"Post"> | string
    title?: StringFilter<"Post"> | string
    content?: StringFilter<"Post"> | string
    type?: EnumPostTypeFilter<"Post"> | $Enums.PostType
    mediaUrls?: StringNullableListFilter<"Post">
    scheduledAt?: DateTimeFilter<"Post"> | Date | string
    publishedAt?: DateTimeNullableFilter<"Post"> | Date | string | null
    status?: EnumPostStatusFilter<"Post"> | $Enums.PostStatus
    eventStart?: DateTimeNullableFilter<"Post"> | Date | string | null
    eventEnd?: DateTimeNullableFilter<"Post"> | Date | string | null
    offerStart?: DateTimeNullableFilter<"Post"> | Date | string | null
    offerEnd?: DateTimeNullableFilter<"Post"> | Date | string | null
    couponCode?: StringNullableFilter<"Post"> | string | null
    callToAction?: StringNullableFilter<"Post"> | string | null
    recurType?: EnumRecurTypeNullableFilter<"Post"> | $Enums.RecurType | null
    recurEndsAt?: DateTimeNullableFilter<"Post"> | Date | string | null
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    locationId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    mediaUrls?: SortOrder
    scheduledAt?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    eventStart?: SortOrderInput | SortOrder
    eventEnd?: SortOrderInput | SortOrder
    offerStart?: SortOrderInput | SortOrder
    offerEnd?: SortOrderInput | SortOrder
    couponCode?: SortOrderInput | SortOrder
    callToAction?: SortOrderInput | SortOrder
    recurType?: SortOrderInput | SortOrder
    recurEndsAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: LocationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    locationId?: StringFilter<"Post"> | string
    userId?: StringFilter<"Post"> | string
    title?: StringFilter<"Post"> | string
    content?: StringFilter<"Post"> | string
    type?: EnumPostTypeFilter<"Post"> | $Enums.PostType
    mediaUrls?: StringNullableListFilter<"Post">
    scheduledAt?: DateTimeFilter<"Post"> | Date | string
    publishedAt?: DateTimeNullableFilter<"Post"> | Date | string | null
    status?: EnumPostStatusFilter<"Post"> | $Enums.PostStatus
    eventStart?: DateTimeNullableFilter<"Post"> | Date | string | null
    eventEnd?: DateTimeNullableFilter<"Post"> | Date | string | null
    offerStart?: DateTimeNullableFilter<"Post"> | Date | string | null
    offerEnd?: DateTimeNullableFilter<"Post"> | Date | string | null
    couponCode?: StringNullableFilter<"Post"> | string | null
    callToAction?: StringNullableFilter<"Post"> | string | null
    recurType?: EnumRecurTypeNullableFilter<"Post"> | $Enums.RecurType | null
    recurEndsAt?: DateTimeNullableFilter<"Post"> | Date | string | null
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    locationId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    mediaUrls?: SortOrder
    scheduledAt?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    eventStart?: SortOrderInput | SortOrder
    eventEnd?: SortOrderInput | SortOrder
    offerStart?: SortOrderInput | SortOrder
    offerEnd?: SortOrderInput | SortOrder
    couponCode?: SortOrderInput | SortOrder
    callToAction?: SortOrderInput | SortOrder
    recurType?: SortOrderInput | SortOrder
    recurEndsAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Post"> | string
    locationId?: StringWithAggregatesFilter<"Post"> | string
    userId?: StringWithAggregatesFilter<"Post"> | string
    title?: StringWithAggregatesFilter<"Post"> | string
    content?: StringWithAggregatesFilter<"Post"> | string
    type?: EnumPostTypeWithAggregatesFilter<"Post"> | $Enums.PostType
    mediaUrls?: StringNullableListFilter<"Post">
    scheduledAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    publishedAt?: DateTimeNullableWithAggregatesFilter<"Post"> | Date | string | null
    status?: EnumPostStatusWithAggregatesFilter<"Post"> | $Enums.PostStatus
    eventStart?: DateTimeNullableWithAggregatesFilter<"Post"> | Date | string | null
    eventEnd?: DateTimeNullableWithAggregatesFilter<"Post"> | Date | string | null
    offerStart?: DateTimeNullableWithAggregatesFilter<"Post"> | Date | string | null
    offerEnd?: DateTimeNullableWithAggregatesFilter<"Post"> | Date | string | null
    couponCode?: StringNullableWithAggregatesFilter<"Post"> | string | null
    callToAction?: StringNullableWithAggregatesFilter<"Post"> | string | null
    recurType?: EnumRecurTypeNullableWithAggregatesFilter<"Post"> | $Enums.RecurType | null
    recurEndsAt?: DateTimeNullableWithAggregatesFilter<"Post"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: StringFilter<"Review"> | string
    locationId?: StringFilter<"Review"> | string
    reviewId?: StringFilter<"Review"> | string
    authorName?: StringFilter<"Review"> | string
    authorPhoto?: StringNullableFilter<"Review"> | string | null
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    createTime?: DateTimeFilter<"Review"> | Date | string
    updateTime?: DateTimeFilter<"Review"> | Date | string
    status?: EnumReviewStatusFilter<"Review"> | $Enums.ReviewStatus
    isProcessed?: BoolFilter<"Review"> | boolean
    sentiment?: EnumSentimentTypeNullableFilter<"Review"> | $Enums.SentimentType | null
    language?: StringNullableFilter<"Review"> | string | null
    isReplyNeeded?: BoolFilter<"Review"> | boolean
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    replies?: ReviewReplyListRelationFilter
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    locationId?: SortOrder
    reviewId?: SortOrder
    authorName?: SortOrder
    authorPhoto?: SortOrderInput | SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createTime?: SortOrder
    updateTime?: SortOrder
    status?: SortOrder
    isProcessed?: SortOrder
    sentiment?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    isReplyNeeded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: LocationOrderByWithRelationInput
    replies?: ReviewReplyOrderByRelationAggregateInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    reviewId?: string
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    locationId?: StringFilter<"Review"> | string
    authorName?: StringFilter<"Review"> | string
    authorPhoto?: StringNullableFilter<"Review"> | string | null
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    createTime?: DateTimeFilter<"Review"> | Date | string
    updateTime?: DateTimeFilter<"Review"> | Date | string
    status?: EnumReviewStatusFilter<"Review"> | $Enums.ReviewStatus
    isProcessed?: BoolFilter<"Review"> | boolean
    sentiment?: EnumSentimentTypeNullableFilter<"Review"> | $Enums.SentimentType | null
    language?: StringNullableFilter<"Review"> | string | null
    isReplyNeeded?: BoolFilter<"Review"> | boolean
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    replies?: ReviewReplyListRelationFilter
  }, "id" | "reviewId">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    locationId?: SortOrder
    reviewId?: SortOrder
    authorName?: SortOrder
    authorPhoto?: SortOrderInput | SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createTime?: SortOrder
    updateTime?: SortOrder
    status?: SortOrder
    isProcessed?: SortOrder
    sentiment?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    isReplyNeeded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Review"> | string
    locationId?: StringWithAggregatesFilter<"Review"> | string
    reviewId?: StringWithAggregatesFilter<"Review"> | string
    authorName?: StringWithAggregatesFilter<"Review"> | string
    authorPhoto?: StringNullableWithAggregatesFilter<"Review"> | string | null
    rating?: IntWithAggregatesFilter<"Review"> | number
    comment?: StringNullableWithAggregatesFilter<"Review"> | string | null
    createTime?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    updateTime?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    status?: EnumReviewStatusWithAggregatesFilter<"Review"> | $Enums.ReviewStatus
    isProcessed?: BoolWithAggregatesFilter<"Review"> | boolean
    sentiment?: EnumSentimentTypeNullableWithAggregatesFilter<"Review"> | $Enums.SentimentType | null
    language?: StringNullableWithAggregatesFilter<"Review"> | string | null
    isReplyNeeded?: BoolWithAggregatesFilter<"Review"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
  }

  export type ReviewReplyWhereInput = {
    AND?: ReviewReplyWhereInput | ReviewReplyWhereInput[]
    OR?: ReviewReplyWhereInput[]
    NOT?: ReviewReplyWhereInput | ReviewReplyWhereInput[]
    id?: StringFilter<"ReviewReply"> | string
    reviewId?: StringFilter<"ReviewReply"> | string
    userId?: StringNullableFilter<"ReviewReply"> | string | null
    content?: StringFilter<"ReviewReply"> | string
    source?: EnumReplySourceFilter<"ReviewReply"> | $Enums.ReplySource
    tone?: EnumReplyToneFilter<"ReviewReply"> | $Enums.ReplyTone
    isPublished?: BoolFilter<"ReviewReply"> | boolean
    publishedAt?: DateTimeNullableFilter<"ReviewReply"> | Date | string | null
    aiTemplateId?: StringNullableFilter<"ReviewReply"> | string | null
    createdAt?: DateTimeFilter<"ReviewReply"> | Date | string
    updatedAt?: DateTimeFilter<"ReviewReply"> | Date | string
    aiTemplate?: XOR<AIReplyTemplateNullableScalarRelationFilter, AIReplyTemplateWhereInput> | null
    review?: XOR<ReviewScalarRelationFilter, ReviewWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ReviewReplyOrderByWithRelationInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrderInput | SortOrder
    content?: SortOrder
    source?: SortOrder
    tone?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    aiTemplateId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aiTemplate?: AIReplyTemplateOrderByWithRelationInput
    review?: ReviewOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ReviewReplyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReviewReplyWhereInput | ReviewReplyWhereInput[]
    OR?: ReviewReplyWhereInput[]
    NOT?: ReviewReplyWhereInput | ReviewReplyWhereInput[]
    reviewId?: StringFilter<"ReviewReply"> | string
    userId?: StringNullableFilter<"ReviewReply"> | string | null
    content?: StringFilter<"ReviewReply"> | string
    source?: EnumReplySourceFilter<"ReviewReply"> | $Enums.ReplySource
    tone?: EnumReplyToneFilter<"ReviewReply"> | $Enums.ReplyTone
    isPublished?: BoolFilter<"ReviewReply"> | boolean
    publishedAt?: DateTimeNullableFilter<"ReviewReply"> | Date | string | null
    aiTemplateId?: StringNullableFilter<"ReviewReply"> | string | null
    createdAt?: DateTimeFilter<"ReviewReply"> | Date | string
    updatedAt?: DateTimeFilter<"ReviewReply"> | Date | string
    aiTemplate?: XOR<AIReplyTemplateNullableScalarRelationFilter, AIReplyTemplateWhereInput> | null
    review?: XOR<ReviewScalarRelationFilter, ReviewWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type ReviewReplyOrderByWithAggregationInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrderInput | SortOrder
    content?: SortOrder
    source?: SortOrder
    tone?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    aiTemplateId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReviewReplyCountOrderByAggregateInput
    _max?: ReviewReplyMaxOrderByAggregateInput
    _min?: ReviewReplyMinOrderByAggregateInput
  }

  export type ReviewReplyScalarWhereWithAggregatesInput = {
    AND?: ReviewReplyScalarWhereWithAggregatesInput | ReviewReplyScalarWhereWithAggregatesInput[]
    OR?: ReviewReplyScalarWhereWithAggregatesInput[]
    NOT?: ReviewReplyScalarWhereWithAggregatesInput | ReviewReplyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReviewReply"> | string
    reviewId?: StringWithAggregatesFilter<"ReviewReply"> | string
    userId?: StringNullableWithAggregatesFilter<"ReviewReply"> | string | null
    content?: StringWithAggregatesFilter<"ReviewReply"> | string
    source?: EnumReplySourceWithAggregatesFilter<"ReviewReply"> | $Enums.ReplySource
    tone?: EnumReplyToneWithAggregatesFilter<"ReviewReply"> | $Enums.ReplyTone
    isPublished?: BoolWithAggregatesFilter<"ReviewReply"> | boolean
    publishedAt?: DateTimeNullableWithAggregatesFilter<"ReviewReply"> | Date | string | null
    aiTemplateId?: StringNullableWithAggregatesFilter<"ReviewReply"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ReviewReply"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReviewReply"> | Date | string
  }

  export type AIReplyTemplateWhereInput = {
    AND?: AIReplyTemplateWhereInput | AIReplyTemplateWhereInput[]
    OR?: AIReplyTemplateWhereInput[]
    NOT?: AIReplyTemplateWhereInput | AIReplyTemplateWhereInput[]
    id?: StringFilter<"AIReplyTemplate"> | string
    organizationId?: StringFilter<"AIReplyTemplate"> | string
    name?: StringFilter<"AIReplyTemplate"> | string
    content?: StringFilter<"AIReplyTemplate"> | string
    tone?: EnumReplyToneFilter<"AIReplyTemplate"> | $Enums.ReplyTone
    sentiment?: EnumSentimentTypeFilter<"AIReplyTemplate"> | $Enums.SentimentType
    isDefault?: BoolFilter<"AIReplyTemplate"> | boolean
    createdAt?: DateTimeFilter<"AIReplyTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"AIReplyTemplate"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    replies?: ReviewReplyListRelationFilter
  }

  export type AIReplyTemplateOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    content?: SortOrder
    tone?: SortOrder
    sentiment?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    replies?: ReviewReplyOrderByRelationAggregateInput
  }

  export type AIReplyTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIReplyTemplateWhereInput | AIReplyTemplateWhereInput[]
    OR?: AIReplyTemplateWhereInput[]
    NOT?: AIReplyTemplateWhereInput | AIReplyTemplateWhereInput[]
    organizationId?: StringFilter<"AIReplyTemplate"> | string
    name?: StringFilter<"AIReplyTemplate"> | string
    content?: StringFilter<"AIReplyTemplate"> | string
    tone?: EnumReplyToneFilter<"AIReplyTemplate"> | $Enums.ReplyTone
    sentiment?: EnumSentimentTypeFilter<"AIReplyTemplate"> | $Enums.SentimentType
    isDefault?: BoolFilter<"AIReplyTemplate"> | boolean
    createdAt?: DateTimeFilter<"AIReplyTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"AIReplyTemplate"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    replies?: ReviewReplyListRelationFilter
  }, "id">

  export type AIReplyTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    content?: SortOrder
    tone?: SortOrder
    sentiment?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AIReplyTemplateCountOrderByAggregateInput
    _max?: AIReplyTemplateMaxOrderByAggregateInput
    _min?: AIReplyTemplateMinOrderByAggregateInput
  }

  export type AIReplyTemplateScalarWhereWithAggregatesInput = {
    AND?: AIReplyTemplateScalarWhereWithAggregatesInput | AIReplyTemplateScalarWhereWithAggregatesInput[]
    OR?: AIReplyTemplateScalarWhereWithAggregatesInput[]
    NOT?: AIReplyTemplateScalarWhereWithAggregatesInput | AIReplyTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIReplyTemplate"> | string
    organizationId?: StringWithAggregatesFilter<"AIReplyTemplate"> | string
    name?: StringWithAggregatesFilter<"AIReplyTemplate"> | string
    content?: StringWithAggregatesFilter<"AIReplyTemplate"> | string
    tone?: EnumReplyToneWithAggregatesFilter<"AIReplyTemplate"> | $Enums.ReplyTone
    sentiment?: EnumSentimentTypeWithAggregatesFilter<"AIReplyTemplate"> | $Enums.SentimentType
    isDefault?: BoolWithAggregatesFilter<"AIReplyTemplate"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AIReplyTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AIReplyTemplate"> | Date | string
  }

  export type InsightWhereInput = {
    AND?: InsightWhereInput | InsightWhereInput[]
    OR?: InsightWhereInput[]
    NOT?: InsightWhereInput | InsightWhereInput[]
    id?: StringFilter<"Insight"> | string
    locationId?: StringFilter<"Insight"> | string
    date?: DateTimeFilter<"Insight"> | Date | string
    type?: EnumInsightTypeFilter<"Insight"> | $Enums.InsightType
    value?: IntFilter<"Insight"> | number
    createdAt?: DateTimeFilter<"Insight"> | Date | string
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }

  export type InsightOrderByWithRelationInput = {
    id?: SortOrder
    locationId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    location?: LocationOrderByWithRelationInput
  }

  export type InsightWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    locationId_date_type?: InsightLocationIdDateTypeCompoundUniqueInput
    AND?: InsightWhereInput | InsightWhereInput[]
    OR?: InsightWhereInput[]
    NOT?: InsightWhereInput | InsightWhereInput[]
    locationId?: StringFilter<"Insight"> | string
    date?: DateTimeFilter<"Insight"> | Date | string
    type?: EnumInsightTypeFilter<"Insight"> | $Enums.InsightType
    value?: IntFilter<"Insight"> | number
    createdAt?: DateTimeFilter<"Insight"> | Date | string
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }, "id" | "locationId_date_type">

  export type InsightOrderByWithAggregationInput = {
    id?: SortOrder
    locationId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    _count?: InsightCountOrderByAggregateInput
    _avg?: InsightAvgOrderByAggregateInput
    _max?: InsightMaxOrderByAggregateInput
    _min?: InsightMinOrderByAggregateInput
    _sum?: InsightSumOrderByAggregateInput
  }

  export type InsightScalarWhereWithAggregatesInput = {
    AND?: InsightScalarWhereWithAggregatesInput | InsightScalarWhereWithAggregatesInput[]
    OR?: InsightScalarWhereWithAggregatesInput[]
    NOT?: InsightScalarWhereWithAggregatesInput | InsightScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Insight"> | string
    locationId?: StringWithAggregatesFilter<"Insight"> | string
    date?: DateTimeWithAggregatesFilter<"Insight"> | Date | string
    type?: EnumInsightTypeWithAggregatesFilter<"Insight"> | $Enums.InsightType
    value?: IntWithAggregatesFilter<"Insight"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Insight"> | Date | string
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: StringFilter<"Report"> | string
    locationId?: StringFilter<"Report"> | string
    name?: StringFilter<"Report"> | string
    startDate?: DateTimeFilter<"Report"> | Date | string
    endDate?: DateTimeFilter<"Report"> | Date | string
    reportType?: EnumReportTypeFilter<"Report"> | $Enums.ReportType
    fileUrl?: StringNullableFilter<"Report"> | string | null
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    locationId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reportType?: SortOrder
    fileUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: LocationOrderByWithRelationInput
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    locationId?: StringFilter<"Report"> | string
    name?: StringFilter<"Report"> | string
    startDate?: DateTimeFilter<"Report"> | Date | string
    endDate?: DateTimeFilter<"Report"> | Date | string
    reportType?: EnumReportTypeFilter<"Report"> | $Enums.ReportType
    fileUrl?: StringNullableFilter<"Report"> | string | null
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }, "id">

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    locationId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reportType?: SortOrder
    fileUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReportCountOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Report"> | string
    locationId?: StringWithAggregatesFilter<"Report"> | string
    name?: StringWithAggregatesFilter<"Report"> | string
    startDate?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    reportType?: EnumReportTypeWithAggregatesFilter<"Report"> | $Enums.ReportType
    fileUrl?: StringNullableWithAggregatesFilter<"Report"> | string | null
    status?: EnumReportStatusWithAggregatesFilter<"Report"> | $Enums.ReportStatus
    createdAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
  }

  export type ReportJobWhereInput = {
    AND?: ReportJobWhereInput | ReportJobWhereInput[]
    OR?: ReportJobWhereInput[]
    NOT?: ReportJobWhereInput | ReportJobWhereInput[]
    id?: StringFilter<"ReportJob"> | string
    organizationId?: StringFilter<"ReportJob"> | string
    name?: StringFilter<"ReportJob"> | string
    locations?: StringNullableListFilter<"ReportJob">
    frequency?: EnumReportFrequencyFilter<"ReportJob"> | $Enums.ReportFrequency
    emailRecipients?: StringNullableListFilter<"ReportJob">
    isActive?: BoolFilter<"ReportJob"> | boolean
    lastRunAt?: DateTimeNullableFilter<"ReportJob"> | Date | string | null
    nextRunAt?: DateTimeFilter<"ReportJob"> | Date | string
    createdAt?: DateTimeFilter<"ReportJob"> | Date | string
    updatedAt?: DateTimeFilter<"ReportJob"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type ReportJobOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    locations?: SortOrder
    frequency?: SortOrder
    emailRecipients?: SortOrder
    isActive?: SortOrder
    lastRunAt?: SortOrderInput | SortOrder
    nextRunAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
  }

  export type ReportJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportJobWhereInput | ReportJobWhereInput[]
    OR?: ReportJobWhereInput[]
    NOT?: ReportJobWhereInput | ReportJobWhereInput[]
    organizationId?: StringFilter<"ReportJob"> | string
    name?: StringFilter<"ReportJob"> | string
    locations?: StringNullableListFilter<"ReportJob">
    frequency?: EnumReportFrequencyFilter<"ReportJob"> | $Enums.ReportFrequency
    emailRecipients?: StringNullableListFilter<"ReportJob">
    isActive?: BoolFilter<"ReportJob"> | boolean
    lastRunAt?: DateTimeNullableFilter<"ReportJob"> | Date | string | null
    nextRunAt?: DateTimeFilter<"ReportJob"> | Date | string
    createdAt?: DateTimeFilter<"ReportJob"> | Date | string
    updatedAt?: DateTimeFilter<"ReportJob"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id">

  export type ReportJobOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    locations?: SortOrder
    frequency?: SortOrder
    emailRecipients?: SortOrder
    isActive?: SortOrder
    lastRunAt?: SortOrderInput | SortOrder
    nextRunAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReportJobCountOrderByAggregateInput
    _max?: ReportJobMaxOrderByAggregateInput
    _min?: ReportJobMinOrderByAggregateInput
  }

  export type ReportJobScalarWhereWithAggregatesInput = {
    AND?: ReportJobScalarWhereWithAggregatesInput | ReportJobScalarWhereWithAggregatesInput[]
    OR?: ReportJobScalarWhereWithAggregatesInput[]
    NOT?: ReportJobScalarWhereWithAggregatesInput | ReportJobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReportJob"> | string
    organizationId?: StringWithAggregatesFilter<"ReportJob"> | string
    name?: StringWithAggregatesFilter<"ReportJob"> | string
    locations?: StringNullableListFilter<"ReportJob">
    frequency?: EnumReportFrequencyWithAggregatesFilter<"ReportJob"> | $Enums.ReportFrequency
    emailRecipients?: StringNullableListFilter<"ReportJob">
    isActive?: BoolWithAggregatesFilter<"ReportJob"> | boolean
    lastRunAt?: DateTimeNullableWithAggregatesFilter<"ReportJob"> | Date | string | null
    nextRunAt?: DateTimeWithAggregatesFilter<"ReportJob"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"ReportJob"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReportJob"> | Date | string
  }

  export type SearchKeywordWhereInput = {
    AND?: SearchKeywordWhereInput | SearchKeywordWhereInput[]
    OR?: SearchKeywordWhereInput[]
    NOT?: SearchKeywordWhereInput | SearchKeywordWhereInput[]
    id?: StringFilter<"SearchKeyword"> | string
    keyword?: StringFilter<"SearchKeyword"> | string
    locationId?: StringFilter<"SearchKeyword"> | string
    latitude?: FloatFilter<"SearchKeyword"> | number
    longitude?: FloatFilter<"SearchKeyword"> | number
    createdAt?: DateTimeFilter<"SearchKeyword"> | Date | string
    updatedAt?: DateTimeFilter<"SearchKeyword"> | Date | string
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    rankResults?: RankTrackingResultListRelationFilter
  }

  export type SearchKeywordOrderByWithRelationInput = {
    id?: SortOrder
    keyword?: SortOrder
    locationId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: LocationOrderByWithRelationInput
    rankResults?: RankTrackingResultOrderByRelationAggregateInput
  }

  export type SearchKeywordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    keyword_locationId?: SearchKeywordKeywordLocationIdCompoundUniqueInput
    AND?: SearchKeywordWhereInput | SearchKeywordWhereInput[]
    OR?: SearchKeywordWhereInput[]
    NOT?: SearchKeywordWhereInput | SearchKeywordWhereInput[]
    keyword?: StringFilter<"SearchKeyword"> | string
    locationId?: StringFilter<"SearchKeyword"> | string
    latitude?: FloatFilter<"SearchKeyword"> | number
    longitude?: FloatFilter<"SearchKeyword"> | number
    createdAt?: DateTimeFilter<"SearchKeyword"> | Date | string
    updatedAt?: DateTimeFilter<"SearchKeyword"> | Date | string
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    rankResults?: RankTrackingResultListRelationFilter
  }, "id" | "keyword_locationId">

  export type SearchKeywordOrderByWithAggregationInput = {
    id?: SortOrder
    keyword?: SortOrder
    locationId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SearchKeywordCountOrderByAggregateInput
    _avg?: SearchKeywordAvgOrderByAggregateInput
    _max?: SearchKeywordMaxOrderByAggregateInput
    _min?: SearchKeywordMinOrderByAggregateInput
    _sum?: SearchKeywordSumOrderByAggregateInput
  }

  export type SearchKeywordScalarWhereWithAggregatesInput = {
    AND?: SearchKeywordScalarWhereWithAggregatesInput | SearchKeywordScalarWhereWithAggregatesInput[]
    OR?: SearchKeywordScalarWhereWithAggregatesInput[]
    NOT?: SearchKeywordScalarWhereWithAggregatesInput | SearchKeywordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SearchKeyword"> | string
    keyword?: StringWithAggregatesFilter<"SearchKeyword"> | string
    locationId?: StringWithAggregatesFilter<"SearchKeyword"> | string
    latitude?: FloatWithAggregatesFilter<"SearchKeyword"> | number
    longitude?: FloatWithAggregatesFilter<"SearchKeyword"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SearchKeyword"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SearchKeyword"> | Date | string
  }

  export type RankTrackingResultWhereInput = {
    AND?: RankTrackingResultWhereInput | RankTrackingResultWhereInput[]
    OR?: RankTrackingResultWhereInput[]
    NOT?: RankTrackingResultWhereInput | RankTrackingResultWhereInput[]
    id?: StringFilter<"RankTrackingResult"> | string
    keywordId?: StringFilter<"RankTrackingResult"> | string
    rankPosition?: IntNullableFilter<"RankTrackingResult"> | number | null
    searchDate?: DateTimeFilter<"RankTrackingResult"> | Date | string
    searchUrl?: StringNullableFilter<"RankTrackingResult"> | string | null
    businessUrl?: StringNullableFilter<"RankTrackingResult"> | string | null
    businessName?: StringNullableFilter<"RankTrackingResult"> | string | null
    htmlSnapshot?: StringNullableFilter<"RankTrackingResult"> | string | null
    createdAt?: DateTimeFilter<"RankTrackingResult"> | Date | string
    keyword?: XOR<SearchKeywordScalarRelationFilter, SearchKeywordWhereInput>
  }

  export type RankTrackingResultOrderByWithRelationInput = {
    id?: SortOrder
    keywordId?: SortOrder
    rankPosition?: SortOrderInput | SortOrder
    searchDate?: SortOrder
    searchUrl?: SortOrderInput | SortOrder
    businessUrl?: SortOrderInput | SortOrder
    businessName?: SortOrderInput | SortOrder
    htmlSnapshot?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    keyword?: SearchKeywordOrderByWithRelationInput
  }

  export type RankTrackingResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RankTrackingResultWhereInput | RankTrackingResultWhereInput[]
    OR?: RankTrackingResultWhereInput[]
    NOT?: RankTrackingResultWhereInput | RankTrackingResultWhereInput[]
    keywordId?: StringFilter<"RankTrackingResult"> | string
    rankPosition?: IntNullableFilter<"RankTrackingResult"> | number | null
    searchDate?: DateTimeFilter<"RankTrackingResult"> | Date | string
    searchUrl?: StringNullableFilter<"RankTrackingResult"> | string | null
    businessUrl?: StringNullableFilter<"RankTrackingResult"> | string | null
    businessName?: StringNullableFilter<"RankTrackingResult"> | string | null
    htmlSnapshot?: StringNullableFilter<"RankTrackingResult"> | string | null
    createdAt?: DateTimeFilter<"RankTrackingResult"> | Date | string
    keyword?: XOR<SearchKeywordScalarRelationFilter, SearchKeywordWhereInput>
  }, "id">

  export type RankTrackingResultOrderByWithAggregationInput = {
    id?: SortOrder
    keywordId?: SortOrder
    rankPosition?: SortOrderInput | SortOrder
    searchDate?: SortOrder
    searchUrl?: SortOrderInput | SortOrder
    businessUrl?: SortOrderInput | SortOrder
    businessName?: SortOrderInput | SortOrder
    htmlSnapshot?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: RankTrackingResultCountOrderByAggregateInput
    _avg?: RankTrackingResultAvgOrderByAggregateInput
    _max?: RankTrackingResultMaxOrderByAggregateInput
    _min?: RankTrackingResultMinOrderByAggregateInput
    _sum?: RankTrackingResultSumOrderByAggregateInput
  }

  export type RankTrackingResultScalarWhereWithAggregatesInput = {
    AND?: RankTrackingResultScalarWhereWithAggregatesInput | RankTrackingResultScalarWhereWithAggregatesInput[]
    OR?: RankTrackingResultScalarWhereWithAggregatesInput[]
    NOT?: RankTrackingResultScalarWhereWithAggregatesInput | RankTrackingResultScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RankTrackingResult"> | string
    keywordId?: StringWithAggregatesFilter<"RankTrackingResult"> | string
    rankPosition?: IntNullableWithAggregatesFilter<"RankTrackingResult"> | number | null
    searchDate?: DateTimeWithAggregatesFilter<"RankTrackingResult"> | Date | string
    searchUrl?: StringNullableWithAggregatesFilter<"RankTrackingResult"> | string | null
    businessUrl?: StringNullableWithAggregatesFilter<"RankTrackingResult"> | string | null
    businessName?: StringNullableWithAggregatesFilter<"RankTrackingResult"> | string | null
    htmlSnapshot?: StringNullableWithAggregatesFilter<"RankTrackingResult"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RankTrackingResult"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    emailVerificationToken?: string | null
    password: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiresAt?: Date | string | null
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    subscriptionPlan?: $Enums.SubscriptionPlan | null
    trialStartedAt?: Date | string | null
    trialEndsAt?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    razorpayCustomerId?: string | null
    razorpayPaymentId?: string | null
    razorpayOrderId?: string | null
    ownedOrganizations?: OrganizationCreateNestedManyWithoutOwnerInput
    posts?: PostCreateNestedManyWithoutUserInput
    reviewReplies?: ReviewReplyCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    locations?: LocationCreateNestedManyWithoutUsersInput
    organizations?: OrganizationCreateNestedManyWithoutMembersInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    emailVerificationToken?: string | null
    password: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiresAt?: Date | string | null
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    subscriptionPlan?: $Enums.SubscriptionPlan | null
    trialStartedAt?: Date | string | null
    trialEndsAt?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    razorpayCustomerId?: string | null
    razorpayPaymentId?: string | null
    razorpayOrderId?: string | null
    ownedOrganizations?: OrganizationUncheckedCreateNestedManyWithoutOwnerInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    reviewReplies?: ReviewReplyUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    locations?: LocationUncheckedCreateNestedManyWithoutUsersInput
    organizations?: OrganizationUncheckedCreateNestedManyWithoutMembersInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    subscriptionPlan?: NullableEnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan | null
    trialStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    ownedOrganizations?: OrganizationUpdateManyWithoutOwnerNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    reviewReplies?: ReviewReplyUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    locations?: LocationUpdateManyWithoutUsersNestedInput
    organizations?: OrganizationUpdateManyWithoutMembersNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    subscriptionPlan?: NullableEnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan | null
    trialStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    ownedOrganizations?: OrganizationUncheckedUpdateManyWithoutOwnerNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    reviewReplies?: ReviewReplyUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    locations?: LocationUncheckedUpdateManyWithoutUsersNestedInput
    organizations?: OrganizationUncheckedUpdateManyWithoutMembersNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    emailVerificationToken?: string | null
    password: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiresAt?: Date | string | null
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    subscriptionPlan?: $Enums.SubscriptionPlan | null
    trialStartedAt?: Date | string | null
    trialEndsAt?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    razorpayCustomerId?: string | null
    razorpayPaymentId?: string | null
    razorpayOrderId?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    subscriptionPlan?: NullableEnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan | null
    trialStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    subscriptionPlan?: NullableEnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan | null
    trialStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateInput = {
    id?: string
    name: string
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiTemplates?: AIReplyTemplateCreateNestedManyWithoutOrganizationInput
    locations?: LocationCreateNestedManyWithoutOrganizationInput
    owner: UserCreateNestedOneWithoutOwnedOrganizationsInput
    reportJobs?: ReportJobCreateNestedManyWithoutOrganizationInput
    members?: UserCreateNestedManyWithoutOrganizationsInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: string
    name: string
    logo?: string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    aiTemplates?: AIReplyTemplateUncheckedCreateNestedManyWithoutOrganizationInput
    locations?: LocationUncheckedCreateNestedManyWithoutOrganizationInput
    reportJobs?: ReportJobUncheckedCreateNestedManyWithoutOrganizationInput
    members?: UserUncheckedCreateNestedManyWithoutOrganizationsInput
  }

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiTemplates?: AIReplyTemplateUpdateManyWithoutOrganizationNestedInput
    locations?: LocationUpdateManyWithoutOrganizationNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedOrganizationsNestedInput
    reportJobs?: ReportJobUpdateManyWithoutOrganizationNestedInput
    members?: UserUpdateManyWithoutOrganizationsNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiTemplates?: AIReplyTemplateUncheckedUpdateManyWithoutOrganizationNestedInput
    locations?: LocationUncheckedUpdateManyWithoutOrganizationNestedInput
    reportJobs?: ReportJobUncheckedUpdateManyWithoutOrganizationNestedInput
    members?: UserUncheckedUpdateManyWithoutOrganizationsNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: string
    name: string
    logo?: string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationCreateInput = {
    id?: string
    name: string
    gmbLocationId: string
    gmbLocationName: string
    address?: string | null
    phone?: string | null
    websiteUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    timezone?: string
    isVerified?: boolean
    lastSyncedAt?: Date | string
    lastFetchedTimestamp?: Date | string | null
    autoReplyEnabled?: boolean
    autoPostEnabled?: boolean
    replyTonePreference?: $Enums.ReplyTone | null
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    logoUrl?: string | null
    gmbAccountId?: string | null
    insights?: InsightCreateNestedManyWithoutLocationInput
    organization: OrganizationCreateNestedOneWithoutLocationsInput
    posts?: PostCreateNestedManyWithoutLocationInput
    reports?: ReportCreateNestedManyWithoutLocationInput
    reviews?: ReviewCreateNestedManyWithoutLocationInput
    users?: UserCreateNestedManyWithoutLocationsInput
    searchKeywords?: SearchKeywordCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateInput = {
    id?: string
    name: string
    organizationId: string
    gmbLocationId: string
    gmbLocationName: string
    address?: string | null
    phone?: string | null
    websiteUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    timezone?: string
    isVerified?: boolean
    lastSyncedAt?: Date | string
    lastFetchedTimestamp?: Date | string | null
    autoReplyEnabled?: boolean
    autoPostEnabled?: boolean
    replyTonePreference?: $Enums.ReplyTone | null
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    logoUrl?: string | null
    gmbAccountId?: string | null
    insights?: InsightUncheckedCreateNestedManyWithoutLocationInput
    posts?: PostUncheckedCreateNestedManyWithoutLocationInput
    reports?: ReportUncheckedCreateNestedManyWithoutLocationInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutLocationInput
    users?: UserUncheckedCreateNestedManyWithoutLocationsInput
    searchKeywords?: SearchKeywordUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gmbLocationId?: StringFieldUpdateOperationsInput | string
    gmbLocationName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastSyncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastFetchedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoReplyEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoPostEnabled?: BoolFieldUpdateOperationsInput | boolean
    replyTonePreference?: NullableEnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gmbAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    insights?: InsightUpdateManyWithoutLocationNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutLocationsNestedInput
    posts?: PostUpdateManyWithoutLocationNestedInput
    reports?: ReportUpdateManyWithoutLocationNestedInput
    reviews?: ReviewUpdateManyWithoutLocationNestedInput
    users?: UserUpdateManyWithoutLocationsNestedInput
    searchKeywords?: SearchKeywordUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    gmbLocationId?: StringFieldUpdateOperationsInput | string
    gmbLocationName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastSyncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastFetchedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoReplyEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoPostEnabled?: BoolFieldUpdateOperationsInput | boolean
    replyTonePreference?: NullableEnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gmbAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    insights?: InsightUncheckedUpdateManyWithoutLocationNestedInput
    posts?: PostUncheckedUpdateManyWithoutLocationNestedInput
    reports?: ReportUncheckedUpdateManyWithoutLocationNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutLocationNestedInput
    users?: UserUncheckedUpdateManyWithoutLocationsNestedInput
    searchKeywords?: SearchKeywordUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationCreateManyInput = {
    id?: string
    name: string
    organizationId: string
    gmbLocationId: string
    gmbLocationName: string
    address?: string | null
    phone?: string | null
    websiteUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    timezone?: string
    isVerified?: boolean
    lastSyncedAt?: Date | string
    lastFetchedTimestamp?: Date | string | null
    autoReplyEnabled?: boolean
    autoPostEnabled?: boolean
    replyTonePreference?: $Enums.ReplyTone | null
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    logoUrl?: string | null
    gmbAccountId?: string | null
  }

  export type LocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gmbLocationId?: StringFieldUpdateOperationsInput | string
    gmbLocationName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastSyncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastFetchedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoReplyEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoPostEnabled?: BoolFieldUpdateOperationsInput | boolean
    replyTonePreference?: NullableEnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gmbAccountId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    gmbLocationId?: StringFieldUpdateOperationsInput | string
    gmbLocationName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastSyncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastFetchedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoReplyEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoPostEnabled?: BoolFieldUpdateOperationsInput | boolean
    replyTonePreference?: NullableEnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gmbAccountId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostCreateInput = {
    id?: string
    title: string
    content: string
    type: $Enums.PostType
    mediaUrls?: PostCreatemediaUrlsInput | string[]
    scheduledAt: Date | string
    publishedAt?: Date | string | null
    status?: $Enums.PostStatus
    eventStart?: Date | string | null
    eventEnd?: Date | string | null
    offerStart?: Date | string | null
    offerEnd?: Date | string | null
    couponCode?: string | null
    callToAction?: string | null
    recurType?: $Enums.RecurType | null
    recurEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutPostsInput
    user: UserCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateInput = {
    id?: string
    locationId: string
    userId: string
    title: string
    content: string
    type: $Enums.PostType
    mediaUrls?: PostCreatemediaUrlsInput | string[]
    scheduledAt: Date | string
    publishedAt?: Date | string | null
    status?: $Enums.PostStatus
    eventStart?: Date | string | null
    eventEnd?: Date | string | null
    offerStart?: Date | string | null
    offerEnd?: Date | string | null
    couponCode?: string | null
    callToAction?: string | null
    recurType?: $Enums.RecurType | null
    recurEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    mediaUrls?: PostUpdatemediaUrlsInput | string[]
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    eventStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offerStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offerEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    callToAction?: NullableStringFieldUpdateOperationsInput | string | null
    recurType?: NullableEnumRecurTypeFieldUpdateOperationsInput | $Enums.RecurType | null
    recurEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutPostsNestedInput
    user?: UserUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    mediaUrls?: PostUpdatemediaUrlsInput | string[]
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    eventStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offerStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offerEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    callToAction?: NullableStringFieldUpdateOperationsInput | string | null
    recurType?: NullableEnumRecurTypeFieldUpdateOperationsInput | $Enums.RecurType | null
    recurEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCreateManyInput = {
    id?: string
    locationId: string
    userId: string
    title: string
    content: string
    type: $Enums.PostType
    mediaUrls?: PostCreatemediaUrlsInput | string[]
    scheduledAt: Date | string
    publishedAt?: Date | string | null
    status?: $Enums.PostStatus
    eventStart?: Date | string | null
    eventEnd?: Date | string | null
    offerStart?: Date | string | null
    offerEnd?: Date | string | null
    couponCode?: string | null
    callToAction?: string | null
    recurType?: $Enums.RecurType | null
    recurEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    mediaUrls?: PostUpdatemediaUrlsInput | string[]
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    eventStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offerStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offerEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    callToAction?: NullableStringFieldUpdateOperationsInput | string | null
    recurType?: NullableEnumRecurTypeFieldUpdateOperationsInput | $Enums.RecurType | null
    recurEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    mediaUrls?: PostUpdatemediaUrlsInput | string[]
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    eventStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offerStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offerEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    callToAction?: NullableStringFieldUpdateOperationsInput | string | null
    recurType?: NullableEnumRecurTypeFieldUpdateOperationsInput | $Enums.RecurType | null
    recurEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateInput = {
    id?: string
    reviewId: string
    authorName: string
    authorPhoto?: string | null
    rating: number
    comment?: string | null
    createTime: Date | string
    updateTime: Date | string
    status?: $Enums.ReviewStatus
    isProcessed?: boolean
    sentiment?: $Enums.SentimentType | null
    language?: string | null
    isReplyNeeded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutReviewsInput
    replies?: ReviewReplyCreateNestedManyWithoutReviewInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    locationId: string
    reviewId: string
    authorName: string
    authorPhoto?: string | null
    rating: number
    comment?: string | null
    createTime: Date | string
    updateTime: Date | string
    status?: $Enums.ReviewStatus
    isProcessed?: boolean
    sentiment?: $Enums.SentimentType | null
    language?: string | null
    isReplyNeeded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: ReviewReplyUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createTime?: DateTimeFieldUpdateOperationsInput | Date | string
    updateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    sentiment?: NullableEnumSentimentTypeFieldUpdateOperationsInput | $Enums.SentimentType | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isReplyNeeded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutReviewsNestedInput
    replies?: ReviewReplyUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createTime?: DateTimeFieldUpdateOperationsInput | Date | string
    updateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    sentiment?: NullableEnumSentimentTypeFieldUpdateOperationsInput | $Enums.SentimentType | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isReplyNeeded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: ReviewReplyUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ReviewCreateManyInput = {
    id?: string
    locationId: string
    reviewId: string
    authorName: string
    authorPhoto?: string | null
    rating: number
    comment?: string | null
    createTime: Date | string
    updateTime: Date | string
    status?: $Enums.ReviewStatus
    isProcessed?: boolean
    sentiment?: $Enums.SentimentType | null
    language?: string | null
    isReplyNeeded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createTime?: DateTimeFieldUpdateOperationsInput | Date | string
    updateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    sentiment?: NullableEnumSentimentTypeFieldUpdateOperationsInput | $Enums.SentimentType | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isReplyNeeded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createTime?: DateTimeFieldUpdateOperationsInput | Date | string
    updateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    sentiment?: NullableEnumSentimentTypeFieldUpdateOperationsInput | $Enums.SentimentType | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isReplyNeeded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewReplyCreateInput = {
    id?: string
    content: string
    source: $Enums.ReplySource
    tone?: $Enums.ReplyTone
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiTemplate?: AIReplyTemplateCreateNestedOneWithoutRepliesInput
    review: ReviewCreateNestedOneWithoutRepliesInput
    user?: UserCreateNestedOneWithoutReviewRepliesInput
  }

  export type ReviewReplyUncheckedCreateInput = {
    id?: string
    reviewId: string
    userId?: string | null
    content: string
    source: $Enums.ReplySource
    tone?: $Enums.ReplyTone
    isPublished?: boolean
    publishedAt?: Date | string | null
    aiTemplateId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewReplyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    source?: EnumReplySourceFieldUpdateOperationsInput | $Enums.ReplySource
    tone?: EnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiTemplate?: AIReplyTemplateUpdateOneWithoutRepliesNestedInput
    review?: ReviewUpdateOneRequiredWithoutRepliesNestedInput
    user?: UserUpdateOneWithoutReviewRepliesNestedInput
  }

  export type ReviewReplyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    source?: EnumReplySourceFieldUpdateOperationsInput | $Enums.ReplySource
    tone?: EnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewReplyCreateManyInput = {
    id?: string
    reviewId: string
    userId?: string | null
    content: string
    source: $Enums.ReplySource
    tone?: $Enums.ReplyTone
    isPublished?: boolean
    publishedAt?: Date | string | null
    aiTemplateId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewReplyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    source?: EnumReplySourceFieldUpdateOperationsInput | $Enums.ReplySource
    tone?: EnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewReplyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    source?: EnumReplySourceFieldUpdateOperationsInput | $Enums.ReplySource
    tone?: EnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIReplyTemplateCreateInput = {
    id?: string
    name: string
    content: string
    tone?: $Enums.ReplyTone
    sentiment: $Enums.SentimentType
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutAiTemplatesInput
    replies?: ReviewReplyCreateNestedManyWithoutAiTemplateInput
  }

  export type AIReplyTemplateUncheckedCreateInput = {
    id?: string
    organizationId: string
    name: string
    content: string
    tone?: $Enums.ReplyTone
    sentiment: $Enums.SentimentType
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: ReviewReplyUncheckedCreateNestedManyWithoutAiTemplateInput
  }

  export type AIReplyTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: EnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone
    sentiment?: EnumSentimentTypeFieldUpdateOperationsInput | $Enums.SentimentType
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutAiTemplatesNestedInput
    replies?: ReviewReplyUpdateManyWithoutAiTemplateNestedInput
  }

  export type AIReplyTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: EnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone
    sentiment?: EnumSentimentTypeFieldUpdateOperationsInput | $Enums.SentimentType
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: ReviewReplyUncheckedUpdateManyWithoutAiTemplateNestedInput
  }

  export type AIReplyTemplateCreateManyInput = {
    id?: string
    organizationId: string
    name: string
    content: string
    tone?: $Enums.ReplyTone
    sentiment: $Enums.SentimentType
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIReplyTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: EnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone
    sentiment?: EnumSentimentTypeFieldUpdateOperationsInput | $Enums.SentimentType
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIReplyTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: EnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone
    sentiment?: EnumSentimentTypeFieldUpdateOperationsInput | $Enums.SentimentType
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightCreateInput = {
    id?: string
    date: Date | string
    type: $Enums.InsightType
    value: number
    createdAt?: Date | string
    location: LocationCreateNestedOneWithoutInsightsInput
  }

  export type InsightUncheckedCreateInput = {
    id?: string
    locationId: string
    date: Date | string
    type: $Enums.InsightType
    value: number
    createdAt?: Date | string
  }

  export type InsightUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumInsightTypeFieldUpdateOperationsInput | $Enums.InsightType
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutInsightsNestedInput
  }

  export type InsightUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumInsightTypeFieldUpdateOperationsInput | $Enums.InsightType
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightCreateManyInput = {
    id?: string
    locationId: string
    date: Date | string
    type: $Enums.InsightType
    value: number
    createdAt?: Date | string
  }

  export type InsightUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumInsightTypeFieldUpdateOperationsInput | $Enums.InsightType
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumInsightTypeFieldUpdateOperationsInput | $Enums.InsightType
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    reportType: $Enums.ReportType
    fileUrl?: string | null
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateInput = {
    id?: string
    locationId: string
    name: string
    startDate: Date | string
    endDate: Date | string
    reportType: $Enums.ReportType
    fileUrl?: string | null
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateManyInput = {
    id?: string
    locationId: string
    name: string
    startDate: Date | string
    endDate: Date | string
    reportType: $Enums.ReportType
    fileUrl?: string | null
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportJobCreateInput = {
    id?: string
    name: string
    locations?: ReportJobCreatelocationsInput | string[]
    frequency: $Enums.ReportFrequency
    emailRecipients?: ReportJobCreateemailRecipientsInput | string[]
    isActive?: boolean
    lastRunAt?: Date | string | null
    nextRunAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutReportJobsInput
  }

  export type ReportJobUncheckedCreateInput = {
    id?: string
    organizationId: string
    name: string
    locations?: ReportJobCreatelocationsInput | string[]
    frequency: $Enums.ReportFrequency
    emailRecipients?: ReportJobCreateemailRecipientsInput | string[]
    isActive?: boolean
    lastRunAt?: Date | string | null
    nextRunAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    locations?: ReportJobUpdatelocationsInput | string[]
    frequency?: EnumReportFrequencyFieldUpdateOperationsInput | $Enums.ReportFrequency
    emailRecipients?: ReportJobUpdateemailRecipientsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutReportJobsNestedInput
  }

  export type ReportJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    locations?: ReportJobUpdatelocationsInput | string[]
    frequency?: EnumReportFrequencyFieldUpdateOperationsInput | $Enums.ReportFrequency
    emailRecipients?: ReportJobUpdateemailRecipientsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportJobCreateManyInput = {
    id?: string
    organizationId: string
    name: string
    locations?: ReportJobCreatelocationsInput | string[]
    frequency: $Enums.ReportFrequency
    emailRecipients?: ReportJobCreateemailRecipientsInput | string[]
    isActive?: boolean
    lastRunAt?: Date | string | null
    nextRunAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    locations?: ReportJobUpdatelocationsInput | string[]
    frequency?: EnumReportFrequencyFieldUpdateOperationsInput | $Enums.ReportFrequency
    emailRecipients?: ReportJobUpdateemailRecipientsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    locations?: ReportJobUpdatelocationsInput | string[]
    frequency?: EnumReportFrequencyFieldUpdateOperationsInput | $Enums.ReportFrequency
    emailRecipients?: ReportJobUpdateemailRecipientsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchKeywordCreateInput = {
    id?: string
    keyword: string
    latitude: number
    longitude: number
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutSearchKeywordsInput
    rankResults?: RankTrackingResultCreateNestedManyWithoutKeywordInput
  }

  export type SearchKeywordUncheckedCreateInput = {
    id?: string
    keyword: string
    locationId: string
    latitude: number
    longitude: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rankResults?: RankTrackingResultUncheckedCreateNestedManyWithoutKeywordInput
  }

  export type SearchKeywordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutSearchKeywordsNestedInput
    rankResults?: RankTrackingResultUpdateManyWithoutKeywordNestedInput
  }

  export type SearchKeywordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rankResults?: RankTrackingResultUncheckedUpdateManyWithoutKeywordNestedInput
  }

  export type SearchKeywordCreateManyInput = {
    id?: string
    keyword: string
    locationId: string
    latitude: number
    longitude: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SearchKeywordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchKeywordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RankTrackingResultCreateInput = {
    id?: string
    rankPosition?: number | null
    searchDate?: Date | string
    searchUrl?: string | null
    businessUrl?: string | null
    businessName?: string | null
    htmlSnapshot?: string | null
    createdAt?: Date | string
    keyword: SearchKeywordCreateNestedOneWithoutRankResultsInput
  }

  export type RankTrackingResultUncheckedCreateInput = {
    id?: string
    keywordId: string
    rankPosition?: number | null
    searchDate?: Date | string
    searchUrl?: string | null
    businessUrl?: string | null
    businessName?: string | null
    htmlSnapshot?: string | null
    createdAt?: Date | string
  }

  export type RankTrackingResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rankPosition?: NullableIntFieldUpdateOperationsInput | number | null
    searchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    searchUrl?: NullableStringFieldUpdateOperationsInput | string | null
    businessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    htmlSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    keyword?: SearchKeywordUpdateOneRequiredWithoutRankResultsNestedInput
  }

  export type RankTrackingResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    keywordId?: StringFieldUpdateOperationsInput | string
    rankPosition?: NullableIntFieldUpdateOperationsInput | number | null
    searchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    searchUrl?: NullableStringFieldUpdateOperationsInput | string | null
    businessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    htmlSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RankTrackingResultCreateManyInput = {
    id?: string
    keywordId: string
    rankPosition?: number | null
    searchDate?: Date | string
    searchUrl?: string | null
    businessUrl?: string | null
    businessName?: string | null
    htmlSnapshot?: string | null
    createdAt?: Date | string
  }

  export type RankTrackingResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rankPosition?: NullableIntFieldUpdateOperationsInput | number | null
    searchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    searchUrl?: NullableStringFieldUpdateOperationsInput | string | null
    businessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    htmlSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RankTrackingResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    keywordId?: StringFieldUpdateOperationsInput | string
    rankPosition?: NullableIntFieldUpdateOperationsInput | number | null
    searchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    searchUrl?: NullableStringFieldUpdateOperationsInput | string | null
    businessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    htmlSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumSubscriptionStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionStatusNullableFilter<$PrismaModel> | $Enums.SubscriptionStatus | null
  }

  export type EnumSubscriptionPlanNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionPlanNullableFilter<$PrismaModel> | $Enums.SubscriptionPlan | null
  }

  export type OrganizationListRelationFilter = {
    every?: OrganizationWhereInput
    some?: OrganizationWhereInput
    none?: OrganizationWhereInput
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type ReviewReplyListRelationFilter = {
    every?: ReviewReplyWhereInput
    some?: ReviewReplyWhereInput
    none?: ReviewReplyWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type LocationListRelationFilter = {
    every?: LocationWhereInput
    some?: LocationWhereInput
    none?: LocationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type OrganizationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewReplyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    emailVerificationToken?: SortOrder
    password?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    googleAccessToken?: SortOrder
    googleRefreshToken?: SortOrder
    googleTokenExpiresAt?: SortOrder
    subscriptionId?: SortOrder
    subscriptionStatus?: SortOrder
    subscriptionPlan?: SortOrder
    trialStartedAt?: SortOrder
    trialEndsAt?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    razorpayCustomerId?: SortOrder
    razorpayPaymentId?: SortOrder
    razorpayOrderId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    emailVerificationToken?: SortOrder
    password?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    googleAccessToken?: SortOrder
    googleRefreshToken?: SortOrder
    googleTokenExpiresAt?: SortOrder
    subscriptionId?: SortOrder
    subscriptionStatus?: SortOrder
    subscriptionPlan?: SortOrder
    trialStartedAt?: SortOrder
    trialEndsAt?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    razorpayCustomerId?: SortOrder
    razorpayPaymentId?: SortOrder
    razorpayOrderId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    emailVerificationToken?: SortOrder
    password?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    googleAccessToken?: SortOrder
    googleRefreshToken?: SortOrder
    googleTokenExpiresAt?: SortOrder
    subscriptionId?: SortOrder
    subscriptionStatus?: SortOrder
    subscriptionPlan?: SortOrder
    trialStartedAt?: SortOrder
    trialEndsAt?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    razorpayCustomerId?: SortOrder
    razorpayPaymentId?: SortOrder
    razorpayOrderId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumSubscriptionStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusNullableFilter<$PrismaModel>
  }

  export type EnumSubscriptionPlanNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionPlanNullableWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionPlan | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionPlanNullableFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionPlanNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AIReplyTemplateListRelationFilter = {
    every?: AIReplyTemplateWhereInput
    some?: AIReplyTemplateWhereInput
    none?: AIReplyTemplateWhereInput
  }

  export type ReportJobListRelationFilter = {
    every?: ReportJobWhereInput
    some?: ReportJobWhereInput
    none?: ReportJobWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type AIReplyTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportJobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumReplyToneNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ReplyTone | EnumReplyToneFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReplyTone[] | ListEnumReplyToneFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ReplyTone[] | ListEnumReplyToneFieldRefInput<$PrismaModel> | null
    not?: NestedEnumReplyToneNullableFilter<$PrismaModel> | $Enums.ReplyTone | null
  }

  export type InsightListRelationFilter = {
    every?: InsightWhereInput
    some?: InsightWhereInput
    none?: InsightWhereInput
  }

  export type OrganizationScalarRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type ReportListRelationFilter = {
    every?: ReportWhereInput
    some?: ReportWhereInput
    none?: ReportWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type SearchKeywordListRelationFilter = {
    every?: SearchKeywordWhereInput
    some?: SearchKeywordWhereInput
    none?: SearchKeywordWhereInput
  }

  export type InsightOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SearchKeywordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    organizationId?: SortOrder
    gmbLocationId?: SortOrder
    gmbLocationName?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    websiteUrl?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    timezone?: SortOrder
    isVerified?: SortOrder
    lastSyncedAt?: SortOrder
    lastFetchedTimestamp?: SortOrder
    autoReplyEnabled?: SortOrder
    autoPostEnabled?: SortOrder
    replyTonePreference?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    logoUrl?: SortOrder
    gmbAccountId?: SortOrder
  }

  export type LocationAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    organizationId?: SortOrder
    gmbLocationId?: SortOrder
    gmbLocationName?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    websiteUrl?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    timezone?: SortOrder
    isVerified?: SortOrder
    lastSyncedAt?: SortOrder
    lastFetchedTimestamp?: SortOrder
    autoReplyEnabled?: SortOrder
    autoPostEnabled?: SortOrder
    replyTonePreference?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    logoUrl?: SortOrder
    gmbAccountId?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    organizationId?: SortOrder
    gmbLocationId?: SortOrder
    gmbLocationName?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    websiteUrl?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    timezone?: SortOrder
    isVerified?: SortOrder
    lastSyncedAt?: SortOrder
    lastFetchedTimestamp?: SortOrder
    autoReplyEnabled?: SortOrder
    autoPostEnabled?: SortOrder
    replyTonePreference?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    logoUrl?: SortOrder
    gmbAccountId?: SortOrder
  }

  export type LocationSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumReplyToneNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReplyTone | EnumReplyToneFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReplyTone[] | ListEnumReplyToneFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ReplyTone[] | ListEnumReplyToneFieldRefInput<$PrismaModel> | null
    not?: NestedEnumReplyToneNullableWithAggregatesFilter<$PrismaModel> | $Enums.ReplyTone | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumReplyToneNullableFilter<$PrismaModel>
    _max?: NestedEnumReplyToneNullableFilter<$PrismaModel>
  }

  export type EnumPostTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PostType | EnumPostTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPostTypeFilter<$PrismaModel> | $Enums.PostType
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumPostStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusFilter<$PrismaModel> | $Enums.PostStatus
  }

  export type EnumRecurTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurType | EnumRecurTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.RecurType[] | ListEnumRecurTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RecurType[] | ListEnumRecurTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRecurTypeNullableFilter<$PrismaModel> | $Enums.RecurType | null
  }

  export type LocationScalarRelationFilter = {
    is?: LocationWhereInput
    isNot?: LocationWhereInput
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    mediaUrls?: SortOrder
    scheduledAt?: SortOrder
    publishedAt?: SortOrder
    status?: SortOrder
    eventStart?: SortOrder
    eventEnd?: SortOrder
    offerStart?: SortOrder
    offerEnd?: SortOrder
    couponCode?: SortOrder
    callToAction?: SortOrder
    recurType?: SortOrder
    recurEndsAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    scheduledAt?: SortOrder
    publishedAt?: SortOrder
    status?: SortOrder
    eventStart?: SortOrder
    eventEnd?: SortOrder
    offerStart?: SortOrder
    offerEnd?: SortOrder
    couponCode?: SortOrder
    callToAction?: SortOrder
    recurType?: SortOrder
    recurEndsAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    scheduledAt?: SortOrder
    publishedAt?: SortOrder
    status?: SortOrder
    eventStart?: SortOrder
    eventEnd?: SortOrder
    offerStart?: SortOrder
    offerEnd?: SortOrder
    couponCode?: SortOrder
    callToAction?: SortOrder
    recurType?: SortOrder
    recurEndsAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPostTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostType | EnumPostTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPostTypeWithAggregatesFilter<$PrismaModel> | $Enums.PostType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostTypeFilter<$PrismaModel>
    _max?: NestedEnumPostTypeFilter<$PrismaModel>
  }

  export type EnumPostStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusWithAggregatesFilter<$PrismaModel> | $Enums.PostStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostStatusFilter<$PrismaModel>
    _max?: NestedEnumPostStatusFilter<$PrismaModel>
  }

  export type EnumRecurTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurType | EnumRecurTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.RecurType[] | ListEnumRecurTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RecurType[] | ListEnumRecurTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRecurTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.RecurType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRecurTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumRecurTypeNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumReviewStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewStatusFilter<$PrismaModel> | $Enums.ReviewStatus
  }

  export type EnumSentimentTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SentimentType | EnumSentimentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.SentimentType[] | ListEnumSentimentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SentimentType[] | ListEnumSentimentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSentimentTypeNullableFilter<$PrismaModel> | $Enums.SentimentType | null
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    reviewId?: SortOrder
    authorName?: SortOrder
    authorPhoto?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createTime?: SortOrder
    updateTime?: SortOrder
    status?: SortOrder
    isProcessed?: SortOrder
    sentiment?: SortOrder
    language?: SortOrder
    isReplyNeeded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    reviewId?: SortOrder
    authorName?: SortOrder
    authorPhoto?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createTime?: SortOrder
    updateTime?: SortOrder
    status?: SortOrder
    isProcessed?: SortOrder
    sentiment?: SortOrder
    language?: SortOrder
    isReplyNeeded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    reviewId?: SortOrder
    authorName?: SortOrder
    authorPhoto?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createTime?: SortOrder
    updateTime?: SortOrder
    status?: SortOrder
    isProcessed?: SortOrder
    sentiment?: SortOrder
    language?: SortOrder
    isReplyNeeded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumReviewStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReviewStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReviewStatusFilter<$PrismaModel>
    _max?: NestedEnumReviewStatusFilter<$PrismaModel>
  }

  export type EnumSentimentTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SentimentType | EnumSentimentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.SentimentType[] | ListEnumSentimentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SentimentType[] | ListEnumSentimentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSentimentTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.SentimentType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSentimentTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumSentimentTypeNullableFilter<$PrismaModel>
  }

  export type EnumReplySourceFilter<$PrismaModel = never> = {
    equals?: $Enums.ReplySource | EnumReplySourceFieldRefInput<$PrismaModel>
    in?: $Enums.ReplySource[] | ListEnumReplySourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReplySource[] | ListEnumReplySourceFieldRefInput<$PrismaModel>
    not?: NestedEnumReplySourceFilter<$PrismaModel> | $Enums.ReplySource
  }

  export type EnumReplyToneFilter<$PrismaModel = never> = {
    equals?: $Enums.ReplyTone | EnumReplyToneFieldRefInput<$PrismaModel>
    in?: $Enums.ReplyTone[] | ListEnumReplyToneFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReplyTone[] | ListEnumReplyToneFieldRefInput<$PrismaModel>
    not?: NestedEnumReplyToneFilter<$PrismaModel> | $Enums.ReplyTone
  }

  export type AIReplyTemplateNullableScalarRelationFilter = {
    is?: AIReplyTemplateWhereInput | null
    isNot?: AIReplyTemplateWhereInput | null
  }

  export type ReviewScalarRelationFilter = {
    is?: ReviewWhereInput
    isNot?: ReviewWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ReviewReplyCountOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    source?: SortOrder
    tone?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrder
    aiTemplateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewReplyMaxOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    source?: SortOrder
    tone?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrder
    aiTemplateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewReplyMinOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    source?: SortOrder
    tone?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrder
    aiTemplateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumReplySourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReplySource | EnumReplySourceFieldRefInput<$PrismaModel>
    in?: $Enums.ReplySource[] | ListEnumReplySourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReplySource[] | ListEnumReplySourceFieldRefInput<$PrismaModel>
    not?: NestedEnumReplySourceWithAggregatesFilter<$PrismaModel> | $Enums.ReplySource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReplySourceFilter<$PrismaModel>
    _max?: NestedEnumReplySourceFilter<$PrismaModel>
  }

  export type EnumReplyToneWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReplyTone | EnumReplyToneFieldRefInput<$PrismaModel>
    in?: $Enums.ReplyTone[] | ListEnumReplyToneFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReplyTone[] | ListEnumReplyToneFieldRefInput<$PrismaModel>
    not?: NestedEnumReplyToneWithAggregatesFilter<$PrismaModel> | $Enums.ReplyTone
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReplyToneFilter<$PrismaModel>
    _max?: NestedEnumReplyToneFilter<$PrismaModel>
  }

  export type EnumSentimentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SentimentType | EnumSentimentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SentimentType[] | ListEnumSentimentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SentimentType[] | ListEnumSentimentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSentimentTypeFilter<$PrismaModel> | $Enums.SentimentType
  }

  export type AIReplyTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    content?: SortOrder
    tone?: SortOrder
    sentiment?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIReplyTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    content?: SortOrder
    tone?: SortOrder
    sentiment?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIReplyTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    content?: SortOrder
    tone?: SortOrder
    sentiment?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSentimentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SentimentType | EnumSentimentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SentimentType[] | ListEnumSentimentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SentimentType[] | ListEnumSentimentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSentimentTypeWithAggregatesFilter<$PrismaModel> | $Enums.SentimentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSentimentTypeFilter<$PrismaModel>
    _max?: NestedEnumSentimentTypeFilter<$PrismaModel>
  }

  export type EnumInsightTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightType | EnumInsightTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InsightType[] | ListEnumInsightTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightType[] | ListEnumInsightTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightTypeFilter<$PrismaModel> | $Enums.InsightType
  }

  export type InsightLocationIdDateTypeCompoundUniqueInput = {
    locationId: string
    date: Date | string
    type: $Enums.InsightType
  }

  export type InsightCountOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
  }

  export type InsightAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type InsightMaxOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
  }

  export type InsightMinOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
  }

  export type InsightSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type EnumInsightTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightType | EnumInsightTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InsightType[] | ListEnumInsightTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightType[] | ListEnumInsightTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightTypeWithAggregatesFilter<$PrismaModel> | $Enums.InsightType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInsightTypeFilter<$PrismaModel>
    _max?: NestedEnumInsightTypeFilter<$PrismaModel>
  }

  export type EnumReportTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportTypeFilter<$PrismaModel> | $Enums.ReportType
  }

  export type EnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reportType?: SortOrder
    fileUrl?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reportType?: SortOrder
    fileUrl?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reportType?: SortOrder
    fileUrl?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumReportTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReportType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportTypeFilter<$PrismaModel>
    _max?: NestedEnumReportTypeFilter<$PrismaModel>
  }

  export type EnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type EnumReportFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportFrequency | EnumReportFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.ReportFrequency[] | ListEnumReportFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportFrequency[] | ListEnumReportFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumReportFrequencyFilter<$PrismaModel> | $Enums.ReportFrequency
  }

  export type ReportJobCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    locations?: SortOrder
    frequency?: SortOrder
    emailRecipients?: SortOrder
    isActive?: SortOrder
    lastRunAt?: SortOrder
    nextRunAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportJobMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    frequency?: SortOrder
    isActive?: SortOrder
    lastRunAt?: SortOrder
    nextRunAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportJobMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    frequency?: SortOrder
    isActive?: SortOrder
    lastRunAt?: SortOrder
    nextRunAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumReportFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportFrequency | EnumReportFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.ReportFrequency[] | ListEnumReportFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportFrequency[] | ListEnumReportFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumReportFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.ReportFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportFrequencyFilter<$PrismaModel>
    _max?: NestedEnumReportFrequencyFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type RankTrackingResultListRelationFilter = {
    every?: RankTrackingResultWhereInput
    some?: RankTrackingResultWhereInput
    none?: RankTrackingResultWhereInput
  }

  export type RankTrackingResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SearchKeywordKeywordLocationIdCompoundUniqueInput = {
    keyword: string
    locationId: string
  }

  export type SearchKeywordCountOrderByAggregateInput = {
    id?: SortOrder
    keyword?: SortOrder
    locationId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SearchKeywordAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type SearchKeywordMaxOrderByAggregateInput = {
    id?: SortOrder
    keyword?: SortOrder
    locationId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SearchKeywordMinOrderByAggregateInput = {
    id?: SortOrder
    keyword?: SortOrder
    locationId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SearchKeywordSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type SearchKeywordScalarRelationFilter = {
    is?: SearchKeywordWhereInput
    isNot?: SearchKeywordWhereInput
  }

  export type RankTrackingResultCountOrderByAggregateInput = {
    id?: SortOrder
    keywordId?: SortOrder
    rankPosition?: SortOrder
    searchDate?: SortOrder
    searchUrl?: SortOrder
    businessUrl?: SortOrder
    businessName?: SortOrder
    htmlSnapshot?: SortOrder
    createdAt?: SortOrder
  }

  export type RankTrackingResultAvgOrderByAggregateInput = {
    rankPosition?: SortOrder
  }

  export type RankTrackingResultMaxOrderByAggregateInput = {
    id?: SortOrder
    keywordId?: SortOrder
    rankPosition?: SortOrder
    searchDate?: SortOrder
    searchUrl?: SortOrder
    businessUrl?: SortOrder
    businessName?: SortOrder
    htmlSnapshot?: SortOrder
    createdAt?: SortOrder
  }

  export type RankTrackingResultMinOrderByAggregateInput = {
    id?: SortOrder
    keywordId?: SortOrder
    rankPosition?: SortOrder
    searchDate?: SortOrder
    searchUrl?: SortOrder
    businessUrl?: SortOrder
    businessName?: SortOrder
    htmlSnapshot?: SortOrder
    createdAt?: SortOrder
  }

  export type RankTrackingResultSumOrderByAggregateInput = {
    rankPosition?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type OrganizationCreateNestedManyWithoutOwnerInput = {
    create?: XOR<OrganizationCreateWithoutOwnerInput, OrganizationUncheckedCreateWithoutOwnerInput> | OrganizationCreateWithoutOwnerInput[] | OrganizationUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OrganizationCreateOrConnectWithoutOwnerInput | OrganizationCreateOrConnectWithoutOwnerInput[]
    createMany?: OrganizationCreateManyOwnerInputEnvelope
    connect?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutUserInput = {
    create?: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput> | PostCreateWithoutUserInput[] | PostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostCreateOrConnectWithoutUserInput | PostCreateOrConnectWithoutUserInput[]
    createMany?: PostCreateManyUserInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type ReviewReplyCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewReplyCreateWithoutUserInput, ReviewReplyUncheckedCreateWithoutUserInput> | ReviewReplyCreateWithoutUserInput[] | ReviewReplyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewReplyCreateOrConnectWithoutUserInput | ReviewReplyCreateOrConnectWithoutUserInput[]
    createMany?: ReviewReplyCreateManyUserInputEnvelope
    connect?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type LocationCreateNestedManyWithoutUsersInput = {
    create?: XOR<LocationCreateWithoutUsersInput, LocationUncheckedCreateWithoutUsersInput> | LocationCreateWithoutUsersInput[] | LocationUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutUsersInput | LocationCreateOrConnectWithoutUsersInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type OrganizationCreateNestedManyWithoutMembersInput = {
    create?: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput> | OrganizationCreateWithoutMembersInput[] | OrganizationUncheckedCreateWithoutMembersInput[]
    connectOrCreate?: OrganizationCreateOrConnectWithoutMembersInput | OrganizationCreateOrConnectWithoutMembersInput[]
    connect?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
  }

  export type OrganizationUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<OrganizationCreateWithoutOwnerInput, OrganizationUncheckedCreateWithoutOwnerInput> | OrganizationCreateWithoutOwnerInput[] | OrganizationUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OrganizationCreateOrConnectWithoutOwnerInput | OrganizationCreateOrConnectWithoutOwnerInput[]
    createMany?: OrganizationCreateManyOwnerInputEnvelope
    connect?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput> | PostCreateWithoutUserInput[] | PostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostCreateOrConnectWithoutUserInput | PostCreateOrConnectWithoutUserInput[]
    createMany?: PostCreateManyUserInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type ReviewReplyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewReplyCreateWithoutUserInput, ReviewReplyUncheckedCreateWithoutUserInput> | ReviewReplyCreateWithoutUserInput[] | ReviewReplyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewReplyCreateOrConnectWithoutUserInput | ReviewReplyCreateOrConnectWithoutUserInput[]
    createMany?: ReviewReplyCreateManyUserInputEnvelope
    connect?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type LocationUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<LocationCreateWithoutUsersInput, LocationUncheckedCreateWithoutUsersInput> | LocationCreateWithoutUsersInput[] | LocationUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutUsersInput | LocationCreateOrConnectWithoutUsersInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type OrganizationUncheckedCreateNestedManyWithoutMembersInput = {
    create?: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput> | OrganizationCreateWithoutMembersInput[] | OrganizationUncheckedCreateWithoutMembersInput[]
    connectOrCreate?: OrganizationCreateOrConnectWithoutMembersInput | OrganizationCreateOrConnectWithoutMembersInput[]
    connect?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableEnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus | null
  }

  export type NullableEnumSubscriptionPlanFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionPlan | null
  }

  export type OrganizationUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<OrganizationCreateWithoutOwnerInput, OrganizationUncheckedCreateWithoutOwnerInput> | OrganizationCreateWithoutOwnerInput[] | OrganizationUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OrganizationCreateOrConnectWithoutOwnerInput | OrganizationCreateOrConnectWithoutOwnerInput[]
    upsert?: OrganizationUpsertWithWhereUniqueWithoutOwnerInput | OrganizationUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: OrganizationCreateManyOwnerInputEnvelope
    set?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
    disconnect?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
    delete?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
    connect?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
    update?: OrganizationUpdateWithWhereUniqueWithoutOwnerInput | OrganizationUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: OrganizationUpdateManyWithWhereWithoutOwnerInput | OrganizationUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: OrganizationScalarWhereInput | OrganizationScalarWhereInput[]
  }

  export type PostUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput> | PostCreateWithoutUserInput[] | PostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostCreateOrConnectWithoutUserInput | PostCreateOrConnectWithoutUserInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutUserInput | PostUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostCreateManyUserInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutUserInput | PostUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostUpdateManyWithWhereWithoutUserInput | PostUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type ReviewReplyUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewReplyCreateWithoutUserInput, ReviewReplyUncheckedCreateWithoutUserInput> | ReviewReplyCreateWithoutUserInput[] | ReviewReplyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewReplyCreateOrConnectWithoutUserInput | ReviewReplyCreateOrConnectWithoutUserInput[]
    upsert?: ReviewReplyUpsertWithWhereUniqueWithoutUserInput | ReviewReplyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewReplyCreateManyUserInputEnvelope
    set?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    disconnect?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    delete?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    connect?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    update?: ReviewReplyUpdateWithWhereUniqueWithoutUserInput | ReviewReplyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewReplyUpdateManyWithWhereWithoutUserInput | ReviewReplyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewReplyScalarWhereInput | ReviewReplyScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type LocationUpdateManyWithoutUsersNestedInput = {
    create?: XOR<LocationCreateWithoutUsersInput, LocationUncheckedCreateWithoutUsersInput> | LocationCreateWithoutUsersInput[] | LocationUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutUsersInput | LocationCreateOrConnectWithoutUsersInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutUsersInput | LocationUpsertWithWhereUniqueWithoutUsersInput[]
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutUsersInput | LocationUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutUsersInput | LocationUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type OrganizationUpdateManyWithoutMembersNestedInput = {
    create?: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput> | OrganizationCreateWithoutMembersInput[] | OrganizationUncheckedCreateWithoutMembersInput[]
    connectOrCreate?: OrganizationCreateOrConnectWithoutMembersInput | OrganizationCreateOrConnectWithoutMembersInput[]
    upsert?: OrganizationUpsertWithWhereUniqueWithoutMembersInput | OrganizationUpsertWithWhereUniqueWithoutMembersInput[]
    set?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
    disconnect?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
    delete?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
    connect?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
    update?: OrganizationUpdateWithWhereUniqueWithoutMembersInput | OrganizationUpdateWithWhereUniqueWithoutMembersInput[]
    updateMany?: OrganizationUpdateManyWithWhereWithoutMembersInput | OrganizationUpdateManyWithWhereWithoutMembersInput[]
    deleteMany?: OrganizationScalarWhereInput | OrganizationScalarWhereInput[]
  }

  export type OrganizationUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<OrganizationCreateWithoutOwnerInput, OrganizationUncheckedCreateWithoutOwnerInput> | OrganizationCreateWithoutOwnerInput[] | OrganizationUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OrganizationCreateOrConnectWithoutOwnerInput | OrganizationCreateOrConnectWithoutOwnerInput[]
    upsert?: OrganizationUpsertWithWhereUniqueWithoutOwnerInput | OrganizationUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: OrganizationCreateManyOwnerInputEnvelope
    set?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
    disconnect?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
    delete?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
    connect?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
    update?: OrganizationUpdateWithWhereUniqueWithoutOwnerInput | OrganizationUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: OrganizationUpdateManyWithWhereWithoutOwnerInput | OrganizationUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: OrganizationScalarWhereInput | OrganizationScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput> | PostCreateWithoutUserInput[] | PostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostCreateOrConnectWithoutUserInput | PostCreateOrConnectWithoutUserInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutUserInput | PostUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostCreateManyUserInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutUserInput | PostUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostUpdateManyWithWhereWithoutUserInput | PostUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type ReviewReplyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewReplyCreateWithoutUserInput, ReviewReplyUncheckedCreateWithoutUserInput> | ReviewReplyCreateWithoutUserInput[] | ReviewReplyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewReplyCreateOrConnectWithoutUserInput | ReviewReplyCreateOrConnectWithoutUserInput[]
    upsert?: ReviewReplyUpsertWithWhereUniqueWithoutUserInput | ReviewReplyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewReplyCreateManyUserInputEnvelope
    set?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    disconnect?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    delete?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    connect?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    update?: ReviewReplyUpdateWithWhereUniqueWithoutUserInput | ReviewReplyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewReplyUpdateManyWithWhereWithoutUserInput | ReviewReplyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewReplyScalarWhereInput | ReviewReplyScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type LocationUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<LocationCreateWithoutUsersInput, LocationUncheckedCreateWithoutUsersInput> | LocationCreateWithoutUsersInput[] | LocationUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutUsersInput | LocationCreateOrConnectWithoutUsersInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutUsersInput | LocationUpsertWithWhereUniqueWithoutUsersInput[]
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutUsersInput | LocationUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutUsersInput | LocationUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type OrganizationUncheckedUpdateManyWithoutMembersNestedInput = {
    create?: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput> | OrganizationCreateWithoutMembersInput[] | OrganizationUncheckedCreateWithoutMembersInput[]
    connectOrCreate?: OrganizationCreateOrConnectWithoutMembersInput | OrganizationCreateOrConnectWithoutMembersInput[]
    upsert?: OrganizationUpsertWithWhereUniqueWithoutMembersInput | OrganizationUpsertWithWhereUniqueWithoutMembersInput[]
    set?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
    disconnect?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
    delete?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
    connect?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
    update?: OrganizationUpdateWithWhereUniqueWithoutMembersInput | OrganizationUpdateWithWhereUniqueWithoutMembersInput[]
    updateMany?: OrganizationUpdateManyWithWhereWithoutMembersInput | OrganizationUpdateManyWithWhereWithoutMembersInput[]
    deleteMany?: OrganizationScalarWhereInput | OrganizationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type AIReplyTemplateCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<AIReplyTemplateCreateWithoutOrganizationInput, AIReplyTemplateUncheckedCreateWithoutOrganizationInput> | AIReplyTemplateCreateWithoutOrganizationInput[] | AIReplyTemplateUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AIReplyTemplateCreateOrConnectWithoutOrganizationInput | AIReplyTemplateCreateOrConnectWithoutOrganizationInput[]
    createMany?: AIReplyTemplateCreateManyOrganizationInputEnvelope
    connect?: AIReplyTemplateWhereUniqueInput | AIReplyTemplateWhereUniqueInput[]
  }

  export type LocationCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<LocationCreateWithoutOrganizationInput, LocationUncheckedCreateWithoutOrganizationInput> | LocationCreateWithoutOrganizationInput[] | LocationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutOrganizationInput | LocationCreateOrConnectWithoutOrganizationInput[]
    createMany?: LocationCreateManyOrganizationInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutOwnedOrganizationsInput = {
    create?: XOR<UserCreateWithoutOwnedOrganizationsInput, UserUncheckedCreateWithoutOwnedOrganizationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedOrganizationsInput
    connect?: UserWhereUniqueInput
  }

  export type ReportJobCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ReportJobCreateWithoutOrganizationInput, ReportJobUncheckedCreateWithoutOrganizationInput> | ReportJobCreateWithoutOrganizationInput[] | ReportJobUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ReportJobCreateOrConnectWithoutOrganizationInput | ReportJobCreateOrConnectWithoutOrganizationInput[]
    createMany?: ReportJobCreateManyOrganizationInputEnvelope
    connect?: ReportJobWhereUniqueInput | ReportJobWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<UserCreateWithoutOrganizationsInput, UserUncheckedCreateWithoutOrganizationsInput> | UserCreateWithoutOrganizationsInput[] | UserUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationsInput | UserCreateOrConnectWithoutOrganizationsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AIReplyTemplateUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<AIReplyTemplateCreateWithoutOrganizationInput, AIReplyTemplateUncheckedCreateWithoutOrganizationInput> | AIReplyTemplateCreateWithoutOrganizationInput[] | AIReplyTemplateUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AIReplyTemplateCreateOrConnectWithoutOrganizationInput | AIReplyTemplateCreateOrConnectWithoutOrganizationInput[]
    createMany?: AIReplyTemplateCreateManyOrganizationInputEnvelope
    connect?: AIReplyTemplateWhereUniqueInput | AIReplyTemplateWhereUniqueInput[]
  }

  export type LocationUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<LocationCreateWithoutOrganizationInput, LocationUncheckedCreateWithoutOrganizationInput> | LocationCreateWithoutOrganizationInput[] | LocationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutOrganizationInput | LocationCreateOrConnectWithoutOrganizationInput[]
    createMany?: LocationCreateManyOrganizationInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type ReportJobUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ReportJobCreateWithoutOrganizationInput, ReportJobUncheckedCreateWithoutOrganizationInput> | ReportJobCreateWithoutOrganizationInput[] | ReportJobUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ReportJobCreateOrConnectWithoutOrganizationInput | ReportJobCreateOrConnectWithoutOrganizationInput[]
    createMany?: ReportJobCreateManyOrganizationInputEnvelope
    connect?: ReportJobWhereUniqueInput | ReportJobWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<UserCreateWithoutOrganizationsInput, UserUncheckedCreateWithoutOrganizationsInput> | UserCreateWithoutOrganizationsInput[] | UserUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationsInput | UserCreateOrConnectWithoutOrganizationsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AIReplyTemplateUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<AIReplyTemplateCreateWithoutOrganizationInput, AIReplyTemplateUncheckedCreateWithoutOrganizationInput> | AIReplyTemplateCreateWithoutOrganizationInput[] | AIReplyTemplateUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AIReplyTemplateCreateOrConnectWithoutOrganizationInput | AIReplyTemplateCreateOrConnectWithoutOrganizationInput[]
    upsert?: AIReplyTemplateUpsertWithWhereUniqueWithoutOrganizationInput | AIReplyTemplateUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: AIReplyTemplateCreateManyOrganizationInputEnvelope
    set?: AIReplyTemplateWhereUniqueInput | AIReplyTemplateWhereUniqueInput[]
    disconnect?: AIReplyTemplateWhereUniqueInput | AIReplyTemplateWhereUniqueInput[]
    delete?: AIReplyTemplateWhereUniqueInput | AIReplyTemplateWhereUniqueInput[]
    connect?: AIReplyTemplateWhereUniqueInput | AIReplyTemplateWhereUniqueInput[]
    update?: AIReplyTemplateUpdateWithWhereUniqueWithoutOrganizationInput | AIReplyTemplateUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: AIReplyTemplateUpdateManyWithWhereWithoutOrganizationInput | AIReplyTemplateUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: AIReplyTemplateScalarWhereInput | AIReplyTemplateScalarWhereInput[]
  }

  export type LocationUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<LocationCreateWithoutOrganizationInput, LocationUncheckedCreateWithoutOrganizationInput> | LocationCreateWithoutOrganizationInput[] | LocationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutOrganizationInput | LocationCreateOrConnectWithoutOrganizationInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutOrganizationInput | LocationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: LocationCreateManyOrganizationInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutOrganizationInput | LocationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutOrganizationInput | LocationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutOwnedOrganizationsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedOrganizationsInput, UserUncheckedCreateWithoutOwnedOrganizationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedOrganizationsInput
    upsert?: UserUpsertWithoutOwnedOrganizationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedOrganizationsInput, UserUpdateWithoutOwnedOrganizationsInput>, UserUncheckedUpdateWithoutOwnedOrganizationsInput>
  }

  export type ReportJobUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ReportJobCreateWithoutOrganizationInput, ReportJobUncheckedCreateWithoutOrganizationInput> | ReportJobCreateWithoutOrganizationInput[] | ReportJobUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ReportJobCreateOrConnectWithoutOrganizationInput | ReportJobCreateOrConnectWithoutOrganizationInput[]
    upsert?: ReportJobUpsertWithWhereUniqueWithoutOrganizationInput | ReportJobUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ReportJobCreateManyOrganizationInputEnvelope
    set?: ReportJobWhereUniqueInput | ReportJobWhereUniqueInput[]
    disconnect?: ReportJobWhereUniqueInput | ReportJobWhereUniqueInput[]
    delete?: ReportJobWhereUniqueInput | ReportJobWhereUniqueInput[]
    connect?: ReportJobWhereUniqueInput | ReportJobWhereUniqueInput[]
    update?: ReportJobUpdateWithWhereUniqueWithoutOrganizationInput | ReportJobUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ReportJobUpdateManyWithWhereWithoutOrganizationInput | ReportJobUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ReportJobScalarWhereInput | ReportJobScalarWhereInput[]
  }

  export type UserUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationsInput, UserUncheckedCreateWithoutOrganizationsInput> | UserCreateWithoutOrganizationsInput[] | UserUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationsInput | UserCreateOrConnectWithoutOrganizationsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutOrganizationsInput | UserUpsertWithWhereUniqueWithoutOrganizationsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutOrganizationsInput | UserUpdateWithWhereUniqueWithoutOrganizationsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutOrganizationsInput | UserUpdateManyWithWhereWithoutOrganizationsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AIReplyTemplateUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<AIReplyTemplateCreateWithoutOrganizationInput, AIReplyTemplateUncheckedCreateWithoutOrganizationInput> | AIReplyTemplateCreateWithoutOrganizationInput[] | AIReplyTemplateUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AIReplyTemplateCreateOrConnectWithoutOrganizationInput | AIReplyTemplateCreateOrConnectWithoutOrganizationInput[]
    upsert?: AIReplyTemplateUpsertWithWhereUniqueWithoutOrganizationInput | AIReplyTemplateUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: AIReplyTemplateCreateManyOrganizationInputEnvelope
    set?: AIReplyTemplateWhereUniqueInput | AIReplyTemplateWhereUniqueInput[]
    disconnect?: AIReplyTemplateWhereUniqueInput | AIReplyTemplateWhereUniqueInput[]
    delete?: AIReplyTemplateWhereUniqueInput | AIReplyTemplateWhereUniqueInput[]
    connect?: AIReplyTemplateWhereUniqueInput | AIReplyTemplateWhereUniqueInput[]
    update?: AIReplyTemplateUpdateWithWhereUniqueWithoutOrganizationInput | AIReplyTemplateUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: AIReplyTemplateUpdateManyWithWhereWithoutOrganizationInput | AIReplyTemplateUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: AIReplyTemplateScalarWhereInput | AIReplyTemplateScalarWhereInput[]
  }

  export type LocationUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<LocationCreateWithoutOrganizationInput, LocationUncheckedCreateWithoutOrganizationInput> | LocationCreateWithoutOrganizationInput[] | LocationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutOrganizationInput | LocationCreateOrConnectWithoutOrganizationInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutOrganizationInput | LocationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: LocationCreateManyOrganizationInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutOrganizationInput | LocationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutOrganizationInput | LocationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type ReportJobUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ReportJobCreateWithoutOrganizationInput, ReportJobUncheckedCreateWithoutOrganizationInput> | ReportJobCreateWithoutOrganizationInput[] | ReportJobUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ReportJobCreateOrConnectWithoutOrganizationInput | ReportJobCreateOrConnectWithoutOrganizationInput[]
    upsert?: ReportJobUpsertWithWhereUniqueWithoutOrganizationInput | ReportJobUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ReportJobCreateManyOrganizationInputEnvelope
    set?: ReportJobWhereUniqueInput | ReportJobWhereUniqueInput[]
    disconnect?: ReportJobWhereUniqueInput | ReportJobWhereUniqueInput[]
    delete?: ReportJobWhereUniqueInput | ReportJobWhereUniqueInput[]
    connect?: ReportJobWhereUniqueInput | ReportJobWhereUniqueInput[]
    update?: ReportJobUpdateWithWhereUniqueWithoutOrganizationInput | ReportJobUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ReportJobUpdateManyWithWhereWithoutOrganizationInput | ReportJobUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ReportJobScalarWhereInput | ReportJobScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationsInput, UserUncheckedCreateWithoutOrganizationsInput> | UserCreateWithoutOrganizationsInput[] | UserUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationsInput | UserCreateOrConnectWithoutOrganizationsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutOrganizationsInput | UserUpsertWithWhereUniqueWithoutOrganizationsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutOrganizationsInput | UserUpdateWithWhereUniqueWithoutOrganizationsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutOrganizationsInput | UserUpdateManyWithWhereWithoutOrganizationsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type InsightCreateNestedManyWithoutLocationInput = {
    create?: XOR<InsightCreateWithoutLocationInput, InsightUncheckedCreateWithoutLocationInput> | InsightCreateWithoutLocationInput[] | InsightUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: InsightCreateOrConnectWithoutLocationInput | InsightCreateOrConnectWithoutLocationInput[]
    createMany?: InsightCreateManyLocationInputEnvelope
    connect?: InsightWhereUniqueInput | InsightWhereUniqueInput[]
  }

  export type OrganizationCreateNestedOneWithoutLocationsInput = {
    create?: XOR<OrganizationCreateWithoutLocationsInput, OrganizationUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutLocationsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type PostCreateNestedManyWithoutLocationInput = {
    create?: XOR<PostCreateWithoutLocationInput, PostUncheckedCreateWithoutLocationInput> | PostCreateWithoutLocationInput[] | PostUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: PostCreateOrConnectWithoutLocationInput | PostCreateOrConnectWithoutLocationInput[]
    createMany?: PostCreateManyLocationInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutLocationInput = {
    create?: XOR<ReportCreateWithoutLocationInput, ReportUncheckedCreateWithoutLocationInput> | ReportCreateWithoutLocationInput[] | ReportUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutLocationInput | ReportCreateOrConnectWithoutLocationInput[]
    createMany?: ReportCreateManyLocationInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutLocationInput = {
    create?: XOR<ReviewCreateWithoutLocationInput, ReviewUncheckedCreateWithoutLocationInput> | ReviewCreateWithoutLocationInput[] | ReviewUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutLocationInput | ReviewCreateOrConnectWithoutLocationInput[]
    createMany?: ReviewCreateManyLocationInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutLocationsInput = {
    create?: XOR<UserCreateWithoutLocationsInput, UserUncheckedCreateWithoutLocationsInput> | UserCreateWithoutLocationsInput[] | UserUncheckedCreateWithoutLocationsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutLocationsInput | UserCreateOrConnectWithoutLocationsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type SearchKeywordCreateNestedManyWithoutLocationInput = {
    create?: XOR<SearchKeywordCreateWithoutLocationInput, SearchKeywordUncheckedCreateWithoutLocationInput> | SearchKeywordCreateWithoutLocationInput[] | SearchKeywordUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: SearchKeywordCreateOrConnectWithoutLocationInput | SearchKeywordCreateOrConnectWithoutLocationInput[]
    createMany?: SearchKeywordCreateManyLocationInputEnvelope
    connect?: SearchKeywordWhereUniqueInput | SearchKeywordWhereUniqueInput[]
  }

  export type InsightUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<InsightCreateWithoutLocationInput, InsightUncheckedCreateWithoutLocationInput> | InsightCreateWithoutLocationInput[] | InsightUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: InsightCreateOrConnectWithoutLocationInput | InsightCreateOrConnectWithoutLocationInput[]
    createMany?: InsightCreateManyLocationInputEnvelope
    connect?: InsightWhereUniqueInput | InsightWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<PostCreateWithoutLocationInput, PostUncheckedCreateWithoutLocationInput> | PostCreateWithoutLocationInput[] | PostUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: PostCreateOrConnectWithoutLocationInput | PostCreateOrConnectWithoutLocationInput[]
    createMany?: PostCreateManyLocationInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<ReportCreateWithoutLocationInput, ReportUncheckedCreateWithoutLocationInput> | ReportCreateWithoutLocationInput[] | ReportUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutLocationInput | ReportCreateOrConnectWithoutLocationInput[]
    createMany?: ReportCreateManyLocationInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<ReviewCreateWithoutLocationInput, ReviewUncheckedCreateWithoutLocationInput> | ReviewCreateWithoutLocationInput[] | ReviewUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutLocationInput | ReviewCreateOrConnectWithoutLocationInput[]
    createMany?: ReviewCreateManyLocationInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutLocationsInput = {
    create?: XOR<UserCreateWithoutLocationsInput, UserUncheckedCreateWithoutLocationsInput> | UserCreateWithoutLocationsInput[] | UserUncheckedCreateWithoutLocationsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutLocationsInput | UserCreateOrConnectWithoutLocationsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type SearchKeywordUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<SearchKeywordCreateWithoutLocationInput, SearchKeywordUncheckedCreateWithoutLocationInput> | SearchKeywordCreateWithoutLocationInput[] | SearchKeywordUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: SearchKeywordCreateOrConnectWithoutLocationInput | SearchKeywordCreateOrConnectWithoutLocationInput[]
    createMany?: SearchKeywordCreateManyLocationInputEnvelope
    connect?: SearchKeywordWhereUniqueInput | SearchKeywordWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableEnumReplyToneFieldUpdateOperationsInput = {
    set?: $Enums.ReplyTone | null
  }

  export type InsightUpdateManyWithoutLocationNestedInput = {
    create?: XOR<InsightCreateWithoutLocationInput, InsightUncheckedCreateWithoutLocationInput> | InsightCreateWithoutLocationInput[] | InsightUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: InsightCreateOrConnectWithoutLocationInput | InsightCreateOrConnectWithoutLocationInput[]
    upsert?: InsightUpsertWithWhereUniqueWithoutLocationInput | InsightUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: InsightCreateManyLocationInputEnvelope
    set?: InsightWhereUniqueInput | InsightWhereUniqueInput[]
    disconnect?: InsightWhereUniqueInput | InsightWhereUniqueInput[]
    delete?: InsightWhereUniqueInput | InsightWhereUniqueInput[]
    connect?: InsightWhereUniqueInput | InsightWhereUniqueInput[]
    update?: InsightUpdateWithWhereUniqueWithoutLocationInput | InsightUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: InsightUpdateManyWithWhereWithoutLocationInput | InsightUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: InsightScalarWhereInput | InsightScalarWhereInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutLocationsNestedInput = {
    create?: XOR<OrganizationCreateWithoutLocationsInput, OrganizationUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutLocationsInput
    upsert?: OrganizationUpsertWithoutLocationsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutLocationsInput, OrganizationUpdateWithoutLocationsInput>, OrganizationUncheckedUpdateWithoutLocationsInput>
  }

  export type PostUpdateManyWithoutLocationNestedInput = {
    create?: XOR<PostCreateWithoutLocationInput, PostUncheckedCreateWithoutLocationInput> | PostCreateWithoutLocationInput[] | PostUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: PostCreateOrConnectWithoutLocationInput | PostCreateOrConnectWithoutLocationInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutLocationInput | PostUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: PostCreateManyLocationInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutLocationInput | PostUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: PostUpdateManyWithWhereWithoutLocationInput | PostUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutLocationNestedInput = {
    create?: XOR<ReportCreateWithoutLocationInput, ReportUncheckedCreateWithoutLocationInput> | ReportCreateWithoutLocationInput[] | ReportUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutLocationInput | ReportCreateOrConnectWithoutLocationInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutLocationInput | ReportUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: ReportCreateManyLocationInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutLocationInput | ReportUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutLocationInput | ReportUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutLocationNestedInput = {
    create?: XOR<ReviewCreateWithoutLocationInput, ReviewUncheckedCreateWithoutLocationInput> | ReviewCreateWithoutLocationInput[] | ReviewUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutLocationInput | ReviewCreateOrConnectWithoutLocationInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutLocationInput | ReviewUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: ReviewCreateManyLocationInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutLocationInput | ReviewUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutLocationInput | ReviewUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type UserUpdateManyWithoutLocationsNestedInput = {
    create?: XOR<UserCreateWithoutLocationsInput, UserUncheckedCreateWithoutLocationsInput> | UserCreateWithoutLocationsInput[] | UserUncheckedCreateWithoutLocationsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutLocationsInput | UserCreateOrConnectWithoutLocationsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutLocationsInput | UserUpsertWithWhereUniqueWithoutLocationsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutLocationsInput | UserUpdateWithWhereUniqueWithoutLocationsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutLocationsInput | UserUpdateManyWithWhereWithoutLocationsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type SearchKeywordUpdateManyWithoutLocationNestedInput = {
    create?: XOR<SearchKeywordCreateWithoutLocationInput, SearchKeywordUncheckedCreateWithoutLocationInput> | SearchKeywordCreateWithoutLocationInput[] | SearchKeywordUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: SearchKeywordCreateOrConnectWithoutLocationInput | SearchKeywordCreateOrConnectWithoutLocationInput[]
    upsert?: SearchKeywordUpsertWithWhereUniqueWithoutLocationInput | SearchKeywordUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: SearchKeywordCreateManyLocationInputEnvelope
    set?: SearchKeywordWhereUniqueInput | SearchKeywordWhereUniqueInput[]
    disconnect?: SearchKeywordWhereUniqueInput | SearchKeywordWhereUniqueInput[]
    delete?: SearchKeywordWhereUniqueInput | SearchKeywordWhereUniqueInput[]
    connect?: SearchKeywordWhereUniqueInput | SearchKeywordWhereUniqueInput[]
    update?: SearchKeywordUpdateWithWhereUniqueWithoutLocationInput | SearchKeywordUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: SearchKeywordUpdateManyWithWhereWithoutLocationInput | SearchKeywordUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: SearchKeywordScalarWhereInput | SearchKeywordScalarWhereInput[]
  }

  export type InsightUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<InsightCreateWithoutLocationInput, InsightUncheckedCreateWithoutLocationInput> | InsightCreateWithoutLocationInput[] | InsightUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: InsightCreateOrConnectWithoutLocationInput | InsightCreateOrConnectWithoutLocationInput[]
    upsert?: InsightUpsertWithWhereUniqueWithoutLocationInput | InsightUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: InsightCreateManyLocationInputEnvelope
    set?: InsightWhereUniqueInput | InsightWhereUniqueInput[]
    disconnect?: InsightWhereUniqueInput | InsightWhereUniqueInput[]
    delete?: InsightWhereUniqueInput | InsightWhereUniqueInput[]
    connect?: InsightWhereUniqueInput | InsightWhereUniqueInput[]
    update?: InsightUpdateWithWhereUniqueWithoutLocationInput | InsightUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: InsightUpdateManyWithWhereWithoutLocationInput | InsightUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: InsightScalarWhereInput | InsightScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<PostCreateWithoutLocationInput, PostUncheckedCreateWithoutLocationInput> | PostCreateWithoutLocationInput[] | PostUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: PostCreateOrConnectWithoutLocationInput | PostCreateOrConnectWithoutLocationInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutLocationInput | PostUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: PostCreateManyLocationInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutLocationInput | PostUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: PostUpdateManyWithWhereWithoutLocationInput | PostUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<ReportCreateWithoutLocationInput, ReportUncheckedCreateWithoutLocationInput> | ReportCreateWithoutLocationInput[] | ReportUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutLocationInput | ReportCreateOrConnectWithoutLocationInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutLocationInput | ReportUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: ReportCreateManyLocationInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutLocationInput | ReportUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutLocationInput | ReportUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<ReviewCreateWithoutLocationInput, ReviewUncheckedCreateWithoutLocationInput> | ReviewCreateWithoutLocationInput[] | ReviewUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutLocationInput | ReviewCreateOrConnectWithoutLocationInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutLocationInput | ReviewUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: ReviewCreateManyLocationInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutLocationInput | ReviewUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutLocationInput | ReviewUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutLocationsNestedInput = {
    create?: XOR<UserCreateWithoutLocationsInput, UserUncheckedCreateWithoutLocationsInput> | UserCreateWithoutLocationsInput[] | UserUncheckedCreateWithoutLocationsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutLocationsInput | UserCreateOrConnectWithoutLocationsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutLocationsInput | UserUpsertWithWhereUniqueWithoutLocationsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutLocationsInput | UserUpdateWithWhereUniqueWithoutLocationsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutLocationsInput | UserUpdateManyWithWhereWithoutLocationsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type SearchKeywordUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<SearchKeywordCreateWithoutLocationInput, SearchKeywordUncheckedCreateWithoutLocationInput> | SearchKeywordCreateWithoutLocationInput[] | SearchKeywordUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: SearchKeywordCreateOrConnectWithoutLocationInput | SearchKeywordCreateOrConnectWithoutLocationInput[]
    upsert?: SearchKeywordUpsertWithWhereUniqueWithoutLocationInput | SearchKeywordUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: SearchKeywordCreateManyLocationInputEnvelope
    set?: SearchKeywordWhereUniqueInput | SearchKeywordWhereUniqueInput[]
    disconnect?: SearchKeywordWhereUniqueInput | SearchKeywordWhereUniqueInput[]
    delete?: SearchKeywordWhereUniqueInput | SearchKeywordWhereUniqueInput[]
    connect?: SearchKeywordWhereUniqueInput | SearchKeywordWhereUniqueInput[]
    update?: SearchKeywordUpdateWithWhereUniqueWithoutLocationInput | SearchKeywordUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: SearchKeywordUpdateManyWithWhereWithoutLocationInput | SearchKeywordUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: SearchKeywordScalarWhereInput | SearchKeywordScalarWhereInput[]
  }

  export type PostCreatemediaUrlsInput = {
    set: string[]
  }

  export type LocationCreateNestedOneWithoutPostsInput = {
    create?: XOR<LocationCreateWithoutPostsInput, LocationUncheckedCreateWithoutPostsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutPostsInput
    connect?: LocationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPostsInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumPostTypeFieldUpdateOperationsInput = {
    set?: $Enums.PostType
  }

  export type PostUpdatemediaUrlsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumPostStatusFieldUpdateOperationsInput = {
    set?: $Enums.PostStatus
  }

  export type NullableEnumRecurTypeFieldUpdateOperationsInput = {
    set?: $Enums.RecurType | null
  }

  export type LocationUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<LocationCreateWithoutPostsInput, LocationUncheckedCreateWithoutPostsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutPostsInput
    upsert?: LocationUpsertWithoutPostsInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutPostsInput, LocationUpdateWithoutPostsInput>, LocationUncheckedUpdateWithoutPostsInput>
  }

  export type UserUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    upsert?: UserUpsertWithoutPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPostsInput, UserUpdateWithoutPostsInput>, UserUncheckedUpdateWithoutPostsInput>
  }

  export type LocationCreateNestedOneWithoutReviewsInput = {
    create?: XOR<LocationCreateWithoutReviewsInput, LocationUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutReviewsInput
    connect?: LocationWhereUniqueInput
  }

  export type ReviewReplyCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReviewReplyCreateWithoutReviewInput, ReviewReplyUncheckedCreateWithoutReviewInput> | ReviewReplyCreateWithoutReviewInput[] | ReviewReplyUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewReplyCreateOrConnectWithoutReviewInput | ReviewReplyCreateOrConnectWithoutReviewInput[]
    createMany?: ReviewReplyCreateManyReviewInputEnvelope
    connect?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
  }

  export type ReviewReplyUncheckedCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReviewReplyCreateWithoutReviewInput, ReviewReplyUncheckedCreateWithoutReviewInput> | ReviewReplyCreateWithoutReviewInput[] | ReviewReplyUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewReplyCreateOrConnectWithoutReviewInput | ReviewReplyCreateOrConnectWithoutReviewInput[]
    createMany?: ReviewReplyCreateManyReviewInputEnvelope
    connect?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumReviewStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReviewStatus
  }

  export type NullableEnumSentimentTypeFieldUpdateOperationsInput = {
    set?: $Enums.SentimentType | null
  }

  export type LocationUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<LocationCreateWithoutReviewsInput, LocationUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutReviewsInput
    upsert?: LocationUpsertWithoutReviewsInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutReviewsInput, LocationUpdateWithoutReviewsInput>, LocationUncheckedUpdateWithoutReviewsInput>
  }

  export type ReviewReplyUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReviewReplyCreateWithoutReviewInput, ReviewReplyUncheckedCreateWithoutReviewInput> | ReviewReplyCreateWithoutReviewInput[] | ReviewReplyUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewReplyCreateOrConnectWithoutReviewInput | ReviewReplyCreateOrConnectWithoutReviewInput[]
    upsert?: ReviewReplyUpsertWithWhereUniqueWithoutReviewInput | ReviewReplyUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReviewReplyCreateManyReviewInputEnvelope
    set?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    disconnect?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    delete?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    connect?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    update?: ReviewReplyUpdateWithWhereUniqueWithoutReviewInput | ReviewReplyUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReviewReplyUpdateManyWithWhereWithoutReviewInput | ReviewReplyUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReviewReplyScalarWhereInput | ReviewReplyScalarWhereInput[]
  }

  export type ReviewReplyUncheckedUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReviewReplyCreateWithoutReviewInput, ReviewReplyUncheckedCreateWithoutReviewInput> | ReviewReplyCreateWithoutReviewInput[] | ReviewReplyUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewReplyCreateOrConnectWithoutReviewInput | ReviewReplyCreateOrConnectWithoutReviewInput[]
    upsert?: ReviewReplyUpsertWithWhereUniqueWithoutReviewInput | ReviewReplyUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReviewReplyCreateManyReviewInputEnvelope
    set?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    disconnect?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    delete?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    connect?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    update?: ReviewReplyUpdateWithWhereUniqueWithoutReviewInput | ReviewReplyUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReviewReplyUpdateManyWithWhereWithoutReviewInput | ReviewReplyUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReviewReplyScalarWhereInput | ReviewReplyScalarWhereInput[]
  }

  export type AIReplyTemplateCreateNestedOneWithoutRepliesInput = {
    create?: XOR<AIReplyTemplateCreateWithoutRepliesInput, AIReplyTemplateUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: AIReplyTemplateCreateOrConnectWithoutRepliesInput
    connect?: AIReplyTemplateWhereUniqueInput
  }

  export type ReviewCreateNestedOneWithoutRepliesInput = {
    create?: XOR<ReviewCreateWithoutRepliesInput, ReviewUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutRepliesInput
    connect?: ReviewWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewRepliesInput = {
    create?: XOR<UserCreateWithoutReviewRepliesInput, UserUncheckedCreateWithoutReviewRepliesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewRepliesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumReplySourceFieldUpdateOperationsInput = {
    set?: $Enums.ReplySource
  }

  export type EnumReplyToneFieldUpdateOperationsInput = {
    set?: $Enums.ReplyTone
  }

  export type AIReplyTemplateUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<AIReplyTemplateCreateWithoutRepliesInput, AIReplyTemplateUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: AIReplyTemplateCreateOrConnectWithoutRepliesInput
    upsert?: AIReplyTemplateUpsertWithoutRepliesInput
    disconnect?: AIReplyTemplateWhereInput | boolean
    delete?: AIReplyTemplateWhereInput | boolean
    connect?: AIReplyTemplateWhereUniqueInput
    update?: XOR<XOR<AIReplyTemplateUpdateToOneWithWhereWithoutRepliesInput, AIReplyTemplateUpdateWithoutRepliesInput>, AIReplyTemplateUncheckedUpdateWithoutRepliesInput>
  }

  export type ReviewUpdateOneRequiredWithoutRepliesNestedInput = {
    create?: XOR<ReviewCreateWithoutRepliesInput, ReviewUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutRepliesInput
    upsert?: ReviewUpsertWithoutRepliesInput
    connect?: ReviewWhereUniqueInput
    update?: XOR<XOR<ReviewUpdateToOneWithWhereWithoutRepliesInput, ReviewUpdateWithoutRepliesInput>, ReviewUncheckedUpdateWithoutRepliesInput>
  }

  export type UserUpdateOneWithoutReviewRepliesNestedInput = {
    create?: XOR<UserCreateWithoutReviewRepliesInput, UserUncheckedCreateWithoutReviewRepliesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewRepliesInput
    upsert?: UserUpsertWithoutReviewRepliesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewRepliesInput, UserUpdateWithoutReviewRepliesInput>, UserUncheckedUpdateWithoutReviewRepliesInput>
  }

  export type OrganizationCreateNestedOneWithoutAiTemplatesInput = {
    create?: XOR<OrganizationCreateWithoutAiTemplatesInput, OrganizationUncheckedCreateWithoutAiTemplatesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutAiTemplatesInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ReviewReplyCreateNestedManyWithoutAiTemplateInput = {
    create?: XOR<ReviewReplyCreateWithoutAiTemplateInput, ReviewReplyUncheckedCreateWithoutAiTemplateInput> | ReviewReplyCreateWithoutAiTemplateInput[] | ReviewReplyUncheckedCreateWithoutAiTemplateInput[]
    connectOrCreate?: ReviewReplyCreateOrConnectWithoutAiTemplateInput | ReviewReplyCreateOrConnectWithoutAiTemplateInput[]
    createMany?: ReviewReplyCreateManyAiTemplateInputEnvelope
    connect?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
  }

  export type ReviewReplyUncheckedCreateNestedManyWithoutAiTemplateInput = {
    create?: XOR<ReviewReplyCreateWithoutAiTemplateInput, ReviewReplyUncheckedCreateWithoutAiTemplateInput> | ReviewReplyCreateWithoutAiTemplateInput[] | ReviewReplyUncheckedCreateWithoutAiTemplateInput[]
    connectOrCreate?: ReviewReplyCreateOrConnectWithoutAiTemplateInput | ReviewReplyCreateOrConnectWithoutAiTemplateInput[]
    createMany?: ReviewReplyCreateManyAiTemplateInputEnvelope
    connect?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
  }

  export type EnumSentimentTypeFieldUpdateOperationsInput = {
    set?: $Enums.SentimentType
  }

  export type OrganizationUpdateOneRequiredWithoutAiTemplatesNestedInput = {
    create?: XOR<OrganizationCreateWithoutAiTemplatesInput, OrganizationUncheckedCreateWithoutAiTemplatesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutAiTemplatesInput
    upsert?: OrganizationUpsertWithoutAiTemplatesInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutAiTemplatesInput, OrganizationUpdateWithoutAiTemplatesInput>, OrganizationUncheckedUpdateWithoutAiTemplatesInput>
  }

  export type ReviewReplyUpdateManyWithoutAiTemplateNestedInput = {
    create?: XOR<ReviewReplyCreateWithoutAiTemplateInput, ReviewReplyUncheckedCreateWithoutAiTemplateInput> | ReviewReplyCreateWithoutAiTemplateInput[] | ReviewReplyUncheckedCreateWithoutAiTemplateInput[]
    connectOrCreate?: ReviewReplyCreateOrConnectWithoutAiTemplateInput | ReviewReplyCreateOrConnectWithoutAiTemplateInput[]
    upsert?: ReviewReplyUpsertWithWhereUniqueWithoutAiTemplateInput | ReviewReplyUpsertWithWhereUniqueWithoutAiTemplateInput[]
    createMany?: ReviewReplyCreateManyAiTemplateInputEnvelope
    set?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    disconnect?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    delete?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    connect?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    update?: ReviewReplyUpdateWithWhereUniqueWithoutAiTemplateInput | ReviewReplyUpdateWithWhereUniqueWithoutAiTemplateInput[]
    updateMany?: ReviewReplyUpdateManyWithWhereWithoutAiTemplateInput | ReviewReplyUpdateManyWithWhereWithoutAiTemplateInput[]
    deleteMany?: ReviewReplyScalarWhereInput | ReviewReplyScalarWhereInput[]
  }

  export type ReviewReplyUncheckedUpdateManyWithoutAiTemplateNestedInput = {
    create?: XOR<ReviewReplyCreateWithoutAiTemplateInput, ReviewReplyUncheckedCreateWithoutAiTemplateInput> | ReviewReplyCreateWithoutAiTemplateInput[] | ReviewReplyUncheckedCreateWithoutAiTemplateInput[]
    connectOrCreate?: ReviewReplyCreateOrConnectWithoutAiTemplateInput | ReviewReplyCreateOrConnectWithoutAiTemplateInput[]
    upsert?: ReviewReplyUpsertWithWhereUniqueWithoutAiTemplateInput | ReviewReplyUpsertWithWhereUniqueWithoutAiTemplateInput[]
    createMany?: ReviewReplyCreateManyAiTemplateInputEnvelope
    set?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    disconnect?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    delete?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    connect?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    update?: ReviewReplyUpdateWithWhereUniqueWithoutAiTemplateInput | ReviewReplyUpdateWithWhereUniqueWithoutAiTemplateInput[]
    updateMany?: ReviewReplyUpdateManyWithWhereWithoutAiTemplateInput | ReviewReplyUpdateManyWithWhereWithoutAiTemplateInput[]
    deleteMany?: ReviewReplyScalarWhereInput | ReviewReplyScalarWhereInput[]
  }

  export type LocationCreateNestedOneWithoutInsightsInput = {
    create?: XOR<LocationCreateWithoutInsightsInput, LocationUncheckedCreateWithoutInsightsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutInsightsInput
    connect?: LocationWhereUniqueInput
  }

  export type EnumInsightTypeFieldUpdateOperationsInput = {
    set?: $Enums.InsightType
  }

  export type LocationUpdateOneRequiredWithoutInsightsNestedInput = {
    create?: XOR<LocationCreateWithoutInsightsInput, LocationUncheckedCreateWithoutInsightsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutInsightsInput
    upsert?: LocationUpsertWithoutInsightsInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutInsightsInput, LocationUpdateWithoutInsightsInput>, LocationUncheckedUpdateWithoutInsightsInput>
  }

  export type LocationCreateNestedOneWithoutReportsInput = {
    create?: XOR<LocationCreateWithoutReportsInput, LocationUncheckedCreateWithoutReportsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutReportsInput
    connect?: LocationWhereUniqueInput
  }

  export type EnumReportTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReportType
  }

  export type EnumReportStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReportStatus
  }

  export type LocationUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<LocationCreateWithoutReportsInput, LocationUncheckedCreateWithoutReportsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutReportsInput
    upsert?: LocationUpsertWithoutReportsInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutReportsInput, LocationUpdateWithoutReportsInput>, LocationUncheckedUpdateWithoutReportsInput>
  }

  export type ReportJobCreatelocationsInput = {
    set: string[]
  }

  export type ReportJobCreateemailRecipientsInput = {
    set: string[]
  }

  export type OrganizationCreateNestedOneWithoutReportJobsInput = {
    create?: XOR<OrganizationCreateWithoutReportJobsInput, OrganizationUncheckedCreateWithoutReportJobsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutReportJobsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ReportJobUpdatelocationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumReportFrequencyFieldUpdateOperationsInput = {
    set?: $Enums.ReportFrequency
  }

  export type ReportJobUpdateemailRecipientsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OrganizationUpdateOneRequiredWithoutReportJobsNestedInput = {
    create?: XOR<OrganizationCreateWithoutReportJobsInput, OrganizationUncheckedCreateWithoutReportJobsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutReportJobsInput
    upsert?: OrganizationUpsertWithoutReportJobsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutReportJobsInput, OrganizationUpdateWithoutReportJobsInput>, OrganizationUncheckedUpdateWithoutReportJobsInput>
  }

  export type LocationCreateNestedOneWithoutSearchKeywordsInput = {
    create?: XOR<LocationCreateWithoutSearchKeywordsInput, LocationUncheckedCreateWithoutSearchKeywordsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutSearchKeywordsInput
    connect?: LocationWhereUniqueInput
  }

  export type RankTrackingResultCreateNestedManyWithoutKeywordInput = {
    create?: XOR<RankTrackingResultCreateWithoutKeywordInput, RankTrackingResultUncheckedCreateWithoutKeywordInput> | RankTrackingResultCreateWithoutKeywordInput[] | RankTrackingResultUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: RankTrackingResultCreateOrConnectWithoutKeywordInput | RankTrackingResultCreateOrConnectWithoutKeywordInput[]
    createMany?: RankTrackingResultCreateManyKeywordInputEnvelope
    connect?: RankTrackingResultWhereUniqueInput | RankTrackingResultWhereUniqueInput[]
  }

  export type RankTrackingResultUncheckedCreateNestedManyWithoutKeywordInput = {
    create?: XOR<RankTrackingResultCreateWithoutKeywordInput, RankTrackingResultUncheckedCreateWithoutKeywordInput> | RankTrackingResultCreateWithoutKeywordInput[] | RankTrackingResultUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: RankTrackingResultCreateOrConnectWithoutKeywordInput | RankTrackingResultCreateOrConnectWithoutKeywordInput[]
    createMany?: RankTrackingResultCreateManyKeywordInputEnvelope
    connect?: RankTrackingResultWhereUniqueInput | RankTrackingResultWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LocationUpdateOneRequiredWithoutSearchKeywordsNestedInput = {
    create?: XOR<LocationCreateWithoutSearchKeywordsInput, LocationUncheckedCreateWithoutSearchKeywordsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutSearchKeywordsInput
    upsert?: LocationUpsertWithoutSearchKeywordsInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutSearchKeywordsInput, LocationUpdateWithoutSearchKeywordsInput>, LocationUncheckedUpdateWithoutSearchKeywordsInput>
  }

  export type RankTrackingResultUpdateManyWithoutKeywordNestedInput = {
    create?: XOR<RankTrackingResultCreateWithoutKeywordInput, RankTrackingResultUncheckedCreateWithoutKeywordInput> | RankTrackingResultCreateWithoutKeywordInput[] | RankTrackingResultUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: RankTrackingResultCreateOrConnectWithoutKeywordInput | RankTrackingResultCreateOrConnectWithoutKeywordInput[]
    upsert?: RankTrackingResultUpsertWithWhereUniqueWithoutKeywordInput | RankTrackingResultUpsertWithWhereUniqueWithoutKeywordInput[]
    createMany?: RankTrackingResultCreateManyKeywordInputEnvelope
    set?: RankTrackingResultWhereUniqueInput | RankTrackingResultWhereUniqueInput[]
    disconnect?: RankTrackingResultWhereUniqueInput | RankTrackingResultWhereUniqueInput[]
    delete?: RankTrackingResultWhereUniqueInput | RankTrackingResultWhereUniqueInput[]
    connect?: RankTrackingResultWhereUniqueInput | RankTrackingResultWhereUniqueInput[]
    update?: RankTrackingResultUpdateWithWhereUniqueWithoutKeywordInput | RankTrackingResultUpdateWithWhereUniqueWithoutKeywordInput[]
    updateMany?: RankTrackingResultUpdateManyWithWhereWithoutKeywordInput | RankTrackingResultUpdateManyWithWhereWithoutKeywordInput[]
    deleteMany?: RankTrackingResultScalarWhereInput | RankTrackingResultScalarWhereInput[]
  }

  export type RankTrackingResultUncheckedUpdateManyWithoutKeywordNestedInput = {
    create?: XOR<RankTrackingResultCreateWithoutKeywordInput, RankTrackingResultUncheckedCreateWithoutKeywordInput> | RankTrackingResultCreateWithoutKeywordInput[] | RankTrackingResultUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: RankTrackingResultCreateOrConnectWithoutKeywordInput | RankTrackingResultCreateOrConnectWithoutKeywordInput[]
    upsert?: RankTrackingResultUpsertWithWhereUniqueWithoutKeywordInput | RankTrackingResultUpsertWithWhereUniqueWithoutKeywordInput[]
    createMany?: RankTrackingResultCreateManyKeywordInputEnvelope
    set?: RankTrackingResultWhereUniqueInput | RankTrackingResultWhereUniqueInput[]
    disconnect?: RankTrackingResultWhereUniqueInput | RankTrackingResultWhereUniqueInput[]
    delete?: RankTrackingResultWhereUniqueInput | RankTrackingResultWhereUniqueInput[]
    connect?: RankTrackingResultWhereUniqueInput | RankTrackingResultWhereUniqueInput[]
    update?: RankTrackingResultUpdateWithWhereUniqueWithoutKeywordInput | RankTrackingResultUpdateWithWhereUniqueWithoutKeywordInput[]
    updateMany?: RankTrackingResultUpdateManyWithWhereWithoutKeywordInput | RankTrackingResultUpdateManyWithWhereWithoutKeywordInput[]
    deleteMany?: RankTrackingResultScalarWhereInput | RankTrackingResultScalarWhereInput[]
  }

  export type SearchKeywordCreateNestedOneWithoutRankResultsInput = {
    create?: XOR<SearchKeywordCreateWithoutRankResultsInput, SearchKeywordUncheckedCreateWithoutRankResultsInput>
    connectOrCreate?: SearchKeywordCreateOrConnectWithoutRankResultsInput
    connect?: SearchKeywordWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SearchKeywordUpdateOneRequiredWithoutRankResultsNestedInput = {
    create?: XOR<SearchKeywordCreateWithoutRankResultsInput, SearchKeywordUncheckedCreateWithoutRankResultsInput>
    connectOrCreate?: SearchKeywordCreateOrConnectWithoutRankResultsInput
    upsert?: SearchKeywordUpsertWithoutRankResultsInput
    connect?: SearchKeywordWhereUniqueInput
    update?: XOR<XOR<SearchKeywordUpdateToOneWithWhereWithoutRankResultsInput, SearchKeywordUpdateWithoutRankResultsInput>, SearchKeywordUncheckedUpdateWithoutRankResultsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumSubscriptionStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionStatusNullableFilter<$PrismaModel> | $Enums.SubscriptionStatus | null
  }

  export type NestedEnumSubscriptionPlanNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionPlanNullableFilter<$PrismaModel> | $Enums.SubscriptionPlan | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionPlanNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionPlanNullableWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionPlan | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionPlanNullableFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionPlanNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumReplyToneNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ReplyTone | EnumReplyToneFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReplyTone[] | ListEnumReplyToneFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ReplyTone[] | ListEnumReplyToneFieldRefInput<$PrismaModel> | null
    not?: NestedEnumReplyToneNullableFilter<$PrismaModel> | $Enums.ReplyTone | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumReplyToneNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReplyTone | EnumReplyToneFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReplyTone[] | ListEnumReplyToneFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ReplyTone[] | ListEnumReplyToneFieldRefInput<$PrismaModel> | null
    not?: NestedEnumReplyToneNullableWithAggregatesFilter<$PrismaModel> | $Enums.ReplyTone | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumReplyToneNullableFilter<$PrismaModel>
    _max?: NestedEnumReplyToneNullableFilter<$PrismaModel>
  }

  export type NestedEnumPostTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PostType | EnumPostTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPostTypeFilter<$PrismaModel> | $Enums.PostType
  }

  export type NestedEnumPostStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusFilter<$PrismaModel> | $Enums.PostStatus
  }

  export type NestedEnumRecurTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurType | EnumRecurTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.RecurType[] | ListEnumRecurTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RecurType[] | ListEnumRecurTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRecurTypeNullableFilter<$PrismaModel> | $Enums.RecurType | null
  }

  export type NestedEnumPostTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostType | EnumPostTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPostTypeWithAggregatesFilter<$PrismaModel> | $Enums.PostType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostTypeFilter<$PrismaModel>
    _max?: NestedEnumPostTypeFilter<$PrismaModel>
  }

  export type NestedEnumPostStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusWithAggregatesFilter<$PrismaModel> | $Enums.PostStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostStatusFilter<$PrismaModel>
    _max?: NestedEnumPostStatusFilter<$PrismaModel>
  }

  export type NestedEnumRecurTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurType | EnumRecurTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.RecurType[] | ListEnumRecurTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RecurType[] | ListEnumRecurTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRecurTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.RecurType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRecurTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumRecurTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumReviewStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewStatusFilter<$PrismaModel> | $Enums.ReviewStatus
  }

  export type NestedEnumSentimentTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SentimentType | EnumSentimentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.SentimentType[] | ListEnumSentimentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SentimentType[] | ListEnumSentimentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSentimentTypeNullableFilter<$PrismaModel> | $Enums.SentimentType | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumReviewStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReviewStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReviewStatusFilter<$PrismaModel>
    _max?: NestedEnumReviewStatusFilter<$PrismaModel>
  }

  export type NestedEnumSentimentTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SentimentType | EnumSentimentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.SentimentType[] | ListEnumSentimentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SentimentType[] | ListEnumSentimentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSentimentTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.SentimentType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSentimentTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumSentimentTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumReplySourceFilter<$PrismaModel = never> = {
    equals?: $Enums.ReplySource | EnumReplySourceFieldRefInput<$PrismaModel>
    in?: $Enums.ReplySource[] | ListEnumReplySourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReplySource[] | ListEnumReplySourceFieldRefInput<$PrismaModel>
    not?: NestedEnumReplySourceFilter<$PrismaModel> | $Enums.ReplySource
  }

  export type NestedEnumReplyToneFilter<$PrismaModel = never> = {
    equals?: $Enums.ReplyTone | EnumReplyToneFieldRefInput<$PrismaModel>
    in?: $Enums.ReplyTone[] | ListEnumReplyToneFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReplyTone[] | ListEnumReplyToneFieldRefInput<$PrismaModel>
    not?: NestedEnumReplyToneFilter<$PrismaModel> | $Enums.ReplyTone
  }

  export type NestedEnumReplySourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReplySource | EnumReplySourceFieldRefInput<$PrismaModel>
    in?: $Enums.ReplySource[] | ListEnumReplySourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReplySource[] | ListEnumReplySourceFieldRefInput<$PrismaModel>
    not?: NestedEnumReplySourceWithAggregatesFilter<$PrismaModel> | $Enums.ReplySource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReplySourceFilter<$PrismaModel>
    _max?: NestedEnumReplySourceFilter<$PrismaModel>
  }

  export type NestedEnumReplyToneWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReplyTone | EnumReplyToneFieldRefInput<$PrismaModel>
    in?: $Enums.ReplyTone[] | ListEnumReplyToneFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReplyTone[] | ListEnumReplyToneFieldRefInput<$PrismaModel>
    not?: NestedEnumReplyToneWithAggregatesFilter<$PrismaModel> | $Enums.ReplyTone
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReplyToneFilter<$PrismaModel>
    _max?: NestedEnumReplyToneFilter<$PrismaModel>
  }

  export type NestedEnumSentimentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SentimentType | EnumSentimentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SentimentType[] | ListEnumSentimentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SentimentType[] | ListEnumSentimentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSentimentTypeFilter<$PrismaModel> | $Enums.SentimentType
  }

  export type NestedEnumSentimentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SentimentType | EnumSentimentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SentimentType[] | ListEnumSentimentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SentimentType[] | ListEnumSentimentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSentimentTypeWithAggregatesFilter<$PrismaModel> | $Enums.SentimentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSentimentTypeFilter<$PrismaModel>
    _max?: NestedEnumSentimentTypeFilter<$PrismaModel>
  }

  export type NestedEnumInsightTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightType | EnumInsightTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InsightType[] | ListEnumInsightTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightType[] | ListEnumInsightTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightTypeFilter<$PrismaModel> | $Enums.InsightType
  }

  export type NestedEnumInsightTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightType | EnumInsightTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InsightType[] | ListEnumInsightTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightType[] | ListEnumInsightTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightTypeWithAggregatesFilter<$PrismaModel> | $Enums.InsightType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInsightTypeFilter<$PrismaModel>
    _max?: NestedEnumInsightTypeFilter<$PrismaModel>
  }

  export type NestedEnumReportTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportTypeFilter<$PrismaModel> | $Enums.ReportType
  }

  export type NestedEnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type NestedEnumReportTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReportType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportTypeFilter<$PrismaModel>
    _max?: NestedEnumReportTypeFilter<$PrismaModel>
  }

  export type NestedEnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type NestedEnumReportFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportFrequency | EnumReportFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.ReportFrequency[] | ListEnumReportFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportFrequency[] | ListEnumReportFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumReportFrequencyFilter<$PrismaModel> | $Enums.ReportFrequency
  }

  export type NestedEnumReportFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportFrequency | EnumReportFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.ReportFrequency[] | ListEnumReportFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportFrequency[] | ListEnumReportFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumReportFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.ReportFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportFrequencyFilter<$PrismaModel>
    _max?: NestedEnumReportFrequencyFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type OrganizationCreateWithoutOwnerInput = {
    id?: string
    name: string
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiTemplates?: AIReplyTemplateCreateNestedManyWithoutOrganizationInput
    locations?: LocationCreateNestedManyWithoutOrganizationInput
    reportJobs?: ReportJobCreateNestedManyWithoutOrganizationInput
    members?: UserCreateNestedManyWithoutOrganizationsInput
  }

  export type OrganizationUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiTemplates?: AIReplyTemplateUncheckedCreateNestedManyWithoutOrganizationInput
    locations?: LocationUncheckedCreateNestedManyWithoutOrganizationInput
    reportJobs?: ReportJobUncheckedCreateNestedManyWithoutOrganizationInput
    members?: UserUncheckedCreateNestedManyWithoutOrganizationsInput
  }

  export type OrganizationCreateOrConnectWithoutOwnerInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutOwnerInput, OrganizationUncheckedCreateWithoutOwnerInput>
  }

  export type OrganizationCreateManyOwnerInputEnvelope = {
    data: OrganizationCreateManyOwnerInput | OrganizationCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutUserInput = {
    id?: string
    title: string
    content: string
    type: $Enums.PostType
    mediaUrls?: PostCreatemediaUrlsInput | string[]
    scheduledAt: Date | string
    publishedAt?: Date | string | null
    status?: $Enums.PostStatus
    eventStart?: Date | string | null
    eventEnd?: Date | string | null
    offerStart?: Date | string | null
    offerEnd?: Date | string | null
    couponCode?: string | null
    callToAction?: string | null
    recurType?: $Enums.RecurType | null
    recurEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutUserInput = {
    id?: string
    locationId: string
    title: string
    content: string
    type: $Enums.PostType
    mediaUrls?: PostCreatemediaUrlsInput | string[]
    scheduledAt: Date | string
    publishedAt?: Date | string | null
    status?: $Enums.PostStatus
    eventStart?: Date | string | null
    eventEnd?: Date | string | null
    offerStart?: Date | string | null
    offerEnd?: Date | string | null
    couponCode?: string | null
    callToAction?: string | null
    recurType?: $Enums.RecurType | null
    recurEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostCreateOrConnectWithoutUserInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput>
  }

  export type PostCreateManyUserInputEnvelope = {
    data: PostCreateManyUserInput | PostCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReviewReplyCreateWithoutUserInput = {
    id?: string
    content: string
    source: $Enums.ReplySource
    tone?: $Enums.ReplyTone
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiTemplate?: AIReplyTemplateCreateNestedOneWithoutRepliesInput
    review: ReviewCreateNestedOneWithoutRepliesInput
  }

  export type ReviewReplyUncheckedCreateWithoutUserInput = {
    id?: string
    reviewId: string
    content: string
    source: $Enums.ReplySource
    tone?: $Enums.ReplyTone
    isPublished?: boolean
    publishedAt?: Date | string | null
    aiTemplateId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewReplyCreateOrConnectWithoutUserInput = {
    where: ReviewReplyWhereUniqueInput
    create: XOR<ReviewReplyCreateWithoutUserInput, ReviewReplyUncheckedCreateWithoutUserInput>
  }

  export type ReviewReplyCreateManyUserInputEnvelope = {
    data: ReviewReplyCreateManyUserInput | ReviewReplyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LocationCreateWithoutUsersInput = {
    id?: string
    name: string
    gmbLocationId: string
    gmbLocationName: string
    address?: string | null
    phone?: string | null
    websiteUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    timezone?: string
    isVerified?: boolean
    lastSyncedAt?: Date | string
    lastFetchedTimestamp?: Date | string | null
    autoReplyEnabled?: boolean
    autoPostEnabled?: boolean
    replyTonePreference?: $Enums.ReplyTone | null
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    logoUrl?: string | null
    gmbAccountId?: string | null
    insights?: InsightCreateNestedManyWithoutLocationInput
    organization: OrganizationCreateNestedOneWithoutLocationsInput
    posts?: PostCreateNestedManyWithoutLocationInput
    reports?: ReportCreateNestedManyWithoutLocationInput
    reviews?: ReviewCreateNestedManyWithoutLocationInput
    searchKeywords?: SearchKeywordCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    organizationId: string
    gmbLocationId: string
    gmbLocationName: string
    address?: string | null
    phone?: string | null
    websiteUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    timezone?: string
    isVerified?: boolean
    lastSyncedAt?: Date | string
    lastFetchedTimestamp?: Date | string | null
    autoReplyEnabled?: boolean
    autoPostEnabled?: boolean
    replyTonePreference?: $Enums.ReplyTone | null
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    logoUrl?: string | null
    gmbAccountId?: string | null
    insights?: InsightUncheckedCreateNestedManyWithoutLocationInput
    posts?: PostUncheckedCreateNestedManyWithoutLocationInput
    reports?: ReportUncheckedCreateNestedManyWithoutLocationInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutLocationInput
    searchKeywords?: SearchKeywordUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutUsersInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutUsersInput, LocationUncheckedCreateWithoutUsersInput>
  }

  export type OrganizationCreateWithoutMembersInput = {
    id?: string
    name: string
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiTemplates?: AIReplyTemplateCreateNestedManyWithoutOrganizationInput
    locations?: LocationCreateNestedManyWithoutOrganizationInput
    owner: UserCreateNestedOneWithoutOwnedOrganizationsInput
    reportJobs?: ReportJobCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    logo?: string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    aiTemplates?: AIReplyTemplateUncheckedCreateNestedManyWithoutOrganizationInput
    locations?: LocationUncheckedCreateNestedManyWithoutOrganizationInput
    reportJobs?: ReportJobUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutMembersInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
  }

  export type OrganizationUpsertWithWhereUniqueWithoutOwnerInput = {
    where: OrganizationWhereUniqueInput
    update: XOR<OrganizationUpdateWithoutOwnerInput, OrganizationUncheckedUpdateWithoutOwnerInput>
    create: XOR<OrganizationCreateWithoutOwnerInput, OrganizationUncheckedCreateWithoutOwnerInput>
  }

  export type OrganizationUpdateWithWhereUniqueWithoutOwnerInput = {
    where: OrganizationWhereUniqueInput
    data: XOR<OrganizationUpdateWithoutOwnerInput, OrganizationUncheckedUpdateWithoutOwnerInput>
  }

  export type OrganizationUpdateManyWithWhereWithoutOwnerInput = {
    where: OrganizationScalarWhereInput
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyWithoutOwnerInput>
  }

  export type OrganizationScalarWhereInput = {
    AND?: OrganizationScalarWhereInput | OrganizationScalarWhereInput[]
    OR?: OrganizationScalarWhereInput[]
    NOT?: OrganizationScalarWhereInput | OrganizationScalarWhereInput[]
    id?: StringFilter<"Organization"> | string
    name?: StringFilter<"Organization"> | string
    logo?: StringNullableFilter<"Organization"> | string | null
    ownerId?: StringFilter<"Organization"> | string
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
  }

  export type PostUpsertWithWhereUniqueWithoutUserInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutUserInput, PostUncheckedUpdateWithoutUserInput>
    create: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput>
  }

  export type PostUpdateWithWhereUniqueWithoutUserInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutUserInput, PostUncheckedUpdateWithoutUserInput>
  }

  export type PostUpdateManyWithWhereWithoutUserInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutUserInput>
  }

  export type PostScalarWhereInput = {
    AND?: PostScalarWhereInput | PostScalarWhereInput[]
    OR?: PostScalarWhereInput[]
    NOT?: PostScalarWhereInput | PostScalarWhereInput[]
    id?: StringFilter<"Post"> | string
    locationId?: StringFilter<"Post"> | string
    userId?: StringFilter<"Post"> | string
    title?: StringFilter<"Post"> | string
    content?: StringFilter<"Post"> | string
    type?: EnumPostTypeFilter<"Post"> | $Enums.PostType
    mediaUrls?: StringNullableListFilter<"Post">
    scheduledAt?: DateTimeFilter<"Post"> | Date | string
    publishedAt?: DateTimeNullableFilter<"Post"> | Date | string | null
    status?: EnumPostStatusFilter<"Post"> | $Enums.PostStatus
    eventStart?: DateTimeNullableFilter<"Post"> | Date | string | null
    eventEnd?: DateTimeNullableFilter<"Post"> | Date | string | null
    offerStart?: DateTimeNullableFilter<"Post"> | Date | string | null
    offerEnd?: DateTimeNullableFilter<"Post"> | Date | string | null
    couponCode?: StringNullableFilter<"Post"> | string | null
    callToAction?: StringNullableFilter<"Post"> | string | null
    recurType?: EnumRecurTypeNullableFilter<"Post"> | $Enums.RecurType | null
    recurEndsAt?: DateTimeNullableFilter<"Post"> | Date | string | null
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
  }

  export type ReviewReplyUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewReplyWhereUniqueInput
    update: XOR<ReviewReplyUpdateWithoutUserInput, ReviewReplyUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewReplyCreateWithoutUserInput, ReviewReplyUncheckedCreateWithoutUserInput>
  }

  export type ReviewReplyUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewReplyWhereUniqueInput
    data: XOR<ReviewReplyUpdateWithoutUserInput, ReviewReplyUncheckedUpdateWithoutUserInput>
  }

  export type ReviewReplyUpdateManyWithWhereWithoutUserInput = {
    where: ReviewReplyScalarWhereInput
    data: XOR<ReviewReplyUpdateManyMutationInput, ReviewReplyUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewReplyScalarWhereInput = {
    AND?: ReviewReplyScalarWhereInput | ReviewReplyScalarWhereInput[]
    OR?: ReviewReplyScalarWhereInput[]
    NOT?: ReviewReplyScalarWhereInput | ReviewReplyScalarWhereInput[]
    id?: StringFilter<"ReviewReply"> | string
    reviewId?: StringFilter<"ReviewReply"> | string
    userId?: StringNullableFilter<"ReviewReply"> | string | null
    content?: StringFilter<"ReviewReply"> | string
    source?: EnumReplySourceFilter<"ReviewReply"> | $Enums.ReplySource
    tone?: EnumReplyToneFilter<"ReviewReply"> | $Enums.ReplyTone
    isPublished?: BoolFilter<"ReviewReply"> | boolean
    publishedAt?: DateTimeNullableFilter<"ReviewReply"> | Date | string | null
    aiTemplateId?: StringNullableFilter<"ReviewReply"> | string | null
    createdAt?: DateTimeFilter<"ReviewReply"> | Date | string
    updatedAt?: DateTimeFilter<"ReviewReply"> | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type LocationUpsertWithWhereUniqueWithoutUsersInput = {
    where: LocationWhereUniqueInput
    update: XOR<LocationUpdateWithoutUsersInput, LocationUncheckedUpdateWithoutUsersInput>
    create: XOR<LocationCreateWithoutUsersInput, LocationUncheckedCreateWithoutUsersInput>
  }

  export type LocationUpdateWithWhereUniqueWithoutUsersInput = {
    where: LocationWhereUniqueInput
    data: XOR<LocationUpdateWithoutUsersInput, LocationUncheckedUpdateWithoutUsersInput>
  }

  export type LocationUpdateManyWithWhereWithoutUsersInput = {
    where: LocationScalarWhereInput
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyWithoutUsersInput>
  }

  export type LocationScalarWhereInput = {
    AND?: LocationScalarWhereInput | LocationScalarWhereInput[]
    OR?: LocationScalarWhereInput[]
    NOT?: LocationScalarWhereInput | LocationScalarWhereInput[]
    id?: StringFilter<"Location"> | string
    name?: StringFilter<"Location"> | string
    organizationId?: StringFilter<"Location"> | string
    gmbLocationId?: StringFilter<"Location"> | string
    gmbLocationName?: StringFilter<"Location"> | string
    address?: StringNullableFilter<"Location"> | string | null
    phone?: StringNullableFilter<"Location"> | string | null
    websiteUrl?: StringNullableFilter<"Location"> | string | null
    latitude?: FloatNullableFilter<"Location"> | number | null
    longitude?: FloatNullableFilter<"Location"> | number | null
    timezone?: StringFilter<"Location"> | string
    isVerified?: BoolFilter<"Location"> | boolean
    lastSyncedAt?: DateTimeFilter<"Location"> | Date | string
    lastFetchedTimestamp?: DateTimeNullableFilter<"Location"> | Date | string | null
    autoReplyEnabled?: BoolFilter<"Location"> | boolean
    autoPostEnabled?: BoolFilter<"Location"> | boolean
    replyTonePreference?: EnumReplyToneNullableFilter<"Location"> | $Enums.ReplyTone | null
    accessToken?: StringNullableFilter<"Location"> | string | null
    refreshToken?: StringNullableFilter<"Location"> | string | null
    tokenExpiresAt?: DateTimeNullableFilter<"Location"> | Date | string | null
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    logoUrl?: StringNullableFilter<"Location"> | string | null
    gmbAccountId?: StringNullableFilter<"Location"> | string | null
  }

  export type OrganizationUpsertWithWhereUniqueWithoutMembersInput = {
    where: OrganizationWhereUniqueInput
    update: XOR<OrganizationUpdateWithoutMembersInput, OrganizationUncheckedUpdateWithoutMembersInput>
    create: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
  }

  export type OrganizationUpdateWithWhereUniqueWithoutMembersInput = {
    where: OrganizationWhereUniqueInput
    data: XOR<OrganizationUpdateWithoutMembersInput, OrganizationUncheckedUpdateWithoutMembersInput>
  }

  export type OrganizationUpdateManyWithWhereWithoutMembersInput = {
    where: OrganizationScalarWhereInput
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyWithoutMembersInput>
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    emailVerificationToken?: string | null
    password: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiresAt?: Date | string | null
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    subscriptionPlan?: $Enums.SubscriptionPlan | null
    trialStartedAt?: Date | string | null
    trialEndsAt?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    razorpayCustomerId?: string | null
    razorpayPaymentId?: string | null
    razorpayOrderId?: string | null
    ownedOrganizations?: OrganizationCreateNestedManyWithoutOwnerInput
    posts?: PostCreateNestedManyWithoutUserInput
    reviewReplies?: ReviewReplyCreateNestedManyWithoutUserInput
    locations?: LocationCreateNestedManyWithoutUsersInput
    organizations?: OrganizationCreateNestedManyWithoutMembersInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    emailVerificationToken?: string | null
    password: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiresAt?: Date | string | null
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    subscriptionPlan?: $Enums.SubscriptionPlan | null
    trialStartedAt?: Date | string | null
    trialEndsAt?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    razorpayCustomerId?: string | null
    razorpayPaymentId?: string | null
    razorpayOrderId?: string | null
    ownedOrganizations?: OrganizationUncheckedCreateNestedManyWithoutOwnerInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    reviewReplies?: ReviewReplyUncheckedCreateNestedManyWithoutUserInput
    locations?: LocationUncheckedCreateNestedManyWithoutUsersInput
    organizations?: OrganizationUncheckedCreateNestedManyWithoutMembersInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    subscriptionPlan?: NullableEnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan | null
    trialStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    ownedOrganizations?: OrganizationUpdateManyWithoutOwnerNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    reviewReplies?: ReviewReplyUpdateManyWithoutUserNestedInput
    locations?: LocationUpdateManyWithoutUsersNestedInput
    organizations?: OrganizationUpdateManyWithoutMembersNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    subscriptionPlan?: NullableEnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan | null
    trialStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    ownedOrganizations?: OrganizationUncheckedUpdateManyWithoutOwnerNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    reviewReplies?: ReviewReplyUncheckedUpdateManyWithoutUserNestedInput
    locations?: LocationUncheckedUpdateManyWithoutUsersNestedInput
    organizations?: OrganizationUncheckedUpdateManyWithoutMembersNestedInput
  }

  export type AIReplyTemplateCreateWithoutOrganizationInput = {
    id?: string
    name: string
    content: string
    tone?: $Enums.ReplyTone
    sentiment: $Enums.SentimentType
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: ReviewReplyCreateNestedManyWithoutAiTemplateInput
  }

  export type AIReplyTemplateUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    content: string
    tone?: $Enums.ReplyTone
    sentiment: $Enums.SentimentType
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: ReviewReplyUncheckedCreateNestedManyWithoutAiTemplateInput
  }

  export type AIReplyTemplateCreateOrConnectWithoutOrganizationInput = {
    where: AIReplyTemplateWhereUniqueInput
    create: XOR<AIReplyTemplateCreateWithoutOrganizationInput, AIReplyTemplateUncheckedCreateWithoutOrganizationInput>
  }

  export type AIReplyTemplateCreateManyOrganizationInputEnvelope = {
    data: AIReplyTemplateCreateManyOrganizationInput | AIReplyTemplateCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type LocationCreateWithoutOrganizationInput = {
    id?: string
    name: string
    gmbLocationId: string
    gmbLocationName: string
    address?: string | null
    phone?: string | null
    websiteUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    timezone?: string
    isVerified?: boolean
    lastSyncedAt?: Date | string
    lastFetchedTimestamp?: Date | string | null
    autoReplyEnabled?: boolean
    autoPostEnabled?: boolean
    replyTonePreference?: $Enums.ReplyTone | null
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    logoUrl?: string | null
    gmbAccountId?: string | null
    insights?: InsightCreateNestedManyWithoutLocationInput
    posts?: PostCreateNestedManyWithoutLocationInput
    reports?: ReportCreateNestedManyWithoutLocationInput
    reviews?: ReviewCreateNestedManyWithoutLocationInput
    users?: UserCreateNestedManyWithoutLocationsInput
    searchKeywords?: SearchKeywordCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    gmbLocationId: string
    gmbLocationName: string
    address?: string | null
    phone?: string | null
    websiteUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    timezone?: string
    isVerified?: boolean
    lastSyncedAt?: Date | string
    lastFetchedTimestamp?: Date | string | null
    autoReplyEnabled?: boolean
    autoPostEnabled?: boolean
    replyTonePreference?: $Enums.ReplyTone | null
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    logoUrl?: string | null
    gmbAccountId?: string | null
    insights?: InsightUncheckedCreateNestedManyWithoutLocationInput
    posts?: PostUncheckedCreateNestedManyWithoutLocationInput
    reports?: ReportUncheckedCreateNestedManyWithoutLocationInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutLocationInput
    users?: UserUncheckedCreateNestedManyWithoutLocationsInput
    searchKeywords?: SearchKeywordUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutOrganizationInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutOrganizationInput, LocationUncheckedCreateWithoutOrganizationInput>
  }

  export type LocationCreateManyOrganizationInputEnvelope = {
    data: LocationCreateManyOrganizationInput | LocationCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutOwnedOrganizationsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    emailVerificationToken?: string | null
    password: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiresAt?: Date | string | null
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    subscriptionPlan?: $Enums.SubscriptionPlan | null
    trialStartedAt?: Date | string | null
    trialEndsAt?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    razorpayCustomerId?: string | null
    razorpayPaymentId?: string | null
    razorpayOrderId?: string | null
    posts?: PostCreateNestedManyWithoutUserInput
    reviewReplies?: ReviewReplyCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    locations?: LocationCreateNestedManyWithoutUsersInput
    organizations?: OrganizationCreateNestedManyWithoutMembersInput
  }

  export type UserUncheckedCreateWithoutOwnedOrganizationsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    emailVerificationToken?: string | null
    password: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiresAt?: Date | string | null
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    subscriptionPlan?: $Enums.SubscriptionPlan | null
    trialStartedAt?: Date | string | null
    trialEndsAt?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    razorpayCustomerId?: string | null
    razorpayPaymentId?: string | null
    razorpayOrderId?: string | null
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    reviewReplies?: ReviewReplyUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    locations?: LocationUncheckedCreateNestedManyWithoutUsersInput
    organizations?: OrganizationUncheckedCreateNestedManyWithoutMembersInput
  }

  export type UserCreateOrConnectWithoutOwnedOrganizationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedOrganizationsInput, UserUncheckedCreateWithoutOwnedOrganizationsInput>
  }

  export type ReportJobCreateWithoutOrganizationInput = {
    id?: string
    name: string
    locations?: ReportJobCreatelocationsInput | string[]
    frequency: $Enums.ReportFrequency
    emailRecipients?: ReportJobCreateemailRecipientsInput | string[]
    isActive?: boolean
    lastRunAt?: Date | string | null
    nextRunAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportJobUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    locations?: ReportJobCreatelocationsInput | string[]
    frequency: $Enums.ReportFrequency
    emailRecipients?: ReportJobCreateemailRecipientsInput | string[]
    isActive?: boolean
    lastRunAt?: Date | string | null
    nextRunAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportJobCreateOrConnectWithoutOrganizationInput = {
    where: ReportJobWhereUniqueInput
    create: XOR<ReportJobCreateWithoutOrganizationInput, ReportJobUncheckedCreateWithoutOrganizationInput>
  }

  export type ReportJobCreateManyOrganizationInputEnvelope = {
    data: ReportJobCreateManyOrganizationInput | ReportJobCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutOrganizationsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    emailVerificationToken?: string | null
    password: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiresAt?: Date | string | null
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    subscriptionPlan?: $Enums.SubscriptionPlan | null
    trialStartedAt?: Date | string | null
    trialEndsAt?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    razorpayCustomerId?: string | null
    razorpayPaymentId?: string | null
    razorpayOrderId?: string | null
    ownedOrganizations?: OrganizationCreateNestedManyWithoutOwnerInput
    posts?: PostCreateNestedManyWithoutUserInput
    reviewReplies?: ReviewReplyCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    locations?: LocationCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutOrganizationsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    emailVerificationToken?: string | null
    password: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiresAt?: Date | string | null
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    subscriptionPlan?: $Enums.SubscriptionPlan | null
    trialStartedAt?: Date | string | null
    trialEndsAt?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    razorpayCustomerId?: string | null
    razorpayPaymentId?: string | null
    razorpayOrderId?: string | null
    ownedOrganizations?: OrganizationUncheckedCreateNestedManyWithoutOwnerInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    reviewReplies?: ReviewReplyUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    locations?: LocationUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutOrganizationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrganizationsInput, UserUncheckedCreateWithoutOrganizationsInput>
  }

  export type AIReplyTemplateUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: AIReplyTemplateWhereUniqueInput
    update: XOR<AIReplyTemplateUpdateWithoutOrganizationInput, AIReplyTemplateUncheckedUpdateWithoutOrganizationInput>
    create: XOR<AIReplyTemplateCreateWithoutOrganizationInput, AIReplyTemplateUncheckedCreateWithoutOrganizationInput>
  }

  export type AIReplyTemplateUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: AIReplyTemplateWhereUniqueInput
    data: XOR<AIReplyTemplateUpdateWithoutOrganizationInput, AIReplyTemplateUncheckedUpdateWithoutOrganizationInput>
  }

  export type AIReplyTemplateUpdateManyWithWhereWithoutOrganizationInput = {
    where: AIReplyTemplateScalarWhereInput
    data: XOR<AIReplyTemplateUpdateManyMutationInput, AIReplyTemplateUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type AIReplyTemplateScalarWhereInput = {
    AND?: AIReplyTemplateScalarWhereInput | AIReplyTemplateScalarWhereInput[]
    OR?: AIReplyTemplateScalarWhereInput[]
    NOT?: AIReplyTemplateScalarWhereInput | AIReplyTemplateScalarWhereInput[]
    id?: StringFilter<"AIReplyTemplate"> | string
    organizationId?: StringFilter<"AIReplyTemplate"> | string
    name?: StringFilter<"AIReplyTemplate"> | string
    content?: StringFilter<"AIReplyTemplate"> | string
    tone?: EnumReplyToneFilter<"AIReplyTemplate"> | $Enums.ReplyTone
    sentiment?: EnumSentimentTypeFilter<"AIReplyTemplate"> | $Enums.SentimentType
    isDefault?: BoolFilter<"AIReplyTemplate"> | boolean
    createdAt?: DateTimeFilter<"AIReplyTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"AIReplyTemplate"> | Date | string
  }

  export type LocationUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: LocationWhereUniqueInput
    update: XOR<LocationUpdateWithoutOrganizationInput, LocationUncheckedUpdateWithoutOrganizationInput>
    create: XOR<LocationCreateWithoutOrganizationInput, LocationUncheckedCreateWithoutOrganizationInput>
  }

  export type LocationUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: LocationWhereUniqueInput
    data: XOR<LocationUpdateWithoutOrganizationInput, LocationUncheckedUpdateWithoutOrganizationInput>
  }

  export type LocationUpdateManyWithWhereWithoutOrganizationInput = {
    where: LocationScalarWhereInput
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type UserUpsertWithoutOwnedOrganizationsInput = {
    update: XOR<UserUpdateWithoutOwnedOrganizationsInput, UserUncheckedUpdateWithoutOwnedOrganizationsInput>
    create: XOR<UserCreateWithoutOwnedOrganizationsInput, UserUncheckedCreateWithoutOwnedOrganizationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedOrganizationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedOrganizationsInput, UserUncheckedUpdateWithoutOwnedOrganizationsInput>
  }

  export type UserUpdateWithoutOwnedOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    subscriptionPlan?: NullableEnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan | null
    trialStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: PostUpdateManyWithoutUserNestedInput
    reviewReplies?: ReviewReplyUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    locations?: LocationUpdateManyWithoutUsersNestedInput
    organizations?: OrganizationUpdateManyWithoutMembersNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    subscriptionPlan?: NullableEnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan | null
    trialStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    reviewReplies?: ReviewReplyUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    locations?: LocationUncheckedUpdateManyWithoutUsersNestedInput
    organizations?: OrganizationUncheckedUpdateManyWithoutMembersNestedInput
  }

  export type ReportJobUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ReportJobWhereUniqueInput
    update: XOR<ReportJobUpdateWithoutOrganizationInput, ReportJobUncheckedUpdateWithoutOrganizationInput>
    create: XOR<ReportJobCreateWithoutOrganizationInput, ReportJobUncheckedCreateWithoutOrganizationInput>
  }

  export type ReportJobUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ReportJobWhereUniqueInput
    data: XOR<ReportJobUpdateWithoutOrganizationInput, ReportJobUncheckedUpdateWithoutOrganizationInput>
  }

  export type ReportJobUpdateManyWithWhereWithoutOrganizationInput = {
    where: ReportJobScalarWhereInput
    data: XOR<ReportJobUpdateManyMutationInput, ReportJobUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type ReportJobScalarWhereInput = {
    AND?: ReportJobScalarWhereInput | ReportJobScalarWhereInput[]
    OR?: ReportJobScalarWhereInput[]
    NOT?: ReportJobScalarWhereInput | ReportJobScalarWhereInput[]
    id?: StringFilter<"ReportJob"> | string
    organizationId?: StringFilter<"ReportJob"> | string
    name?: StringFilter<"ReportJob"> | string
    locations?: StringNullableListFilter<"ReportJob">
    frequency?: EnumReportFrequencyFilter<"ReportJob"> | $Enums.ReportFrequency
    emailRecipients?: StringNullableListFilter<"ReportJob">
    isActive?: BoolFilter<"ReportJob"> | boolean
    lastRunAt?: DateTimeNullableFilter<"ReportJob"> | Date | string | null
    nextRunAt?: DateTimeFilter<"ReportJob"> | Date | string
    createdAt?: DateTimeFilter<"ReportJob"> | Date | string
    updatedAt?: DateTimeFilter<"ReportJob"> | Date | string
  }

  export type UserUpsertWithWhereUniqueWithoutOrganizationsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutOrganizationsInput, UserUncheckedUpdateWithoutOrganizationsInput>
    create: XOR<UserCreateWithoutOrganizationsInput, UserUncheckedCreateWithoutOrganizationsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutOrganizationsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutOrganizationsInput, UserUncheckedUpdateWithoutOrganizationsInput>
  }

  export type UserUpdateManyWithWhereWithoutOrganizationsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutOrganizationsInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    emailVerificationToken?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    googleAccessToken?: StringNullableFilter<"User"> | string | null
    googleRefreshToken?: StringNullableFilter<"User"> | string | null
    googleTokenExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    subscriptionId?: StringNullableFilter<"User"> | string | null
    subscriptionStatus?: EnumSubscriptionStatusNullableFilter<"User"> | $Enums.SubscriptionStatus | null
    subscriptionPlan?: EnumSubscriptionPlanNullableFilter<"User"> | $Enums.SubscriptionPlan | null
    trialStartedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    trialEndsAt?: DateTimeNullableFilter<"User"> | Date | string | null
    currentPeriodStart?: DateTimeNullableFilter<"User"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"User"> | Date | string | null
    razorpayCustomerId?: StringNullableFilter<"User"> | string | null
    razorpayPaymentId?: StringNullableFilter<"User"> | string | null
    razorpayOrderId?: StringNullableFilter<"User"> | string | null
  }

  export type InsightCreateWithoutLocationInput = {
    id?: string
    date: Date | string
    type: $Enums.InsightType
    value: number
    createdAt?: Date | string
  }

  export type InsightUncheckedCreateWithoutLocationInput = {
    id?: string
    date: Date | string
    type: $Enums.InsightType
    value: number
    createdAt?: Date | string
  }

  export type InsightCreateOrConnectWithoutLocationInput = {
    where: InsightWhereUniqueInput
    create: XOR<InsightCreateWithoutLocationInput, InsightUncheckedCreateWithoutLocationInput>
  }

  export type InsightCreateManyLocationInputEnvelope = {
    data: InsightCreateManyLocationInput | InsightCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationCreateWithoutLocationsInput = {
    id?: string
    name: string
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiTemplates?: AIReplyTemplateCreateNestedManyWithoutOrganizationInput
    owner: UserCreateNestedOneWithoutOwnedOrganizationsInput
    reportJobs?: ReportJobCreateNestedManyWithoutOrganizationInput
    members?: UserCreateNestedManyWithoutOrganizationsInput
  }

  export type OrganizationUncheckedCreateWithoutLocationsInput = {
    id?: string
    name: string
    logo?: string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    aiTemplates?: AIReplyTemplateUncheckedCreateNestedManyWithoutOrganizationInput
    reportJobs?: ReportJobUncheckedCreateNestedManyWithoutOrganizationInput
    members?: UserUncheckedCreateNestedManyWithoutOrganizationsInput
  }

  export type OrganizationCreateOrConnectWithoutLocationsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutLocationsInput, OrganizationUncheckedCreateWithoutLocationsInput>
  }

  export type PostCreateWithoutLocationInput = {
    id?: string
    title: string
    content: string
    type: $Enums.PostType
    mediaUrls?: PostCreatemediaUrlsInput | string[]
    scheduledAt: Date | string
    publishedAt?: Date | string | null
    status?: $Enums.PostStatus
    eventStart?: Date | string | null
    eventEnd?: Date | string | null
    offerStart?: Date | string | null
    offerEnd?: Date | string | null
    couponCode?: string | null
    callToAction?: string | null
    recurType?: $Enums.RecurType | null
    recurEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutLocationInput = {
    id?: string
    userId: string
    title: string
    content: string
    type: $Enums.PostType
    mediaUrls?: PostCreatemediaUrlsInput | string[]
    scheduledAt: Date | string
    publishedAt?: Date | string | null
    status?: $Enums.PostStatus
    eventStart?: Date | string | null
    eventEnd?: Date | string | null
    offerStart?: Date | string | null
    offerEnd?: Date | string | null
    couponCode?: string | null
    callToAction?: string | null
    recurType?: $Enums.RecurType | null
    recurEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostCreateOrConnectWithoutLocationInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutLocationInput, PostUncheckedCreateWithoutLocationInput>
  }

  export type PostCreateManyLocationInputEnvelope = {
    data: PostCreateManyLocationInput | PostCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutLocationInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    reportType: $Enums.ReportType
    fileUrl?: string | null
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportUncheckedCreateWithoutLocationInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    reportType: $Enums.ReportType
    fileUrl?: string | null
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutLocationInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutLocationInput, ReportUncheckedCreateWithoutLocationInput>
  }

  export type ReportCreateManyLocationInputEnvelope = {
    data: ReportCreateManyLocationInput | ReportCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutLocationInput = {
    id?: string
    reviewId: string
    authorName: string
    authorPhoto?: string | null
    rating: number
    comment?: string | null
    createTime: Date | string
    updateTime: Date | string
    status?: $Enums.ReviewStatus
    isProcessed?: boolean
    sentiment?: $Enums.SentimentType | null
    language?: string | null
    isReplyNeeded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: ReviewReplyCreateNestedManyWithoutReviewInput
  }

  export type ReviewUncheckedCreateWithoutLocationInput = {
    id?: string
    reviewId: string
    authorName: string
    authorPhoto?: string | null
    rating: number
    comment?: string | null
    createTime: Date | string
    updateTime: Date | string
    status?: $Enums.ReviewStatus
    isProcessed?: boolean
    sentiment?: $Enums.SentimentType | null
    language?: string | null
    isReplyNeeded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: ReviewReplyUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewCreateOrConnectWithoutLocationInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutLocationInput, ReviewUncheckedCreateWithoutLocationInput>
  }

  export type ReviewCreateManyLocationInputEnvelope = {
    data: ReviewCreateManyLocationInput | ReviewCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutLocationsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    emailVerificationToken?: string | null
    password: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiresAt?: Date | string | null
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    subscriptionPlan?: $Enums.SubscriptionPlan | null
    trialStartedAt?: Date | string | null
    trialEndsAt?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    razorpayCustomerId?: string | null
    razorpayPaymentId?: string | null
    razorpayOrderId?: string | null
    ownedOrganizations?: OrganizationCreateNestedManyWithoutOwnerInput
    posts?: PostCreateNestedManyWithoutUserInput
    reviewReplies?: ReviewReplyCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    organizations?: OrganizationCreateNestedManyWithoutMembersInput
  }

  export type UserUncheckedCreateWithoutLocationsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    emailVerificationToken?: string | null
    password: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiresAt?: Date | string | null
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    subscriptionPlan?: $Enums.SubscriptionPlan | null
    trialStartedAt?: Date | string | null
    trialEndsAt?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    razorpayCustomerId?: string | null
    razorpayPaymentId?: string | null
    razorpayOrderId?: string | null
    ownedOrganizations?: OrganizationUncheckedCreateNestedManyWithoutOwnerInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    reviewReplies?: ReviewReplyUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    organizations?: OrganizationUncheckedCreateNestedManyWithoutMembersInput
  }

  export type UserCreateOrConnectWithoutLocationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLocationsInput, UserUncheckedCreateWithoutLocationsInput>
  }

  export type SearchKeywordCreateWithoutLocationInput = {
    id?: string
    keyword: string
    latitude: number
    longitude: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rankResults?: RankTrackingResultCreateNestedManyWithoutKeywordInput
  }

  export type SearchKeywordUncheckedCreateWithoutLocationInput = {
    id?: string
    keyword: string
    latitude: number
    longitude: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rankResults?: RankTrackingResultUncheckedCreateNestedManyWithoutKeywordInput
  }

  export type SearchKeywordCreateOrConnectWithoutLocationInput = {
    where: SearchKeywordWhereUniqueInput
    create: XOR<SearchKeywordCreateWithoutLocationInput, SearchKeywordUncheckedCreateWithoutLocationInput>
  }

  export type SearchKeywordCreateManyLocationInputEnvelope = {
    data: SearchKeywordCreateManyLocationInput | SearchKeywordCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type InsightUpsertWithWhereUniqueWithoutLocationInput = {
    where: InsightWhereUniqueInput
    update: XOR<InsightUpdateWithoutLocationInput, InsightUncheckedUpdateWithoutLocationInput>
    create: XOR<InsightCreateWithoutLocationInput, InsightUncheckedCreateWithoutLocationInput>
  }

  export type InsightUpdateWithWhereUniqueWithoutLocationInput = {
    where: InsightWhereUniqueInput
    data: XOR<InsightUpdateWithoutLocationInput, InsightUncheckedUpdateWithoutLocationInput>
  }

  export type InsightUpdateManyWithWhereWithoutLocationInput = {
    where: InsightScalarWhereInput
    data: XOR<InsightUpdateManyMutationInput, InsightUncheckedUpdateManyWithoutLocationInput>
  }

  export type InsightScalarWhereInput = {
    AND?: InsightScalarWhereInput | InsightScalarWhereInput[]
    OR?: InsightScalarWhereInput[]
    NOT?: InsightScalarWhereInput | InsightScalarWhereInput[]
    id?: StringFilter<"Insight"> | string
    locationId?: StringFilter<"Insight"> | string
    date?: DateTimeFilter<"Insight"> | Date | string
    type?: EnumInsightTypeFilter<"Insight"> | $Enums.InsightType
    value?: IntFilter<"Insight"> | number
    createdAt?: DateTimeFilter<"Insight"> | Date | string
  }

  export type OrganizationUpsertWithoutLocationsInput = {
    update: XOR<OrganizationUpdateWithoutLocationsInput, OrganizationUncheckedUpdateWithoutLocationsInput>
    create: XOR<OrganizationCreateWithoutLocationsInput, OrganizationUncheckedCreateWithoutLocationsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutLocationsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutLocationsInput, OrganizationUncheckedUpdateWithoutLocationsInput>
  }

  export type OrganizationUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiTemplates?: AIReplyTemplateUpdateManyWithoutOrganizationNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedOrganizationsNestedInput
    reportJobs?: ReportJobUpdateManyWithoutOrganizationNestedInput
    members?: UserUpdateManyWithoutOrganizationsNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiTemplates?: AIReplyTemplateUncheckedUpdateManyWithoutOrganizationNestedInput
    reportJobs?: ReportJobUncheckedUpdateManyWithoutOrganizationNestedInput
    members?: UserUncheckedUpdateManyWithoutOrganizationsNestedInput
  }

  export type PostUpsertWithWhereUniqueWithoutLocationInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutLocationInput, PostUncheckedUpdateWithoutLocationInput>
    create: XOR<PostCreateWithoutLocationInput, PostUncheckedCreateWithoutLocationInput>
  }

  export type PostUpdateWithWhereUniqueWithoutLocationInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutLocationInput, PostUncheckedUpdateWithoutLocationInput>
  }

  export type PostUpdateManyWithWhereWithoutLocationInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutLocationInput>
  }

  export type ReportUpsertWithWhereUniqueWithoutLocationInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutLocationInput, ReportUncheckedUpdateWithoutLocationInput>
    create: XOR<ReportCreateWithoutLocationInput, ReportUncheckedCreateWithoutLocationInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutLocationInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutLocationInput, ReportUncheckedUpdateWithoutLocationInput>
  }

  export type ReportUpdateManyWithWhereWithoutLocationInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutLocationInput>
  }

  export type ReportScalarWhereInput = {
    AND?: ReportScalarWhereInput | ReportScalarWhereInput[]
    OR?: ReportScalarWhereInput[]
    NOT?: ReportScalarWhereInput | ReportScalarWhereInput[]
    id?: StringFilter<"Report"> | string
    locationId?: StringFilter<"Report"> | string
    name?: StringFilter<"Report"> | string
    startDate?: DateTimeFilter<"Report"> | Date | string
    endDate?: DateTimeFilter<"Report"> | Date | string
    reportType?: EnumReportTypeFilter<"Report"> | $Enums.ReportType
    fileUrl?: StringNullableFilter<"Report"> | string | null
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutLocationInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutLocationInput, ReviewUncheckedUpdateWithoutLocationInput>
    create: XOR<ReviewCreateWithoutLocationInput, ReviewUncheckedCreateWithoutLocationInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutLocationInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutLocationInput, ReviewUncheckedUpdateWithoutLocationInput>
  }

  export type ReviewUpdateManyWithWhereWithoutLocationInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutLocationInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: StringFilter<"Review"> | string
    locationId?: StringFilter<"Review"> | string
    reviewId?: StringFilter<"Review"> | string
    authorName?: StringFilter<"Review"> | string
    authorPhoto?: StringNullableFilter<"Review"> | string | null
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    createTime?: DateTimeFilter<"Review"> | Date | string
    updateTime?: DateTimeFilter<"Review"> | Date | string
    status?: EnumReviewStatusFilter<"Review"> | $Enums.ReviewStatus
    isProcessed?: BoolFilter<"Review"> | boolean
    sentiment?: EnumSentimentTypeNullableFilter<"Review"> | $Enums.SentimentType | null
    language?: StringNullableFilter<"Review"> | string | null
    isReplyNeeded?: BoolFilter<"Review"> | boolean
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
  }

  export type UserUpsertWithWhereUniqueWithoutLocationsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutLocationsInput, UserUncheckedUpdateWithoutLocationsInput>
    create: XOR<UserCreateWithoutLocationsInput, UserUncheckedCreateWithoutLocationsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutLocationsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutLocationsInput, UserUncheckedUpdateWithoutLocationsInput>
  }

  export type UserUpdateManyWithWhereWithoutLocationsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutLocationsInput>
  }

  export type SearchKeywordUpsertWithWhereUniqueWithoutLocationInput = {
    where: SearchKeywordWhereUniqueInput
    update: XOR<SearchKeywordUpdateWithoutLocationInput, SearchKeywordUncheckedUpdateWithoutLocationInput>
    create: XOR<SearchKeywordCreateWithoutLocationInput, SearchKeywordUncheckedCreateWithoutLocationInput>
  }

  export type SearchKeywordUpdateWithWhereUniqueWithoutLocationInput = {
    where: SearchKeywordWhereUniqueInput
    data: XOR<SearchKeywordUpdateWithoutLocationInput, SearchKeywordUncheckedUpdateWithoutLocationInput>
  }

  export type SearchKeywordUpdateManyWithWhereWithoutLocationInput = {
    where: SearchKeywordScalarWhereInput
    data: XOR<SearchKeywordUpdateManyMutationInput, SearchKeywordUncheckedUpdateManyWithoutLocationInput>
  }

  export type SearchKeywordScalarWhereInput = {
    AND?: SearchKeywordScalarWhereInput | SearchKeywordScalarWhereInput[]
    OR?: SearchKeywordScalarWhereInput[]
    NOT?: SearchKeywordScalarWhereInput | SearchKeywordScalarWhereInput[]
    id?: StringFilter<"SearchKeyword"> | string
    keyword?: StringFilter<"SearchKeyword"> | string
    locationId?: StringFilter<"SearchKeyword"> | string
    latitude?: FloatFilter<"SearchKeyword"> | number
    longitude?: FloatFilter<"SearchKeyword"> | number
    createdAt?: DateTimeFilter<"SearchKeyword"> | Date | string
    updatedAt?: DateTimeFilter<"SearchKeyword"> | Date | string
  }

  export type LocationCreateWithoutPostsInput = {
    id?: string
    name: string
    gmbLocationId: string
    gmbLocationName: string
    address?: string | null
    phone?: string | null
    websiteUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    timezone?: string
    isVerified?: boolean
    lastSyncedAt?: Date | string
    lastFetchedTimestamp?: Date | string | null
    autoReplyEnabled?: boolean
    autoPostEnabled?: boolean
    replyTonePreference?: $Enums.ReplyTone | null
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    logoUrl?: string | null
    gmbAccountId?: string | null
    insights?: InsightCreateNestedManyWithoutLocationInput
    organization: OrganizationCreateNestedOneWithoutLocationsInput
    reports?: ReportCreateNestedManyWithoutLocationInput
    reviews?: ReviewCreateNestedManyWithoutLocationInput
    users?: UserCreateNestedManyWithoutLocationsInput
    searchKeywords?: SearchKeywordCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutPostsInput = {
    id?: string
    name: string
    organizationId: string
    gmbLocationId: string
    gmbLocationName: string
    address?: string | null
    phone?: string | null
    websiteUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    timezone?: string
    isVerified?: boolean
    lastSyncedAt?: Date | string
    lastFetchedTimestamp?: Date | string | null
    autoReplyEnabled?: boolean
    autoPostEnabled?: boolean
    replyTonePreference?: $Enums.ReplyTone | null
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    logoUrl?: string | null
    gmbAccountId?: string | null
    insights?: InsightUncheckedCreateNestedManyWithoutLocationInput
    reports?: ReportUncheckedCreateNestedManyWithoutLocationInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutLocationInput
    users?: UserUncheckedCreateNestedManyWithoutLocationsInput
    searchKeywords?: SearchKeywordUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutPostsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutPostsInput, LocationUncheckedCreateWithoutPostsInput>
  }

  export type UserCreateWithoutPostsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    emailVerificationToken?: string | null
    password: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiresAt?: Date | string | null
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    subscriptionPlan?: $Enums.SubscriptionPlan | null
    trialStartedAt?: Date | string | null
    trialEndsAt?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    razorpayCustomerId?: string | null
    razorpayPaymentId?: string | null
    razorpayOrderId?: string | null
    ownedOrganizations?: OrganizationCreateNestedManyWithoutOwnerInput
    reviewReplies?: ReviewReplyCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    locations?: LocationCreateNestedManyWithoutUsersInput
    organizations?: OrganizationCreateNestedManyWithoutMembersInput
  }

  export type UserUncheckedCreateWithoutPostsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    emailVerificationToken?: string | null
    password: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiresAt?: Date | string | null
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    subscriptionPlan?: $Enums.SubscriptionPlan | null
    trialStartedAt?: Date | string | null
    trialEndsAt?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    razorpayCustomerId?: string | null
    razorpayPaymentId?: string | null
    razorpayOrderId?: string | null
    ownedOrganizations?: OrganizationUncheckedCreateNestedManyWithoutOwnerInput
    reviewReplies?: ReviewReplyUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    locations?: LocationUncheckedCreateNestedManyWithoutUsersInput
    organizations?: OrganizationUncheckedCreateNestedManyWithoutMembersInput
  }

  export type UserCreateOrConnectWithoutPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
  }

  export type LocationUpsertWithoutPostsInput = {
    update: XOR<LocationUpdateWithoutPostsInput, LocationUncheckedUpdateWithoutPostsInput>
    create: XOR<LocationCreateWithoutPostsInput, LocationUncheckedCreateWithoutPostsInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutPostsInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutPostsInput, LocationUncheckedUpdateWithoutPostsInput>
  }

  export type LocationUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gmbLocationId?: StringFieldUpdateOperationsInput | string
    gmbLocationName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastSyncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastFetchedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoReplyEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoPostEnabled?: BoolFieldUpdateOperationsInput | boolean
    replyTonePreference?: NullableEnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gmbAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    insights?: InsightUpdateManyWithoutLocationNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutLocationsNestedInput
    reports?: ReportUpdateManyWithoutLocationNestedInput
    reviews?: ReviewUpdateManyWithoutLocationNestedInput
    users?: UserUpdateManyWithoutLocationsNestedInput
    searchKeywords?: SearchKeywordUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    gmbLocationId?: StringFieldUpdateOperationsInput | string
    gmbLocationName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastSyncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastFetchedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoReplyEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoPostEnabled?: BoolFieldUpdateOperationsInput | boolean
    replyTonePreference?: NullableEnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gmbAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    insights?: InsightUncheckedUpdateManyWithoutLocationNestedInput
    reports?: ReportUncheckedUpdateManyWithoutLocationNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutLocationNestedInput
    users?: UserUncheckedUpdateManyWithoutLocationsNestedInput
    searchKeywords?: SearchKeywordUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type UserUpsertWithoutPostsInput = {
    update: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
  }

  export type UserUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    subscriptionPlan?: NullableEnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan | null
    trialStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    ownedOrganizations?: OrganizationUpdateManyWithoutOwnerNestedInput
    reviewReplies?: ReviewReplyUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    locations?: LocationUpdateManyWithoutUsersNestedInput
    organizations?: OrganizationUpdateManyWithoutMembersNestedInput
  }

  export type UserUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    subscriptionPlan?: NullableEnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan | null
    trialStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    ownedOrganizations?: OrganizationUncheckedUpdateManyWithoutOwnerNestedInput
    reviewReplies?: ReviewReplyUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    locations?: LocationUncheckedUpdateManyWithoutUsersNestedInput
    organizations?: OrganizationUncheckedUpdateManyWithoutMembersNestedInput
  }

  export type LocationCreateWithoutReviewsInput = {
    id?: string
    name: string
    gmbLocationId: string
    gmbLocationName: string
    address?: string | null
    phone?: string | null
    websiteUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    timezone?: string
    isVerified?: boolean
    lastSyncedAt?: Date | string
    lastFetchedTimestamp?: Date | string | null
    autoReplyEnabled?: boolean
    autoPostEnabled?: boolean
    replyTonePreference?: $Enums.ReplyTone | null
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    logoUrl?: string | null
    gmbAccountId?: string | null
    insights?: InsightCreateNestedManyWithoutLocationInput
    organization: OrganizationCreateNestedOneWithoutLocationsInput
    posts?: PostCreateNestedManyWithoutLocationInput
    reports?: ReportCreateNestedManyWithoutLocationInput
    users?: UserCreateNestedManyWithoutLocationsInput
    searchKeywords?: SearchKeywordCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutReviewsInput = {
    id?: string
    name: string
    organizationId: string
    gmbLocationId: string
    gmbLocationName: string
    address?: string | null
    phone?: string | null
    websiteUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    timezone?: string
    isVerified?: boolean
    lastSyncedAt?: Date | string
    lastFetchedTimestamp?: Date | string | null
    autoReplyEnabled?: boolean
    autoPostEnabled?: boolean
    replyTonePreference?: $Enums.ReplyTone | null
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    logoUrl?: string | null
    gmbAccountId?: string | null
    insights?: InsightUncheckedCreateNestedManyWithoutLocationInput
    posts?: PostUncheckedCreateNestedManyWithoutLocationInput
    reports?: ReportUncheckedCreateNestedManyWithoutLocationInput
    users?: UserUncheckedCreateNestedManyWithoutLocationsInput
    searchKeywords?: SearchKeywordUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutReviewsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutReviewsInput, LocationUncheckedCreateWithoutReviewsInput>
  }

  export type ReviewReplyCreateWithoutReviewInput = {
    id?: string
    content: string
    source: $Enums.ReplySource
    tone?: $Enums.ReplyTone
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiTemplate?: AIReplyTemplateCreateNestedOneWithoutRepliesInput
    user?: UserCreateNestedOneWithoutReviewRepliesInput
  }

  export type ReviewReplyUncheckedCreateWithoutReviewInput = {
    id?: string
    userId?: string | null
    content: string
    source: $Enums.ReplySource
    tone?: $Enums.ReplyTone
    isPublished?: boolean
    publishedAt?: Date | string | null
    aiTemplateId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewReplyCreateOrConnectWithoutReviewInput = {
    where: ReviewReplyWhereUniqueInput
    create: XOR<ReviewReplyCreateWithoutReviewInput, ReviewReplyUncheckedCreateWithoutReviewInput>
  }

  export type ReviewReplyCreateManyReviewInputEnvelope = {
    data: ReviewReplyCreateManyReviewInput | ReviewReplyCreateManyReviewInput[]
    skipDuplicates?: boolean
  }

  export type LocationUpsertWithoutReviewsInput = {
    update: XOR<LocationUpdateWithoutReviewsInput, LocationUncheckedUpdateWithoutReviewsInput>
    create: XOR<LocationCreateWithoutReviewsInput, LocationUncheckedCreateWithoutReviewsInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutReviewsInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutReviewsInput, LocationUncheckedUpdateWithoutReviewsInput>
  }

  export type LocationUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gmbLocationId?: StringFieldUpdateOperationsInput | string
    gmbLocationName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastSyncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastFetchedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoReplyEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoPostEnabled?: BoolFieldUpdateOperationsInput | boolean
    replyTonePreference?: NullableEnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gmbAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    insights?: InsightUpdateManyWithoutLocationNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutLocationsNestedInput
    posts?: PostUpdateManyWithoutLocationNestedInput
    reports?: ReportUpdateManyWithoutLocationNestedInput
    users?: UserUpdateManyWithoutLocationsNestedInput
    searchKeywords?: SearchKeywordUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    gmbLocationId?: StringFieldUpdateOperationsInput | string
    gmbLocationName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastSyncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastFetchedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoReplyEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoPostEnabled?: BoolFieldUpdateOperationsInput | boolean
    replyTonePreference?: NullableEnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gmbAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    insights?: InsightUncheckedUpdateManyWithoutLocationNestedInput
    posts?: PostUncheckedUpdateManyWithoutLocationNestedInput
    reports?: ReportUncheckedUpdateManyWithoutLocationNestedInput
    users?: UserUncheckedUpdateManyWithoutLocationsNestedInput
    searchKeywords?: SearchKeywordUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type ReviewReplyUpsertWithWhereUniqueWithoutReviewInput = {
    where: ReviewReplyWhereUniqueInput
    update: XOR<ReviewReplyUpdateWithoutReviewInput, ReviewReplyUncheckedUpdateWithoutReviewInput>
    create: XOR<ReviewReplyCreateWithoutReviewInput, ReviewReplyUncheckedCreateWithoutReviewInput>
  }

  export type ReviewReplyUpdateWithWhereUniqueWithoutReviewInput = {
    where: ReviewReplyWhereUniqueInput
    data: XOR<ReviewReplyUpdateWithoutReviewInput, ReviewReplyUncheckedUpdateWithoutReviewInput>
  }

  export type ReviewReplyUpdateManyWithWhereWithoutReviewInput = {
    where: ReviewReplyScalarWhereInput
    data: XOR<ReviewReplyUpdateManyMutationInput, ReviewReplyUncheckedUpdateManyWithoutReviewInput>
  }

  export type AIReplyTemplateCreateWithoutRepliesInput = {
    id?: string
    name: string
    content: string
    tone?: $Enums.ReplyTone
    sentiment: $Enums.SentimentType
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutAiTemplatesInput
  }

  export type AIReplyTemplateUncheckedCreateWithoutRepliesInput = {
    id?: string
    organizationId: string
    name: string
    content: string
    tone?: $Enums.ReplyTone
    sentiment: $Enums.SentimentType
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIReplyTemplateCreateOrConnectWithoutRepliesInput = {
    where: AIReplyTemplateWhereUniqueInput
    create: XOR<AIReplyTemplateCreateWithoutRepliesInput, AIReplyTemplateUncheckedCreateWithoutRepliesInput>
  }

  export type ReviewCreateWithoutRepliesInput = {
    id?: string
    reviewId: string
    authorName: string
    authorPhoto?: string | null
    rating: number
    comment?: string | null
    createTime: Date | string
    updateTime: Date | string
    status?: $Enums.ReviewStatus
    isProcessed?: boolean
    sentiment?: $Enums.SentimentType | null
    language?: string | null
    isReplyNeeded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutRepliesInput = {
    id?: string
    locationId: string
    reviewId: string
    authorName: string
    authorPhoto?: string | null
    rating: number
    comment?: string | null
    createTime: Date | string
    updateTime: Date | string
    status?: $Enums.ReviewStatus
    isProcessed?: boolean
    sentiment?: $Enums.SentimentType | null
    language?: string | null
    isReplyNeeded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutRepliesInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutRepliesInput, ReviewUncheckedCreateWithoutRepliesInput>
  }

  export type UserCreateWithoutReviewRepliesInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    emailVerificationToken?: string | null
    password: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiresAt?: Date | string | null
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    subscriptionPlan?: $Enums.SubscriptionPlan | null
    trialStartedAt?: Date | string | null
    trialEndsAt?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    razorpayCustomerId?: string | null
    razorpayPaymentId?: string | null
    razorpayOrderId?: string | null
    ownedOrganizations?: OrganizationCreateNestedManyWithoutOwnerInput
    posts?: PostCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    locations?: LocationCreateNestedManyWithoutUsersInput
    organizations?: OrganizationCreateNestedManyWithoutMembersInput
  }

  export type UserUncheckedCreateWithoutReviewRepliesInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    emailVerificationToken?: string | null
    password: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiresAt?: Date | string | null
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    subscriptionPlan?: $Enums.SubscriptionPlan | null
    trialStartedAt?: Date | string | null
    trialEndsAt?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    razorpayCustomerId?: string | null
    razorpayPaymentId?: string | null
    razorpayOrderId?: string | null
    ownedOrganizations?: OrganizationUncheckedCreateNestedManyWithoutOwnerInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    locations?: LocationUncheckedCreateNestedManyWithoutUsersInput
    organizations?: OrganizationUncheckedCreateNestedManyWithoutMembersInput
  }

  export type UserCreateOrConnectWithoutReviewRepliesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewRepliesInput, UserUncheckedCreateWithoutReviewRepliesInput>
  }

  export type AIReplyTemplateUpsertWithoutRepliesInput = {
    update: XOR<AIReplyTemplateUpdateWithoutRepliesInput, AIReplyTemplateUncheckedUpdateWithoutRepliesInput>
    create: XOR<AIReplyTemplateCreateWithoutRepliesInput, AIReplyTemplateUncheckedCreateWithoutRepliesInput>
    where?: AIReplyTemplateWhereInput
  }

  export type AIReplyTemplateUpdateToOneWithWhereWithoutRepliesInput = {
    where?: AIReplyTemplateWhereInput
    data: XOR<AIReplyTemplateUpdateWithoutRepliesInput, AIReplyTemplateUncheckedUpdateWithoutRepliesInput>
  }

  export type AIReplyTemplateUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: EnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone
    sentiment?: EnumSentimentTypeFieldUpdateOperationsInput | $Enums.SentimentType
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutAiTemplatesNestedInput
  }

  export type AIReplyTemplateUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: EnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone
    sentiment?: EnumSentimentTypeFieldUpdateOperationsInput | $Enums.SentimentType
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpsertWithoutRepliesInput = {
    update: XOR<ReviewUpdateWithoutRepliesInput, ReviewUncheckedUpdateWithoutRepliesInput>
    create: XOR<ReviewCreateWithoutRepliesInput, ReviewUncheckedCreateWithoutRepliesInput>
    where?: ReviewWhereInput
  }

  export type ReviewUpdateToOneWithWhereWithoutRepliesInput = {
    where?: ReviewWhereInput
    data: XOR<ReviewUpdateWithoutRepliesInput, ReviewUncheckedUpdateWithoutRepliesInput>
  }

  export type ReviewUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createTime?: DateTimeFieldUpdateOperationsInput | Date | string
    updateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    sentiment?: NullableEnumSentimentTypeFieldUpdateOperationsInput | $Enums.SentimentType | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isReplyNeeded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createTime?: DateTimeFieldUpdateOperationsInput | Date | string
    updateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    sentiment?: NullableEnumSentimentTypeFieldUpdateOperationsInput | $Enums.SentimentType | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isReplyNeeded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutReviewRepliesInput = {
    update: XOR<UserUpdateWithoutReviewRepliesInput, UserUncheckedUpdateWithoutReviewRepliesInput>
    create: XOR<UserCreateWithoutReviewRepliesInput, UserUncheckedCreateWithoutReviewRepliesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewRepliesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewRepliesInput, UserUncheckedUpdateWithoutReviewRepliesInput>
  }

  export type UserUpdateWithoutReviewRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    subscriptionPlan?: NullableEnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan | null
    trialStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    ownedOrganizations?: OrganizationUpdateManyWithoutOwnerNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    locations?: LocationUpdateManyWithoutUsersNestedInput
    organizations?: OrganizationUpdateManyWithoutMembersNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    subscriptionPlan?: NullableEnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan | null
    trialStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    ownedOrganizations?: OrganizationUncheckedUpdateManyWithoutOwnerNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    locations?: LocationUncheckedUpdateManyWithoutUsersNestedInput
    organizations?: OrganizationUncheckedUpdateManyWithoutMembersNestedInput
  }

  export type OrganizationCreateWithoutAiTemplatesInput = {
    id?: string
    name: string
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationCreateNestedManyWithoutOrganizationInput
    owner: UserCreateNestedOneWithoutOwnedOrganizationsInput
    reportJobs?: ReportJobCreateNestedManyWithoutOrganizationInput
    members?: UserCreateNestedManyWithoutOrganizationsInput
  }

  export type OrganizationUncheckedCreateWithoutAiTemplatesInput = {
    id?: string
    name: string
    logo?: string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationUncheckedCreateNestedManyWithoutOrganizationInput
    reportJobs?: ReportJobUncheckedCreateNestedManyWithoutOrganizationInput
    members?: UserUncheckedCreateNestedManyWithoutOrganizationsInput
  }

  export type OrganizationCreateOrConnectWithoutAiTemplatesInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutAiTemplatesInput, OrganizationUncheckedCreateWithoutAiTemplatesInput>
  }

  export type ReviewReplyCreateWithoutAiTemplateInput = {
    id?: string
    content: string
    source: $Enums.ReplySource
    tone?: $Enums.ReplyTone
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    review: ReviewCreateNestedOneWithoutRepliesInput
    user?: UserCreateNestedOneWithoutReviewRepliesInput
  }

  export type ReviewReplyUncheckedCreateWithoutAiTemplateInput = {
    id?: string
    reviewId: string
    userId?: string | null
    content: string
    source: $Enums.ReplySource
    tone?: $Enums.ReplyTone
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewReplyCreateOrConnectWithoutAiTemplateInput = {
    where: ReviewReplyWhereUniqueInput
    create: XOR<ReviewReplyCreateWithoutAiTemplateInput, ReviewReplyUncheckedCreateWithoutAiTemplateInput>
  }

  export type ReviewReplyCreateManyAiTemplateInputEnvelope = {
    data: ReviewReplyCreateManyAiTemplateInput | ReviewReplyCreateManyAiTemplateInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutAiTemplatesInput = {
    update: XOR<OrganizationUpdateWithoutAiTemplatesInput, OrganizationUncheckedUpdateWithoutAiTemplatesInput>
    create: XOR<OrganizationCreateWithoutAiTemplatesInput, OrganizationUncheckedCreateWithoutAiTemplatesInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutAiTemplatesInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutAiTemplatesInput, OrganizationUncheckedUpdateWithoutAiTemplatesInput>
  }

  export type OrganizationUpdateWithoutAiTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUpdateManyWithoutOrganizationNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedOrganizationsNestedInput
    reportJobs?: ReportJobUpdateManyWithoutOrganizationNestedInput
    members?: UserUpdateManyWithoutOrganizationsNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutAiTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUncheckedUpdateManyWithoutOrganizationNestedInput
    reportJobs?: ReportJobUncheckedUpdateManyWithoutOrganizationNestedInput
    members?: UserUncheckedUpdateManyWithoutOrganizationsNestedInput
  }

  export type ReviewReplyUpsertWithWhereUniqueWithoutAiTemplateInput = {
    where: ReviewReplyWhereUniqueInput
    update: XOR<ReviewReplyUpdateWithoutAiTemplateInput, ReviewReplyUncheckedUpdateWithoutAiTemplateInput>
    create: XOR<ReviewReplyCreateWithoutAiTemplateInput, ReviewReplyUncheckedCreateWithoutAiTemplateInput>
  }

  export type ReviewReplyUpdateWithWhereUniqueWithoutAiTemplateInput = {
    where: ReviewReplyWhereUniqueInput
    data: XOR<ReviewReplyUpdateWithoutAiTemplateInput, ReviewReplyUncheckedUpdateWithoutAiTemplateInput>
  }

  export type ReviewReplyUpdateManyWithWhereWithoutAiTemplateInput = {
    where: ReviewReplyScalarWhereInput
    data: XOR<ReviewReplyUpdateManyMutationInput, ReviewReplyUncheckedUpdateManyWithoutAiTemplateInput>
  }

  export type LocationCreateWithoutInsightsInput = {
    id?: string
    name: string
    gmbLocationId: string
    gmbLocationName: string
    address?: string | null
    phone?: string | null
    websiteUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    timezone?: string
    isVerified?: boolean
    lastSyncedAt?: Date | string
    lastFetchedTimestamp?: Date | string | null
    autoReplyEnabled?: boolean
    autoPostEnabled?: boolean
    replyTonePreference?: $Enums.ReplyTone | null
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    logoUrl?: string | null
    gmbAccountId?: string | null
    organization: OrganizationCreateNestedOneWithoutLocationsInput
    posts?: PostCreateNestedManyWithoutLocationInput
    reports?: ReportCreateNestedManyWithoutLocationInput
    reviews?: ReviewCreateNestedManyWithoutLocationInput
    users?: UserCreateNestedManyWithoutLocationsInput
    searchKeywords?: SearchKeywordCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutInsightsInput = {
    id?: string
    name: string
    organizationId: string
    gmbLocationId: string
    gmbLocationName: string
    address?: string | null
    phone?: string | null
    websiteUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    timezone?: string
    isVerified?: boolean
    lastSyncedAt?: Date | string
    lastFetchedTimestamp?: Date | string | null
    autoReplyEnabled?: boolean
    autoPostEnabled?: boolean
    replyTonePreference?: $Enums.ReplyTone | null
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    logoUrl?: string | null
    gmbAccountId?: string | null
    posts?: PostUncheckedCreateNestedManyWithoutLocationInput
    reports?: ReportUncheckedCreateNestedManyWithoutLocationInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutLocationInput
    users?: UserUncheckedCreateNestedManyWithoutLocationsInput
    searchKeywords?: SearchKeywordUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutInsightsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutInsightsInput, LocationUncheckedCreateWithoutInsightsInput>
  }

  export type LocationUpsertWithoutInsightsInput = {
    update: XOR<LocationUpdateWithoutInsightsInput, LocationUncheckedUpdateWithoutInsightsInput>
    create: XOR<LocationCreateWithoutInsightsInput, LocationUncheckedCreateWithoutInsightsInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutInsightsInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutInsightsInput, LocationUncheckedUpdateWithoutInsightsInput>
  }

  export type LocationUpdateWithoutInsightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gmbLocationId?: StringFieldUpdateOperationsInput | string
    gmbLocationName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastSyncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastFetchedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoReplyEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoPostEnabled?: BoolFieldUpdateOperationsInput | boolean
    replyTonePreference?: NullableEnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gmbAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneRequiredWithoutLocationsNestedInput
    posts?: PostUpdateManyWithoutLocationNestedInput
    reports?: ReportUpdateManyWithoutLocationNestedInput
    reviews?: ReviewUpdateManyWithoutLocationNestedInput
    users?: UserUpdateManyWithoutLocationsNestedInput
    searchKeywords?: SearchKeywordUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutInsightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    gmbLocationId?: StringFieldUpdateOperationsInput | string
    gmbLocationName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastSyncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastFetchedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoReplyEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoPostEnabled?: BoolFieldUpdateOperationsInput | boolean
    replyTonePreference?: NullableEnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gmbAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: PostUncheckedUpdateManyWithoutLocationNestedInput
    reports?: ReportUncheckedUpdateManyWithoutLocationNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutLocationNestedInput
    users?: UserUncheckedUpdateManyWithoutLocationsNestedInput
    searchKeywords?: SearchKeywordUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationCreateWithoutReportsInput = {
    id?: string
    name: string
    gmbLocationId: string
    gmbLocationName: string
    address?: string | null
    phone?: string | null
    websiteUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    timezone?: string
    isVerified?: boolean
    lastSyncedAt?: Date | string
    lastFetchedTimestamp?: Date | string | null
    autoReplyEnabled?: boolean
    autoPostEnabled?: boolean
    replyTonePreference?: $Enums.ReplyTone | null
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    logoUrl?: string | null
    gmbAccountId?: string | null
    insights?: InsightCreateNestedManyWithoutLocationInput
    organization: OrganizationCreateNestedOneWithoutLocationsInput
    posts?: PostCreateNestedManyWithoutLocationInput
    reviews?: ReviewCreateNestedManyWithoutLocationInput
    users?: UserCreateNestedManyWithoutLocationsInput
    searchKeywords?: SearchKeywordCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutReportsInput = {
    id?: string
    name: string
    organizationId: string
    gmbLocationId: string
    gmbLocationName: string
    address?: string | null
    phone?: string | null
    websiteUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    timezone?: string
    isVerified?: boolean
    lastSyncedAt?: Date | string
    lastFetchedTimestamp?: Date | string | null
    autoReplyEnabled?: boolean
    autoPostEnabled?: boolean
    replyTonePreference?: $Enums.ReplyTone | null
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    logoUrl?: string | null
    gmbAccountId?: string | null
    insights?: InsightUncheckedCreateNestedManyWithoutLocationInput
    posts?: PostUncheckedCreateNestedManyWithoutLocationInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutLocationInput
    users?: UserUncheckedCreateNestedManyWithoutLocationsInput
    searchKeywords?: SearchKeywordUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutReportsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutReportsInput, LocationUncheckedCreateWithoutReportsInput>
  }

  export type LocationUpsertWithoutReportsInput = {
    update: XOR<LocationUpdateWithoutReportsInput, LocationUncheckedUpdateWithoutReportsInput>
    create: XOR<LocationCreateWithoutReportsInput, LocationUncheckedCreateWithoutReportsInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutReportsInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutReportsInput, LocationUncheckedUpdateWithoutReportsInput>
  }

  export type LocationUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gmbLocationId?: StringFieldUpdateOperationsInput | string
    gmbLocationName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastSyncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastFetchedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoReplyEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoPostEnabled?: BoolFieldUpdateOperationsInput | boolean
    replyTonePreference?: NullableEnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gmbAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    insights?: InsightUpdateManyWithoutLocationNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutLocationsNestedInput
    posts?: PostUpdateManyWithoutLocationNestedInput
    reviews?: ReviewUpdateManyWithoutLocationNestedInput
    users?: UserUpdateManyWithoutLocationsNestedInput
    searchKeywords?: SearchKeywordUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    gmbLocationId?: StringFieldUpdateOperationsInput | string
    gmbLocationName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastSyncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastFetchedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoReplyEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoPostEnabled?: BoolFieldUpdateOperationsInput | boolean
    replyTonePreference?: NullableEnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gmbAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    insights?: InsightUncheckedUpdateManyWithoutLocationNestedInput
    posts?: PostUncheckedUpdateManyWithoutLocationNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutLocationNestedInput
    users?: UserUncheckedUpdateManyWithoutLocationsNestedInput
    searchKeywords?: SearchKeywordUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type OrganizationCreateWithoutReportJobsInput = {
    id?: string
    name: string
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiTemplates?: AIReplyTemplateCreateNestedManyWithoutOrganizationInput
    locations?: LocationCreateNestedManyWithoutOrganizationInput
    owner: UserCreateNestedOneWithoutOwnedOrganizationsInput
    members?: UserCreateNestedManyWithoutOrganizationsInput
  }

  export type OrganizationUncheckedCreateWithoutReportJobsInput = {
    id?: string
    name: string
    logo?: string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    aiTemplates?: AIReplyTemplateUncheckedCreateNestedManyWithoutOrganizationInput
    locations?: LocationUncheckedCreateNestedManyWithoutOrganizationInput
    members?: UserUncheckedCreateNestedManyWithoutOrganizationsInput
  }

  export type OrganizationCreateOrConnectWithoutReportJobsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutReportJobsInput, OrganizationUncheckedCreateWithoutReportJobsInput>
  }

  export type OrganizationUpsertWithoutReportJobsInput = {
    update: XOR<OrganizationUpdateWithoutReportJobsInput, OrganizationUncheckedUpdateWithoutReportJobsInput>
    create: XOR<OrganizationCreateWithoutReportJobsInput, OrganizationUncheckedCreateWithoutReportJobsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutReportJobsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutReportJobsInput, OrganizationUncheckedUpdateWithoutReportJobsInput>
  }

  export type OrganizationUpdateWithoutReportJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiTemplates?: AIReplyTemplateUpdateManyWithoutOrganizationNestedInput
    locations?: LocationUpdateManyWithoutOrganizationNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedOrganizationsNestedInput
    members?: UserUpdateManyWithoutOrganizationsNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutReportJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiTemplates?: AIReplyTemplateUncheckedUpdateManyWithoutOrganizationNestedInput
    locations?: LocationUncheckedUpdateManyWithoutOrganizationNestedInput
    members?: UserUncheckedUpdateManyWithoutOrganizationsNestedInput
  }

  export type LocationCreateWithoutSearchKeywordsInput = {
    id?: string
    name: string
    gmbLocationId: string
    gmbLocationName: string
    address?: string | null
    phone?: string | null
    websiteUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    timezone?: string
    isVerified?: boolean
    lastSyncedAt?: Date | string
    lastFetchedTimestamp?: Date | string | null
    autoReplyEnabled?: boolean
    autoPostEnabled?: boolean
    replyTonePreference?: $Enums.ReplyTone | null
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    logoUrl?: string | null
    gmbAccountId?: string | null
    insights?: InsightCreateNestedManyWithoutLocationInput
    organization: OrganizationCreateNestedOneWithoutLocationsInput
    posts?: PostCreateNestedManyWithoutLocationInput
    reports?: ReportCreateNestedManyWithoutLocationInput
    reviews?: ReviewCreateNestedManyWithoutLocationInput
    users?: UserCreateNestedManyWithoutLocationsInput
  }

  export type LocationUncheckedCreateWithoutSearchKeywordsInput = {
    id?: string
    name: string
    organizationId: string
    gmbLocationId: string
    gmbLocationName: string
    address?: string | null
    phone?: string | null
    websiteUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    timezone?: string
    isVerified?: boolean
    lastSyncedAt?: Date | string
    lastFetchedTimestamp?: Date | string | null
    autoReplyEnabled?: boolean
    autoPostEnabled?: boolean
    replyTonePreference?: $Enums.ReplyTone | null
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    logoUrl?: string | null
    gmbAccountId?: string | null
    insights?: InsightUncheckedCreateNestedManyWithoutLocationInput
    posts?: PostUncheckedCreateNestedManyWithoutLocationInput
    reports?: ReportUncheckedCreateNestedManyWithoutLocationInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutLocationInput
    users?: UserUncheckedCreateNestedManyWithoutLocationsInput
  }

  export type LocationCreateOrConnectWithoutSearchKeywordsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutSearchKeywordsInput, LocationUncheckedCreateWithoutSearchKeywordsInput>
  }

  export type RankTrackingResultCreateWithoutKeywordInput = {
    id?: string
    rankPosition?: number | null
    searchDate?: Date | string
    searchUrl?: string | null
    businessUrl?: string | null
    businessName?: string | null
    htmlSnapshot?: string | null
    createdAt?: Date | string
  }

  export type RankTrackingResultUncheckedCreateWithoutKeywordInput = {
    id?: string
    rankPosition?: number | null
    searchDate?: Date | string
    searchUrl?: string | null
    businessUrl?: string | null
    businessName?: string | null
    htmlSnapshot?: string | null
    createdAt?: Date | string
  }

  export type RankTrackingResultCreateOrConnectWithoutKeywordInput = {
    where: RankTrackingResultWhereUniqueInput
    create: XOR<RankTrackingResultCreateWithoutKeywordInput, RankTrackingResultUncheckedCreateWithoutKeywordInput>
  }

  export type RankTrackingResultCreateManyKeywordInputEnvelope = {
    data: RankTrackingResultCreateManyKeywordInput | RankTrackingResultCreateManyKeywordInput[]
    skipDuplicates?: boolean
  }

  export type LocationUpsertWithoutSearchKeywordsInput = {
    update: XOR<LocationUpdateWithoutSearchKeywordsInput, LocationUncheckedUpdateWithoutSearchKeywordsInput>
    create: XOR<LocationCreateWithoutSearchKeywordsInput, LocationUncheckedCreateWithoutSearchKeywordsInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutSearchKeywordsInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutSearchKeywordsInput, LocationUncheckedUpdateWithoutSearchKeywordsInput>
  }

  export type LocationUpdateWithoutSearchKeywordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gmbLocationId?: StringFieldUpdateOperationsInput | string
    gmbLocationName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastSyncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastFetchedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoReplyEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoPostEnabled?: BoolFieldUpdateOperationsInput | boolean
    replyTonePreference?: NullableEnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gmbAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    insights?: InsightUpdateManyWithoutLocationNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutLocationsNestedInput
    posts?: PostUpdateManyWithoutLocationNestedInput
    reports?: ReportUpdateManyWithoutLocationNestedInput
    reviews?: ReviewUpdateManyWithoutLocationNestedInput
    users?: UserUpdateManyWithoutLocationsNestedInput
  }

  export type LocationUncheckedUpdateWithoutSearchKeywordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    gmbLocationId?: StringFieldUpdateOperationsInput | string
    gmbLocationName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastSyncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastFetchedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoReplyEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoPostEnabled?: BoolFieldUpdateOperationsInput | boolean
    replyTonePreference?: NullableEnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gmbAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    insights?: InsightUncheckedUpdateManyWithoutLocationNestedInput
    posts?: PostUncheckedUpdateManyWithoutLocationNestedInput
    reports?: ReportUncheckedUpdateManyWithoutLocationNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutLocationNestedInput
    users?: UserUncheckedUpdateManyWithoutLocationsNestedInput
  }

  export type RankTrackingResultUpsertWithWhereUniqueWithoutKeywordInput = {
    where: RankTrackingResultWhereUniqueInput
    update: XOR<RankTrackingResultUpdateWithoutKeywordInput, RankTrackingResultUncheckedUpdateWithoutKeywordInput>
    create: XOR<RankTrackingResultCreateWithoutKeywordInput, RankTrackingResultUncheckedCreateWithoutKeywordInput>
  }

  export type RankTrackingResultUpdateWithWhereUniqueWithoutKeywordInput = {
    where: RankTrackingResultWhereUniqueInput
    data: XOR<RankTrackingResultUpdateWithoutKeywordInput, RankTrackingResultUncheckedUpdateWithoutKeywordInput>
  }

  export type RankTrackingResultUpdateManyWithWhereWithoutKeywordInput = {
    where: RankTrackingResultScalarWhereInput
    data: XOR<RankTrackingResultUpdateManyMutationInput, RankTrackingResultUncheckedUpdateManyWithoutKeywordInput>
  }

  export type RankTrackingResultScalarWhereInput = {
    AND?: RankTrackingResultScalarWhereInput | RankTrackingResultScalarWhereInput[]
    OR?: RankTrackingResultScalarWhereInput[]
    NOT?: RankTrackingResultScalarWhereInput | RankTrackingResultScalarWhereInput[]
    id?: StringFilter<"RankTrackingResult"> | string
    keywordId?: StringFilter<"RankTrackingResult"> | string
    rankPosition?: IntNullableFilter<"RankTrackingResult"> | number | null
    searchDate?: DateTimeFilter<"RankTrackingResult"> | Date | string
    searchUrl?: StringNullableFilter<"RankTrackingResult"> | string | null
    businessUrl?: StringNullableFilter<"RankTrackingResult"> | string | null
    businessName?: StringNullableFilter<"RankTrackingResult"> | string | null
    htmlSnapshot?: StringNullableFilter<"RankTrackingResult"> | string | null
    createdAt?: DateTimeFilter<"RankTrackingResult"> | Date | string
  }

  export type SearchKeywordCreateWithoutRankResultsInput = {
    id?: string
    keyword: string
    latitude: number
    longitude: number
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutSearchKeywordsInput
  }

  export type SearchKeywordUncheckedCreateWithoutRankResultsInput = {
    id?: string
    keyword: string
    locationId: string
    latitude: number
    longitude: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SearchKeywordCreateOrConnectWithoutRankResultsInput = {
    where: SearchKeywordWhereUniqueInput
    create: XOR<SearchKeywordCreateWithoutRankResultsInput, SearchKeywordUncheckedCreateWithoutRankResultsInput>
  }

  export type SearchKeywordUpsertWithoutRankResultsInput = {
    update: XOR<SearchKeywordUpdateWithoutRankResultsInput, SearchKeywordUncheckedUpdateWithoutRankResultsInput>
    create: XOR<SearchKeywordCreateWithoutRankResultsInput, SearchKeywordUncheckedCreateWithoutRankResultsInput>
    where?: SearchKeywordWhereInput
  }

  export type SearchKeywordUpdateToOneWithWhereWithoutRankResultsInput = {
    where?: SearchKeywordWhereInput
    data: XOR<SearchKeywordUpdateWithoutRankResultsInput, SearchKeywordUncheckedUpdateWithoutRankResultsInput>
  }

  export type SearchKeywordUpdateWithoutRankResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutSearchKeywordsNestedInput
  }

  export type SearchKeywordUncheckedUpdateWithoutRankResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateManyOwnerInput = {
    id?: string
    name: string
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostCreateManyUserInput = {
    id?: string
    locationId: string
    title: string
    content: string
    type: $Enums.PostType
    mediaUrls?: PostCreatemediaUrlsInput | string[]
    scheduledAt: Date | string
    publishedAt?: Date | string | null
    status?: $Enums.PostStatus
    eventStart?: Date | string | null
    eventEnd?: Date | string | null
    offerStart?: Date | string | null
    offerEnd?: Date | string | null
    couponCode?: string | null
    callToAction?: string | null
    recurType?: $Enums.RecurType | null
    recurEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewReplyCreateManyUserInput = {
    id?: string
    reviewId: string
    content: string
    source: $Enums.ReplySource
    tone?: $Enums.ReplyTone
    isPublished?: boolean
    publishedAt?: Date | string | null
    aiTemplateId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type OrganizationUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiTemplates?: AIReplyTemplateUpdateManyWithoutOrganizationNestedInput
    locations?: LocationUpdateManyWithoutOrganizationNestedInput
    reportJobs?: ReportJobUpdateManyWithoutOrganizationNestedInput
    members?: UserUpdateManyWithoutOrganizationsNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiTemplates?: AIReplyTemplateUncheckedUpdateManyWithoutOrganizationNestedInput
    locations?: LocationUncheckedUpdateManyWithoutOrganizationNestedInput
    reportJobs?: ReportJobUncheckedUpdateManyWithoutOrganizationNestedInput
    members?: UserUncheckedUpdateManyWithoutOrganizationsNestedInput
  }

  export type OrganizationUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    mediaUrls?: PostUpdatemediaUrlsInput | string[]
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    eventStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offerStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offerEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    callToAction?: NullableStringFieldUpdateOperationsInput | string | null
    recurType?: NullableEnumRecurTypeFieldUpdateOperationsInput | $Enums.RecurType | null
    recurEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    mediaUrls?: PostUpdatemediaUrlsInput | string[]
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    eventStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offerStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offerEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    callToAction?: NullableStringFieldUpdateOperationsInput | string | null
    recurType?: NullableEnumRecurTypeFieldUpdateOperationsInput | $Enums.RecurType | null
    recurEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    mediaUrls?: PostUpdatemediaUrlsInput | string[]
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    eventStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offerStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offerEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    callToAction?: NullableStringFieldUpdateOperationsInput | string | null
    recurType?: NullableEnumRecurTypeFieldUpdateOperationsInput | $Enums.RecurType | null
    recurEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewReplyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    source?: EnumReplySourceFieldUpdateOperationsInput | $Enums.ReplySource
    tone?: EnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiTemplate?: AIReplyTemplateUpdateOneWithoutRepliesNestedInput
    review?: ReviewUpdateOneRequiredWithoutRepliesNestedInput
  }

  export type ReviewReplyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    source?: EnumReplySourceFieldUpdateOperationsInput | $Enums.ReplySource
    tone?: EnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewReplyUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    source?: EnumReplySourceFieldUpdateOperationsInput | $Enums.ReplySource
    tone?: EnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gmbLocationId?: StringFieldUpdateOperationsInput | string
    gmbLocationName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastSyncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastFetchedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoReplyEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoPostEnabled?: BoolFieldUpdateOperationsInput | boolean
    replyTonePreference?: NullableEnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gmbAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    insights?: InsightUpdateManyWithoutLocationNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutLocationsNestedInput
    posts?: PostUpdateManyWithoutLocationNestedInput
    reports?: ReportUpdateManyWithoutLocationNestedInput
    reviews?: ReviewUpdateManyWithoutLocationNestedInput
    searchKeywords?: SearchKeywordUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    gmbLocationId?: StringFieldUpdateOperationsInput | string
    gmbLocationName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastSyncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastFetchedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoReplyEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoPostEnabled?: BoolFieldUpdateOperationsInput | boolean
    replyTonePreference?: NullableEnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gmbAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    insights?: InsightUncheckedUpdateManyWithoutLocationNestedInput
    posts?: PostUncheckedUpdateManyWithoutLocationNestedInput
    reports?: ReportUncheckedUpdateManyWithoutLocationNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutLocationNestedInput
    searchKeywords?: SearchKeywordUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    gmbLocationId?: StringFieldUpdateOperationsInput | string
    gmbLocationName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastSyncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastFetchedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoReplyEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoPostEnabled?: BoolFieldUpdateOperationsInput | boolean
    replyTonePreference?: NullableEnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gmbAccountId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrganizationUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiTemplates?: AIReplyTemplateUpdateManyWithoutOrganizationNestedInput
    locations?: LocationUpdateManyWithoutOrganizationNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedOrganizationsNestedInput
    reportJobs?: ReportJobUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiTemplates?: AIReplyTemplateUncheckedUpdateManyWithoutOrganizationNestedInput
    locations?: LocationUncheckedUpdateManyWithoutOrganizationNestedInput
    reportJobs?: ReportJobUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateManyWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIReplyTemplateCreateManyOrganizationInput = {
    id?: string
    name: string
    content: string
    tone?: $Enums.ReplyTone
    sentiment: $Enums.SentimentType
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationCreateManyOrganizationInput = {
    id?: string
    name: string
    gmbLocationId: string
    gmbLocationName: string
    address?: string | null
    phone?: string | null
    websiteUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    timezone?: string
    isVerified?: boolean
    lastSyncedAt?: Date | string
    lastFetchedTimestamp?: Date | string | null
    autoReplyEnabled?: boolean
    autoPostEnabled?: boolean
    replyTonePreference?: $Enums.ReplyTone | null
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    logoUrl?: string | null
    gmbAccountId?: string | null
  }

  export type ReportJobCreateManyOrganizationInput = {
    id?: string
    name: string
    locations?: ReportJobCreatelocationsInput | string[]
    frequency: $Enums.ReportFrequency
    emailRecipients?: ReportJobCreateemailRecipientsInput | string[]
    isActive?: boolean
    lastRunAt?: Date | string | null
    nextRunAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIReplyTemplateUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: EnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone
    sentiment?: EnumSentimentTypeFieldUpdateOperationsInput | $Enums.SentimentType
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: ReviewReplyUpdateManyWithoutAiTemplateNestedInput
  }

  export type AIReplyTemplateUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: EnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone
    sentiment?: EnumSentimentTypeFieldUpdateOperationsInput | $Enums.SentimentType
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: ReviewReplyUncheckedUpdateManyWithoutAiTemplateNestedInput
  }

  export type AIReplyTemplateUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: EnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone
    sentiment?: EnumSentimentTypeFieldUpdateOperationsInput | $Enums.SentimentType
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gmbLocationId?: StringFieldUpdateOperationsInput | string
    gmbLocationName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastSyncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastFetchedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoReplyEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoPostEnabled?: BoolFieldUpdateOperationsInput | boolean
    replyTonePreference?: NullableEnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gmbAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    insights?: InsightUpdateManyWithoutLocationNestedInput
    posts?: PostUpdateManyWithoutLocationNestedInput
    reports?: ReportUpdateManyWithoutLocationNestedInput
    reviews?: ReviewUpdateManyWithoutLocationNestedInput
    users?: UserUpdateManyWithoutLocationsNestedInput
    searchKeywords?: SearchKeywordUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gmbLocationId?: StringFieldUpdateOperationsInput | string
    gmbLocationName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastSyncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastFetchedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoReplyEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoPostEnabled?: BoolFieldUpdateOperationsInput | boolean
    replyTonePreference?: NullableEnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gmbAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    insights?: InsightUncheckedUpdateManyWithoutLocationNestedInput
    posts?: PostUncheckedUpdateManyWithoutLocationNestedInput
    reports?: ReportUncheckedUpdateManyWithoutLocationNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutLocationNestedInput
    users?: UserUncheckedUpdateManyWithoutLocationsNestedInput
    searchKeywords?: SearchKeywordUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gmbLocationId?: StringFieldUpdateOperationsInput | string
    gmbLocationName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastSyncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastFetchedTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoReplyEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoPostEnabled?: BoolFieldUpdateOperationsInput | boolean
    replyTonePreference?: NullableEnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gmbAccountId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportJobUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    locations?: ReportJobUpdatelocationsInput | string[]
    frequency?: EnumReportFrequencyFieldUpdateOperationsInput | $Enums.ReportFrequency
    emailRecipients?: ReportJobUpdateemailRecipientsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportJobUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    locations?: ReportJobUpdatelocationsInput | string[]
    frequency?: EnumReportFrequencyFieldUpdateOperationsInput | $Enums.ReportFrequency
    emailRecipients?: ReportJobUpdateemailRecipientsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportJobUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    locations?: ReportJobUpdatelocationsInput | string[]
    frequency?: EnumReportFrequencyFieldUpdateOperationsInput | $Enums.ReportFrequency
    emailRecipients?: ReportJobUpdateemailRecipientsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    subscriptionPlan?: NullableEnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan | null
    trialStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    ownedOrganizations?: OrganizationUpdateManyWithoutOwnerNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    reviewReplies?: ReviewReplyUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    locations?: LocationUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    subscriptionPlan?: NullableEnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan | null
    trialStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    ownedOrganizations?: OrganizationUncheckedUpdateManyWithoutOwnerNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    reviewReplies?: ReviewReplyUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    locations?: LocationUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateManyWithoutOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    subscriptionPlan?: NullableEnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan | null
    trialStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InsightCreateManyLocationInput = {
    id?: string
    date: Date | string
    type: $Enums.InsightType
    value: number
    createdAt?: Date | string
  }

  export type PostCreateManyLocationInput = {
    id?: string
    userId: string
    title: string
    content: string
    type: $Enums.PostType
    mediaUrls?: PostCreatemediaUrlsInput | string[]
    scheduledAt: Date | string
    publishedAt?: Date | string | null
    status?: $Enums.PostStatus
    eventStart?: Date | string | null
    eventEnd?: Date | string | null
    offerStart?: Date | string | null
    offerEnd?: Date | string | null
    couponCode?: string | null
    callToAction?: string | null
    recurType?: $Enums.RecurType | null
    recurEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportCreateManyLocationInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    reportType: $Enums.ReportType
    fileUrl?: string | null
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyLocationInput = {
    id?: string
    reviewId: string
    authorName: string
    authorPhoto?: string | null
    rating: number
    comment?: string | null
    createTime: Date | string
    updateTime: Date | string
    status?: $Enums.ReviewStatus
    isProcessed?: boolean
    sentiment?: $Enums.SentimentType | null
    language?: string | null
    isReplyNeeded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SearchKeywordCreateManyLocationInput = {
    id?: string
    keyword: string
    latitude: number
    longitude: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InsightUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumInsightTypeFieldUpdateOperationsInput | $Enums.InsightType
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumInsightTypeFieldUpdateOperationsInput | $Enums.InsightType
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumInsightTypeFieldUpdateOperationsInput | $Enums.InsightType
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    mediaUrls?: PostUpdatemediaUrlsInput | string[]
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    eventStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offerStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offerEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    callToAction?: NullableStringFieldUpdateOperationsInput | string | null
    recurType?: NullableEnumRecurTypeFieldUpdateOperationsInput | $Enums.RecurType | null
    recurEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    mediaUrls?: PostUpdatemediaUrlsInput | string[]
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    eventStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offerStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offerEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    callToAction?: NullableStringFieldUpdateOperationsInput | string | null
    recurType?: NullableEnumRecurTypeFieldUpdateOperationsInput | $Enums.RecurType | null
    recurEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    mediaUrls?: PostUpdatemediaUrlsInput | string[]
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    eventStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offerStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offerEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    callToAction?: NullableStringFieldUpdateOperationsInput | string | null
    recurType?: NullableEnumRecurTypeFieldUpdateOperationsInput | $Enums.RecurType | null
    recurEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createTime?: DateTimeFieldUpdateOperationsInput | Date | string
    updateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    sentiment?: NullableEnumSentimentTypeFieldUpdateOperationsInput | $Enums.SentimentType | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isReplyNeeded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: ReviewReplyUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createTime?: DateTimeFieldUpdateOperationsInput | Date | string
    updateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    sentiment?: NullableEnumSentimentTypeFieldUpdateOperationsInput | $Enums.SentimentType | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isReplyNeeded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: ReviewReplyUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createTime?: DateTimeFieldUpdateOperationsInput | Date | string
    updateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    sentiment?: NullableEnumSentimentTypeFieldUpdateOperationsInput | $Enums.SentimentType | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    isReplyNeeded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    subscriptionPlan?: NullableEnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan | null
    trialStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    ownedOrganizations?: OrganizationUpdateManyWithoutOwnerNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    reviewReplies?: ReviewReplyUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    organizations?: OrganizationUpdateManyWithoutMembersNestedInput
  }

  export type UserUncheckedUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    subscriptionPlan?: NullableEnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan | null
    trialStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    ownedOrganizations?: OrganizationUncheckedUpdateManyWithoutOwnerNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    reviewReplies?: ReviewReplyUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    organizations?: OrganizationUncheckedUpdateManyWithoutMembersNestedInput
  }

  export type UserUncheckedUpdateManyWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    subscriptionPlan?: NullableEnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan | null
    trialStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SearchKeywordUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rankResults?: RankTrackingResultUpdateManyWithoutKeywordNestedInput
  }

  export type SearchKeywordUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rankResults?: RankTrackingResultUncheckedUpdateManyWithoutKeywordNestedInput
  }

  export type SearchKeywordUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewReplyCreateManyReviewInput = {
    id?: string
    userId?: string | null
    content: string
    source: $Enums.ReplySource
    tone?: $Enums.ReplyTone
    isPublished?: boolean
    publishedAt?: Date | string | null
    aiTemplateId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewReplyUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    source?: EnumReplySourceFieldUpdateOperationsInput | $Enums.ReplySource
    tone?: EnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiTemplate?: AIReplyTemplateUpdateOneWithoutRepliesNestedInput
    user?: UserUpdateOneWithoutReviewRepliesNestedInput
  }

  export type ReviewReplyUncheckedUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    source?: EnumReplySourceFieldUpdateOperationsInput | $Enums.ReplySource
    tone?: EnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewReplyUncheckedUpdateManyWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    source?: EnumReplySourceFieldUpdateOperationsInput | $Enums.ReplySource
    tone?: EnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewReplyCreateManyAiTemplateInput = {
    id?: string
    reviewId: string
    userId?: string | null
    content: string
    source: $Enums.ReplySource
    tone?: $Enums.ReplyTone
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewReplyUpdateWithoutAiTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    source?: EnumReplySourceFieldUpdateOperationsInput | $Enums.ReplySource
    tone?: EnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ReviewUpdateOneRequiredWithoutRepliesNestedInput
    user?: UserUpdateOneWithoutReviewRepliesNestedInput
  }

  export type ReviewReplyUncheckedUpdateWithoutAiTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    source?: EnumReplySourceFieldUpdateOperationsInput | $Enums.ReplySource
    tone?: EnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewReplyUncheckedUpdateManyWithoutAiTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    source?: EnumReplySourceFieldUpdateOperationsInput | $Enums.ReplySource
    tone?: EnumReplyToneFieldUpdateOperationsInput | $Enums.ReplyTone
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RankTrackingResultCreateManyKeywordInput = {
    id?: string
    rankPosition?: number | null
    searchDate?: Date | string
    searchUrl?: string | null
    businessUrl?: string | null
    businessName?: string | null
    htmlSnapshot?: string | null
    createdAt?: Date | string
  }

  export type RankTrackingResultUpdateWithoutKeywordInput = {
    id?: StringFieldUpdateOperationsInput | string
    rankPosition?: NullableIntFieldUpdateOperationsInput | number | null
    searchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    searchUrl?: NullableStringFieldUpdateOperationsInput | string | null
    businessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    htmlSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RankTrackingResultUncheckedUpdateWithoutKeywordInput = {
    id?: StringFieldUpdateOperationsInput | string
    rankPosition?: NullableIntFieldUpdateOperationsInput | number | null
    searchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    searchUrl?: NullableStringFieldUpdateOperationsInput | string | null
    businessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    htmlSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RankTrackingResultUncheckedUpdateManyWithoutKeywordInput = {
    id?: StringFieldUpdateOperationsInput | string
    rankPosition?: NullableIntFieldUpdateOperationsInput | number | null
    searchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    searchUrl?: NullableStringFieldUpdateOperationsInput | string | null
    businessUrl?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    htmlSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}